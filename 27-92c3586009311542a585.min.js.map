{"version":3,"file":"27-92c3586009311542a585.min.js","mappings":"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","sources":["webpack://graphPlayground/./src/js/workers/GraphAlgorithmWorker.ts","webpack://graphPlayground/./src/js/GraphAlgorithms.ts","webpack://graphPlayground/./src/js/classes/SpanningTree.ts"],"sourcesContent":["import GraphAlgorithms from \"../GraphAlgorithms\";\nconst ctx: Worker = self as any;\n\nlet myID: number;\n\nfunction sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nctx.addEventListener(\"message\", async e => {\n    if (e.data.type === \"id\") {\n        myID = e.data.id;\n        return;\n    }\n    const args: any[] = e.data.args;\n    if (e.data.type === \"test\") {\n        await sleep(e.data.waitTime);\n        ctx.postMessage({ id: myID, data: \"DONE\" });\n        return;\n    }\n    if (\"convertToGraphImmut\" in e.data && e.data.convertToGraphImmut) {\n        args.push(GraphAlgorithms.graphPlainToGraphImmut(e.data.graph));\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\n    } else {\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\n    }\n});\n","\"use strict\";\n\nimport genericH from \"./util/genericHelpers\";\nimport graphH from \"./util/graphHelpers\";\nimport SpanningTree from \"./classes/SpanningTree\";\nimport EdgeImmut, { EdgeImmutPlain } from \"./classes/GraphImmut/EdgeImmut\";\nimport NodeImmut from \"./classes/GraphImmut/NodeImmut\";\nimport GraphImmut from \"./classes/GraphImmut/GraphImmut\";\nimport GraphState from \"./graphState\";\nimport { GraphPlain } from \"./util/predefinedGraphs\";\n\ntype EdgeFlowProp = { from: number; to: number; capacity: number; flow: number };\nexport type MSTResult = { mst: EdgeImmutPlain[]; totalWeight: number };\nexport type FlowResult = { maxFlow: number; flowPath: EdgeFlowProp[] };\nexport type ShortestPathResult = {\n    pathExists: boolean;\n    path: number[];\n    distance: number;\n    cost?: number;\n    weight?: number;\n};\nexport type ConnectedComponentResult = { components: { [key: number]: number }; count: number };\n\nexport default class GraphAlgorithms {\n    public static graphPlainToGraphImmut = (gp: GraphPlain): GraphImmut => {\n        return new GraphImmut(gp.nodes, gp.edges, gp.directed, gp.weighted);\n    };\n\n    // Welsh-Powell Algorithm\n    public static colorNetwork = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number } => {\n        // Get node ID's only\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\n\n        // Put vertices in array in decreasing order of degree\n        const degrees = G.getAllOutDegrees();\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\n        });\n\n        const colorIndex: { [key: number]: number } = {};\n        let currentColor = 0;\n        while (vertexOrder.length > 0) {\n            const root = vertexOrder.shift()!;\n            colorIndex[root] = currentColor;\n\n            const myGroup = [];\n            myGroup.push(root);\n\n            for (let i = 0; i < vertexOrder.length; ) {\n                const p = vertexOrder[i];\n                let conflict = false;\n\n                for (let j = 0; j < myGroup.length; j++) {\n                    if (G.areAdjacent(p, myGroup[j])) {\n                        i++;\n                        conflict = true;\n                        break;\n                    }\n                }\n                if (conflict) {\n                    continue;\n                }\n\n                colorIndex[p] = currentColor;\n                myGroup.push(p);\n                vertexOrder.splice(i, 1);\n            }\n\n            currentColor++;\n        }\n\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\n        return { colors: colorIndex, chromaticNumber };\n    };\n\n    public static connectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n        const setComponentNum = (v: number) => {\n            components[v] = componentCount;\n        };\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in components)) {\n                const visited = GraphAlgorithms.depthFirstSearch(i, G);\n                visited.forEach(setComponentNum);\n                componentCount++;\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static depthFirstSearch = (start: number, G = GraphState.graph): number[] => {\n        const visisted: number[] = [];\n        const Stack: number[] = [];\n        Stack.push(start);\n        while (Stack.length > 0) {\n            const v = Stack.pop()!;\n            if (!visisted.includes(v)) {\n                visisted.push(v);\n                G.getNodeAdjacency(v).forEach(nodeID => {\n                    Stack.push(nodeID);\n                });\n            }\n        }\n\n        return visisted;\n    };\n\n    // Tarjan's algorithm\n    public static stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\n        let index = 0;\n        const indices: { [key: number]: number } = {};\n        const lowlink: { [key: number]: number } = {};\n        const S: number[] = [];\n        const components: { [key: number]: number } = {};\n        let componentCount = 0;\n\n        const strongConnect = (v: number) => {\n            indices[v] = index;\n            lowlink[v] = index++;\n            S.push(v);\n\n            G.getNodeAdjacency(v).forEach(w => {\n                if (!(w in indices)) {\n                    strongConnect(w);\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\n                } else if (S.includes(w)) {\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\n                }\n            });\n\n            if (lowlink[v] === indices[v]) {\n                let w = -1;\n                if (S.length > 0) {\n                    do {\n                        w = S.pop()!;\n                        components[w] = componentCount;\n                    } while (w !== v);\n                    componentCount++;\n                }\n            }\n        };\n\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\n            if (!(i in indices)) {\n                strongConnect(i);\n            }\n        }\n\n        return { components, count: componentCount };\n    };\n\n    public static breadthFirstSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult => {\n        // Perform the BFS\n        const visisted: number[] = [];\n        const Q: number[] = []; // Use Push and Shift for Queue operations\n        const edgeTo: { [key: number]: number } = {};\n\n        Q.push(startNodeID);\n        while (Q.length > 0) {\n            const x = Q.shift()!;\n            if (!visisted.includes(x)) {\n                visisted.push(x);\n                G.getNodeAdjacency(x).forEach(y => {\n                    if (!visisted.includes(y)) {\n                        edgeTo[y] = x;\n                        Q.push(y);\n                    }\n                });\n            }\n        }\n\n        if (visisted.includes(targetNodeID)) {\n            // Build the path\n            const path = [];\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\n                path.push(x);\n            }\n            path.push(startNodeID);\n            path.reverse();\n\n            // Get the path weight\n            let weight = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\n            }\n\n            return { pathExists: true, path, distance: path.length, weight };\n        }\n\n        return { pathExists: false, path: [], distance: -1, weight: -1 };\n    };\n\n    public static dijkstraSearch = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        if (!G.isDirected()) {\n            G = G.asDirected(true);\n        }\n        if (!G.isWeighted()) {\n            G = G.asWeighted();\n        }\n\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find(edge => {\n            return edge.getWeight() < 0;\n        });\n        if (typeof nonNegative !== \"undefined\") {\n            return false;\n        }\n\n        // Priority Queue implementation for Dijkstra\n        class PriorityQueue {\n            private readonly _nodes: { key: number | string; priority: number }[] = [];\n\n            enqueue(priority: number, key: number): void {\n                this._nodes.push({ key, priority });\n                this.sort();\n            }\n\n            dequeue(): number | string {\n                return this._nodes.shift()!.key;\n            }\n\n            sort(): void {\n                this._nodes.sort((a: { priority: number }, b: { priority: number }) => {\n                    return a.priority - b.priority;\n                });\n            }\n\n            isEmpty(): boolean {\n                return !this._nodes.length;\n            }\n        }\n\n        const queue = new PriorityQueue();\n        const distances: { [key: number]: number } = {};\n        const previous: { [key: number]: number | null } = {};\n        let path = [];\n\n        // Initialize Queue and distances\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            let dist = Infinity;\n            if (node.getID() === startNodeID) {\n                dist = 0;\n            }\n\n            distances[node.getID()] = dist;\n            queue.enqueue(dist, node.getID());\n            previous[node.getID()] = null;\n        });\n\n        while (!queue.isEmpty()) {\n            let smallest = queue.dequeue() as number;\n\n            if (smallest === targetNodeID) {\n                path = [];\n                while (previous[smallest] !== null) {\n                    path.push(smallest);\n                    smallest = previous[smallest]!;\n                }\n                break;\n            }\n\n            if (distances[smallest] === Infinity) {\n                continue;\n            }\n\n            G.getNodeAdjacency(smallest).forEach(neighbor => {\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\n\n                if (alt < distances[neighbor]) {\n                    distances[neighbor] = alt;\n                    previous[neighbor] = smallest;\n\n                    queue.enqueue(alt, neighbor);\n                }\n            });\n        }\n\n        path.push(startNodeID);\n        path.reverse();\n\n        if (distances[targetNodeID] !== Infinity) {\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static bellmanFord = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): ShortestPathResult | boolean => {\n        const distances: number[] = [];\n        const parents: (number | null)[] = [];\n\n        // Initialize\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\n            distances[node.getID()] = Infinity;\n            parents[node.getID()] = null;\n        });\n\n        // Relax Edges\n        distances[startNodeID] = 0;\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\n            (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\n                    parents[edge.getTo()] = edge.getFrom();\n                }\n            });\n        }\n\n        // Check for negative weight cycles\n        let negativeCylce = false;\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\n                negativeCylce = true;\n            }\n        });\n\n        if (distances[targetNodeID] !== Infinity) {\n            const path: number[] = [targetNodeID];\n            while (!path.includes(startNodeID)) {\n                path.push(parents[path.slice().pop()!] as number);\n            }\n            path.reverse();\n\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\n        }\n\n        if (negativeCylce) {\n            return false;\n        }\n\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\n    };\n\n    public static fordFulkerson = (\n        startNodeID: number,\n        targetNodeID: number,\n        G: GraphImmut = GraphState.graph\n    ): boolean | FlowResult => {\n        // Must be a directed graph\n        if (!G.isDirected()) {\n            return false;\n        }\n\n        // Source == sink\n        if (startNodeID === targetNodeID) {\n            return false;\n        }\n\n        const bfs = GraphAlgorithms.breadthFirstSearch(startNodeID, targetNodeID, G);\n        // No path from source to sink\n        if (!bfs.pathExists) {\n            return false;\n        }\n\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\n        G = G.reduceMultiGraph((a, b) => {\n            return a + b;\n        }, 0);\n\n        const V = G.getNumberOfNodes();\n        let value = 0;\n        let marked: boolean[] = [];\n        let edgeTo: (string | null)[] = [];\n\n        const edgeProperties: { [key: string]: EdgeFlowProp } = {};\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\n                from: edge.getFrom(),\n                to: edge.getTo(),\n                capacity: edge.getWeight(),\n                flow: 0\n            };\n        });\n\n        const other = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            const b = parseInt(edge[1]);\n            return x === a ? b : a;\n        };\n\n        const residualCapacity = (e: string, x: number) => {\n            const edge = e.split(\"_\");\n            const a = parseInt(edge[0]);\n            if (x === a) {\n                return edgeProperties[e].flow;\n            }\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\n        };\n\n        const addResidualFlow = (e: string, x: number, deltaFlow: number) => {\n            const edge = e.split(\"_\");\n            const v = parseInt(edge[0]);\n            if (x === v) {\n                edgeProperties[e].flow -= deltaFlow;\n            } else {\n                edgeProperties[e].flow += deltaFlow;\n            }\n        };\n\n        const hasAugmentedPath = () => {\n            marked = [];\n            edgeTo = [];\n            for (let v = 0; v < V; ++v) {\n                marked.push(false);\n                edgeTo.push(null);\n            }\n\n            const queue = [];\n            queue.push(startNodeID);\n\n            marked[startNodeID] = true;\n            while (queue.length > 0) {\n                const v = queue.shift()!;\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    const w = other(e, v);\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\n                        edgeTo[w] = e;\n                        marked[w] = true;\n                        if (w === targetNodeID) {\n                            return true;\n                        }\n\n                        queue.push(w);\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        while (hasAugmentedPath()) {\n            let bottleneckValue = Infinity;\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x]!, x));\n            }\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\n                addResidualFlow(edgeTo[x]!, x, bottleneckValue);\n            }\n            value += bottleneckValue;\n        }\n\n        const getFlows = (): EdgeFlowProp[] => {\n            const f: EdgeFlowProp[] = [];\n            for (let v = 0; v < V; v++) {\n                const vertexAdjacency = G.getNodeAdjacency(v);\n                for (const i of vertexAdjacency) {\n                    const e = `${v}_${i}`;\n                    if (edgeProperties[e].flow > 0) {\n                        f.push(edgeProperties[e]);\n                    }\n                }\n            }\n\n            return f;\n        };\n\n        return { maxFlow: value, flowPath: getFlows() };\n    };\n\n    public static kruskal = (G: GraphImmut = GraphState.graph): MSTResult => {\n        // If we have a multigraph, reduce it by using the minimum edge weights\n        G.reduceMultiGraph();\n\n        const Q: EdgeImmut[] = G.getAllEdges(true) as EdgeImmut[];\n\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\n        Q.sort((a, b) => {\n            return a.getWeight() - b.getWeight();\n        });\n\n        const kruskal: EdgeImmut[] = [];\n        const set = new SpanningTree(G.getNumberOfNodes());\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\n            const e = Q.shift()!;\n            if (!set.connected(e.getFrom(), e.getTo())) {\n                set.union(e.getFrom(), e.getTo());\n                kruskal.push(e);\n            }\n        }\n\n        // Get the total cost of the MST\n        const weight = kruskal.reduce((acc, e) => {\n            return acc + e.getWeight();\n        }, 0);\n\n        return { mst: (kruskal as any) as EdgeImmutPlain[], totalWeight: weight };\n    };\n\n    public static topologicalSort = (G: GraphImmut = GraphState.graph): boolean | NodeImmut[] => {\n        const adjacency = G.getFullAdjacency();\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\n\n        const L: NodeImmut[] = [];\n        const S: NodeImmut[] = (G.getAllNodes(true) as NodeImmut[]).filter(n => {\n            return degrees[n.getID()].in === 0;\n        });\n        let edges = G.getAllEdges(true) as EdgeImmut[];\n\n        while (S.length !== 0) {\n            const nodeN = S.pop()!;\n            L.push(nodeN);\n\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\n\n            // Remove n to m edges for all nodes m\n            edges = edges.filter(edge => {\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\n                    degrees[edge.getTo()].in--;\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter(v => {\n                        return v !== edge.getTo();\n                    });\n                    return false;\n                }\n                return true;\n            });\n\n            // If m has no more incoming edges, add it to S\n            nodeNConnectedTo.forEach(mID => {\n                if (degrees[mID].in === 0) {\n                    S.push(G.getNode(mID, true) as NodeImmut);\n                }\n            });\n        }\n\n        return edges.length > 0 || L;\n    };\n\n    public static isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\n        return GraphAlgorithms.topologicalSort(G) === true;\n    };\n\n    public static directionalEulerian = (directionalDegrees: { in: number; out: number }[], scc: number[]): boolean => {\n        let eulerian = true;\n        let component = -1;\n        directionalDegrees.forEach((deg, id) => {\n            if (deg.in !== deg.out) {\n                eulerian = false;\n            }\n            if (deg.in > 0) {\n                if (component === -1) {\n                    component = scc[id];\n                }\n                if (component !== scc[id]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n\n    public static hasEulerianCircuit = (degrees: number[], cc: number[]): boolean => {\n        const oddDegree = degrees.filter(v => {\n            return v % 2 !== 0;\n        });\n\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\n        if (oddDegree.length !== 0) {\n            return false;\n        }\n\n        let eulerian = true;\n        let component = -1;\n        degrees.forEach((v, i) => {\n            if (v !== 0) {\n                if (component === -1) {\n                    component = cc[i];\n                }\n                if (component !== cc[i]) {\n                    eulerian = false;\n                }\n            }\n        });\n\n        return eulerian;\n    };\n}\n","\"use strict\";\n\nexport default class SpanningTree {\n    private readonly id: number[];\n\n    constructor(V: number) {\n        this.id = [];\n        for (let v = 0; v < V; v++) {\n            this.id.push(v);\n        }\n    }\n\n    union(v: number, w: number) {\n        const q = this.root(v);\n        const p = this.root(w);\n\n        if (p !== q) {\n            this.id[p] = q;\n        }\n    }\n\n    root(q: number) {\n        while (this.id[q] !== q) {\n            q = this.id[q];\n        }\n        return q;\n    }\n\n    connected(v: number, w: number) {\n        return this.root(v) === this.root(w);\n    }\n}\n"],"names":["myID","ctx","self","addEventListener","e","data","type","id","args","ms","waitTime","Promise","resolve","setTimeout","postMessage","convertToGraphImmut","push","graphPlainToGraphImmut","graph","apply","gp","nodes","edges","directed","weighted","colorNetwork","G","nodeArr","datasetToArray","getAllNodes","degrees","getAllOutDegrees","vertexOrder","sort","a","b","colorIndex","currentColor","length","root","shift","myGroup","i","p","conflict","j","areAdjacent","splice","colors","chromaticNumber","max","flatten","connectedComponents","components","componentCount","setComponentNum","v","getNumberOfNodes","GraphAlgorithms","depthFirstSearch","forEach","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","w","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","queue","_nodes","enqueue","priority","key","this","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","V","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","bottleneckValue","maxFlow","flowPath","f","getFlows","kruskal","set","connected","union","reduce","acc","mst","totalWeight","topologicalSort","adjacency","getFullAdjacency","findVertexDegreesDirectional","L","filter","n","in","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","scc","eulerian","component","deg","out","hasEulerianCircuit","cc","q"],"sourceRoot":""}