{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/genericHelpers.js","webpack:///./src/js/GraphImmut/NodeImmut.js","webpack:///./src/js/GraphImmut/EdgeImmut.js","webpack:///./src/js/GraphImmut/GraphImmut.js","webpack:///./src/js/graphHelpers.js","webpack:///./src/js/settings.js","webpack:///./src/js/graphState.js","webpack:///./src/js/main.js","webpack:///./src/js/predefinedGraphs.js","webpack:///./src/js/UIInteractions.js","webpack:///./src/js/app.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","4","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","head","document","getElementsByTagName","script","createElement","charset","timeout","nc","setAttribute","src","p","0","1","setTimeout","onScriptComplete","type","target","event","onerror","onload","clearTimeout","chunk","errorType","realSrc","error","Error","request","undefined","appendChild","all","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","bind","slice","self","deepFreeze","freeze","getOwnPropertyNames","forEach","prop","isFrozen","sort","arr","compareFunction","datasetToArray","ds","key","v","keepOnlyKeys","keys","indexOf","getFileExtension","filename","split","htmlEncode","string","jquery__WEBPACK_IMPORTED_MODULE_0___default","text","html","replace","printout","escape","flatten","map","rotate","max","iterable","reduce","a","b","Math","toTitleCase","str","match","toUpperCase","showSimpleModal","title","body","showFormModal","initialValue","makeFormModal","successText","form","footer","f","class","formRow","id","basicMap","extraAttrs","attrname","validFunc","validationFunc","generalValidator","valueMutator","$v","val","valid","removeClass","next","remove","addClass","after","append","checked","for","label","prepend","clickDismiss","$b","onclick","on","parseFloat","$options","optionText","oText","oIndex","optionValues","$footer","$modal","tabindex","role","aria-hidden","data-dismiss","aria-label","find","off","last","click","first","focus","successCb","cancelCb","modal","vals","hasErrors","each","tagName","attr","files","trigger","hasClass","__webpack_exports__","NodeImmut","[object Object]","this","toString","attributes","toReturn","attribute","getLabel","assign","getID","EdgeImmut","from","to","weight","newWeight","getFrom","getTo","GraphImmut_filterNodeExtraAttr","filter","includes","obj","GraphImmut_genericEdgesToImmutEdges","edges","nodeMap","newEdges","immutable","edge","GraphImmut_genericNodesToImmutNodes","nodes","newNodes","nodeNum","set","floor","GraphImmut_GraphImmut","directed","weighted","numNodes","size","numEdges","alignTo","nodeCount","getAllAttributes","getWeight","rich","toPlain","has","getNode","editNode","node","deleteAll","foundOneEdge","oldWeight","foundFirst","index","editEdge","toArray","degrees","doubleEdges","addedEdges","G","asDirected","asUndirected","asWeighted","asUnweighted","adj","getNodeAdjacency","id1","id2","edgeList","minWeight","Infinity","getEdgesBetween","reducer","multiEdges","uniques","Set","acc","keep","duplicateEdge","findVertexDegreesDirectional","adjacencyMatrix","out","in","outV","interpolateNodesFromEdges","settings_self","defaults","nodePhysics","direction","weights","current","checkForLocalStorage","x","localStorage","setItem","removeItem","saveSettings","JSON","stringify","loadSettings","parse","getItem","setAll","network","setOptions","physics","getOption","arrows","manipulation","editWithoutDrag","main","visWeightEdgeEdit","visOptions","changeOption","option","resetToDefault","graphState","graph","asChangedDirectedWeighted","setData","getGraphData","settings","graphState_self","backHistory","forwardHistory","maxHistory","upToDate","applyFunc","ui","makeAndPrintGraphColoring","always","makeAndPrintEulerian","makeAndPrintConnectedComponents","makeAndPrintStronglyConnectedComponents","makeAndPrintIsCyclic","state","stronglyConnectedComponents","connectedComponents","graphColoring","graphProperties","vertices","eulerian","Chromatic Number","Connected Components","Strongly Connected Components","cyclic","setUpToDate","listOptions","makeAndPrintProperties","getProperty","updateIfNotUpdated","recalcLong","directional","getNumberOfNodes","getNumberOfEdges","printableProperties","printGraphProperties","properties","k","genericHelpers","trim","jquery_default","addEdge","clearColorFromNodes","getAllNodes","getAllEdges","addNode","y","deleteEdge","deleteNode","color","nodeIDToLabel","nodeLabelToID","toLowerCase","rID","found","getGraphAsDataSet","isWeighted","index_network","setLocations","locations","getAllNodesAsImmutableList","getAttribute","GraphImmut","getAllEdgesAsImmutableList","isDirected","clearColors","main_self","container","getElementById","callback","interaction","hover","$popup","saveData","cancelEdit","confirm","_data","fromId","toId","operation","nodeLabelIDValidator","applyColors","graphColors","chromaticNumber","colors","randomColor_default","count","luminosity","recalcProps","graphChanged","rearrangeGraph","saveState","g","randomizeNetworkLayoutSeed","getPositions","disableEditMode","enableEditMode","printGraphAlgorithms","saveStateLocalStorage","getStateForSaving","parent","extend","Array","isArray","undo","applyState","redo","newState","firstLoad","currentState","pop","oldKey","shuffleNetworkLayout","round","random","layoutEngine","randomSeed","initialRandomSeed","addNetworkListeners","editEdgeMode","lastNetworkClickEvent","parents","deleteSelected","keydown","which","ctrlKey","shiftKey","predefinedGraphs_petersenEdges","predefinedGraphs_konigsbergEdges","predefinedGraphs","graphNames","Petersen","graphHelpers","Konigsberg","Complete","V","predefinedGraphs_completeGraph","Hypercube","D","pow","pad","generateDifferByOne","input","numBits","inputBits","reverse","allDiffer","newNum","parseInt","join","predefinedGraphs_hypercubeGraph","Custom","predefinedGraphs_newCustomGraph","UIInteractions_makeAndPrintShortestPath","fn","values","source","sink","pathExists","distance","cost","path","UIInteractions_makeAndPrintComponents","async","stronglyConnected","cc","componentKey","gAlgo","then","default","components","UIInteractions_UIInteractions","display","makeAndPrintBFS","makeAndPrintDijkstra","makeAndPrintBFSP","makeAndPrintFFMCMF","makeAndPrintKruskal","makeAndPrintTopologicalSort","makeAndPrintDirectionalEulerian","makeSimpleClickListener","selector","preventDefault","printHelp","printOptions","predefined","makeImportFileModal","makeImportTextModal","makeExportFileModal","makeExportTextModal","colorNetwork","t","directionalEulerian","getFullAdjacency","hasEulerianCircuit","getAllOutDegrees","breadthFirstSearch","dijkstraSearch","bellmanFord","fordFulkerson","maxFlow","flowPath","flow","capacity","kruskal","totalWeight","mst","isGraphCyclic","topologicalSort","$div","empty","addAlgoToPane","alg","href","getAlgorithms","singleton_default","config","install","Raven","app_loadDefault","registerListeners"],"mappings":"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","file":"bundle-32e3fb4e467d5d7ad21d.min.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t4: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\t\tvar script = document.createElement('script');\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \"-\" + {\"0\":\"cbcd766730cd0475ef58\",\"1\":\"3cbef50a309afb32a7e4\"}[chunkId] + \".min.js\";\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tfunction onScriptComplete(event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\tvar error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\thead.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([41,2]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\"use strict\";\r\n\r\nimport $ from 'jquery';\r\n\r\nlet self = {\r\n    deepFreeze: (o) => {\r\n        Object.freeze(o);\r\n\r\n        Object.getOwnPropertyNames(o).forEach(prop => {\r\n            if (o.hasOwnProperty(prop) && o[prop] !== null\r\n                && (typeof o[prop] === \"object\" || typeof o[prop] === \"function\")\r\n                && !Object.isFrozen(o[prop])) {\r\n                self.deepFreeze(o[prop]);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    },\r\n    sort: (arr, compareFunction) => {\r\n        return [...arr].sort(compareFunction);\r\n    },\r\n    datasetToArray: (ds, key) => {\r\n        let r = [];\r\n        ds.forEach((v) => {\r\n            r.push(v[key]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    keepOnlyKeys: (arr, keys) => {\r\n        arr = arr.slice();\r\n        arr.forEach((v) => {\r\n            let k = Object.keys(v);\r\n            k.forEach((key) => {\r\n                if (keys.indexOf(key) < 0) {\r\n                    delete v[key];\r\n                }\r\n            });\r\n        });\r\n        return self.deepFreeze(arr);\r\n    },\r\n\r\n    getFileExtension: (filename) => {\r\n        return filename.split(\".\").splice(-1)[0];\r\n    },\r\n\r\n    htmlEncode: (string) => {\r\n        string = $(\"<div>\").text(string).html();\r\n        string = string.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>');\r\n        return string;\r\n    },\r\n\r\n    printout: (text, escape) => {\r\n        if (escape) {\r\n            text = this.htmlEncode(escape);\r\n        }\r\n        $(\"#printout\").html(text);\r\n    },\r\n\r\n    flatten: (map) => {\r\n        let r = [];\r\n        for (let i in map) {\r\n            if ({}.hasOwnProperty.call(map, i)) {\r\n                r.push(map[i]);\r\n            }\r\n        }\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    rotate: (map) => {\r\n        let r = {};\r\n        for (let i in map) {\r\n            if (map[i] in r) {\r\n                r[map[i]].push(i);\r\n            }\r\n            else {\r\n                r[map[i]] = [i];\r\n            }\r\n        }\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    max: (iterable) => {\r\n        return iterable.reduce((a, b) => {\r\n            return Math.max(a, b);\r\n        });\r\n    },\r\n\r\n    toTitleCase: (str) => {\r\n        return str.replace(/(?:^|\\s)\\w/g, (match) => {\r\n            return match.toUpperCase();\r\n        });\r\n    },\r\n\r\n    showSimpleModal: (title, body) => {\r\n        self.showFormModal(null, title, null, [{type: \"html\", initialValue: body}], null, false);\r\n    },\r\n\r\n    makeFormModal: (title, successText, form, footer = true) => {\r\n        let f = $(\"<div>\", {class: \"modal-body form-group\"});\r\n        form.forEach((formRow, i) => {\r\n            if (!(\"initialValue\" in formRow)) {\r\n                formRow.initialValue = \"\";\r\n            }\r\n\r\n            let id = \"form-modal-\" + i;\r\n            if (\"id\" in formRow && formRow.id !== \"\" && formRow.id !== null && typeof formRow.id === \"string\") {\r\n                id = formRow.id;\r\n            }\r\n\r\n            let basicMap = {class: \"form-control\", id: id, value: formRow.initialValue};\r\n\r\n            if (\"extraAttrs\" in formRow) {\r\n                Object.keys(formRow.extraAttrs).forEach((attrname) => {\r\n                    if (typeof formRow.extraAttrs[attrname] !== \"function\") {\r\n                        basicMap[attrname] = formRow.extraAttrs[attrname];\r\n                    }\r\n                });\r\n            }\r\n\r\n            let validFunc = () => true;\r\n            if (\"validationFunc\" in formRow) {\r\n                validFunc = formRow.validationFunc;\r\n            }\r\n\r\n            let generalValidator = (event, valueMutator = null) => {\r\n                let $v = $(event.target);\r\n                let val = $v.val();\r\n                if (valueMutator !== null && typeof valueMutator === \"function\") {\r\n                    val = valueMutator(val);\r\n                }\r\n                let valid = validFunc(val, $v);\r\n\r\n                if (valid === true) {\r\n                    $v.removeClass(\"is-invalid\").next(\"#feedback-\" + i).remove();\r\n                }\r\n                else {\r\n                    $v.addClass(\"is-invalid\");\r\n                    if ($v.next(\"#feedback-\" + i).length === 0) {\r\n                        $v.after($(\"<div>\", {class: \"invalid-feedback\", id: \"feedback-\" + i}).text(valid));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (formRow.type === \"html\") {\r\n                f.append($(formRow.initialValue));\r\n            }\r\n            else if (formRow.type === \"checkbox\") {\r\n                basicMap.type = \"checkbox\";\r\n                basicMap.class = \"form-check-input\";\r\n                delete basicMap.value;\r\n                if (formRow.initialValue) {\r\n                    basicMap.checked = \"\";\r\n                }\r\n\r\n                f.append($(\"<div>\", {class: \"form-check\"})\r\n                    .append($(\"<label>\", {for: id, class: \"form-check-label\"})\r\n                        .text(formRow.label).prepend($(\"<input>\", basicMap))\r\n                    )\r\n                );\r\n            }\r\n            else{\r\n                f.append($(\"<label>\", {for: id, class: \"col-form-label\"}).text(formRow.label));\r\n\r\n                if (formRow.type === \"button\") {\r\n                    if (\"clickDismiss\" in formRow && formRow.clickDismiss === true) {\r\n                        basicMap.class += \" btn-dismiss\";\r\n                    }\r\n                    let $b = $(\"<button>\", basicMap).text(formRow.initialValue);\r\n                    if (\"onclick\" in formRow && typeof formRow.onclick === \"function\") {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"numeric\") {\r\n                    basicMap.type = \"number\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", (e) => {\r\n                        generalValidator(e, parseFloat);\r\n                    }));\r\n                }\r\n                else if (formRow.type === \"text\") {\r\n                    basicMap.type = \"text\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"file\") {\r\n                    basicMap.type = \"file\";\r\n                    basicMap.class = \"form-control-file form-control\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"textarea\") {\r\n                    let $b = $(\"<textarea>\", basicMap).on(\"blur validate\", generalValidator);\r\n                    if (\"onclick\" in formRow) {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"select\") {\r\n                    let $options = $(\"<select>\", basicMap);\r\n                    formRow.optionText.forEach((oText, oIndex) => {\r\n                        if (oIndex < formRow.optionValues.length) {\r\n                            $options.append($(\"<option>\", {value: formRow.optionValues[oIndex]}).text(oText));\r\n                        }\r\n                        else {\r\n                            $options.append($(\"<option>\").text(oText));\r\n                        }\r\n                    });\r\n                    f.append($options.on(\"blur validate\", generalValidator));\r\n                }\r\n            }\r\n        });\r\n\r\n        let $footer = $(\"<div>\", {class: \"modal-footer\"})\r\n            .append($(\"<button>\", {class: \"btn btn-success\", type: \"button\"}).text(successText))\r\n            .append($(\"<button>\", {class: \"btn btn-danger btn-cancel\", type: \"button\"}).text(\"Cancel\"));\r\n\r\n        if (footer === false) {\r\n            $footer = null;\r\n        }\r\n\r\n        let $modal = ($(\"<div>\", {class: \"modal fade\", tabindex: \"-1\", role: \"dialog\", \"aria-hidden\": \"true\"}));\r\n        $modal\r\n            .append($(\"<div>\", {class: \"modal-dialog\"})\r\n                .append($(\"<div>\", {class: \"modal-content\"})\r\n                    .append($(\"<div>\", {class: \"modal-header\"})\r\n                        .append($(\"<h5>\", {class: \"modal-title\"}).text(title))\r\n                        .append($(\"<button>\", {class: \"close\", \"data-dismiss\": \"modal\", \"aria-label\": \"close\"})\r\n                            .append($(\"<span>\", {\"aria-hidden\": \"true\"}).html(\"&times;\"))\r\n                        )\r\n                    )\r\n                    .append(f)\r\n                    .append($footer)\r\n                )\r\n            );\r\n        $modal.find(\"input, textarea\").off(\"keyup\").on(\"keyup\", (e) => {\r\n            if (e.key === \"Enter\") {\r\n                $(\".btn-success\").last().click();\r\n            }\r\n        });\r\n        $modal.on(\"shown.bs.modal\", () => {\r\n            $modal.find(\"input[type='text'], input[type='number'], textarea\").first().focus();\r\n        });\r\n\r\n        return $modal;\r\n    },\r\n\r\n    showFormModal: (successCb, title, successText, form, cancelCb = ($modal) => {\r\n        $modal.modal(\"hide\");\r\n    }, footer = true) => {\r\n        let $modal = self.makeFormModal(title, successText, form, footer);\r\n\r\n        $modal.on(\"click\", \".btn-cancel\", () => {\r\n            if (typeof cancelCb === \"function\") {\r\n                cancelCb($modal);\r\n            }\r\n            else {\r\n                $modal.modal(\"hide\");\r\n            }\r\n        }).on(\"click\", \".btn-dismiss\", () => {\r\n            $modal.modal(\"hide\");\r\n        }).on(\"click\", \".btn-success\", () => {\r\n            let vals = [];\r\n            let hasErrors = false;\r\n\r\n            $modal.find(\"input, textarea, select\").each((i, v) => {\r\n                let $v = $(v);\r\n\r\n                if ($v.tagName === \"SELECT\") {\r\n                    vals.push($v.find(\":selected\").val());\r\n                }\r\n                else if ($v.attr(\"type\") === \"checkbox\") {\r\n                    vals.push($v.prop(\"checked\"));\r\n                }\r\n                else if ($v.attr(\"type\") === \"file\") {\r\n                    vals.push($v.get(0).files);\r\n                }\r\n                else if ($v.attr(\"type\") === \"number\") {\r\n                    vals.push(parseFloat($v.val()));\r\n                }\r\n                else {\r\n                    vals.push($v.val());\r\n                }\r\n\r\n                if ($v.trigger(\"validate\").hasClass(\"is-invalid\")) {\r\n                    hasErrors = true;\r\n                }\r\n\r\n            });\r\n\r\n            if (!hasErrors && typeof successCb === \"function\") {\r\n                successCb($modal, vals);\r\n            }\r\n        }).on(\"hidden.bs.modal\", () => {\r\n            $modal.remove();\r\n        }).modal(\"show\");\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\n\nexport default class NodeImmut {\n    constructor (id, label = null, extraAttrs = null) {\n        this.id = id;\n\n        if (label === null) {\n            this.label = id.toString();\n        }\n        else {\n            this.label = label;\n        }\n\n        this.attributes = {};\n        if (extraAttrs !== null && typeof extraAttrs === \"object\") {\n            Object.keys(extraAttrs).forEach((key) => {\n                this.attributes[key] = Object.freeze(extraAttrs[key]);\n            });\n        }\n\n        this.attributes = Object.freeze(this.attributes);\n        this.label = Object.freeze(this.label);\n        this.id = Object.freeze(this.id);\n\n        if (new.target === NodeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    toPlain () {\n        let toReturn = {id: this.id, label: this.label};\n        Object.keys(this.attributes).forEach((key) => {\n            if (!(key in toReturn)) {\n                toReturn[key] = this.attributes[key];\n            }\n        });\n\n        return toReturn;\n    }\n\n    getID () {\n        return this.id;\n    }\n\n    getLabel () {\n        return this.label;\n    }\n\n    getAttribute (attribute) {\n        if (attribute in this.attributes) {\n            return this.attributes[attribute];\n        }\n\n        return null;\n    }\n\n    getAllAttributes () {\n        return this.attributes;\n    }\n\n    editNode (label = null, extraAttrs = null) {\n        if (label === null) {\n            label = this.getLabel();\n        }\n\n        // Merge existing and new attributes favoring the new\n        let attributes = Object.assign({}, this.attributes);\n        Object.keys(extraAttrs).forEach((key) => {\n            attributes[key] = extraAttrs[key];\n        });\n\n        return new NodeImmut(this.getID(), label, attributes);\n    }\n}\n","\"use strict\";\n\nexport default class EdgeImmut {\n    constructor (from, to, weight = 1) {\n        this.from = Object.freeze(from);\n        this.to = Object.freeze(to);\n        this.weight = Object.freeze(parseFloat(weight));\n\n        if (new.target === EdgeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    getFrom () {\n        return this.from;\n    }\n\n    getTo () {\n        return this.to;\n    }\n\n    getWeight () {\n        return this.weight;\n    }\n\n    toPlain () {\n        return {from: this.from, to: this.to, weight: this.weight};\n    }\n\n    editEdge (newWeight) {\n        return new EdgeImmut(this.getFrom(), this.getTo(), newWeight);\n    }\n}\n","\"use strict\";\n\nimport {List} from \"immutable\";\nimport NodeImmut from './NodeImmut';\nimport EdgeImmut from './EdgeImmut';\n\nconst filterNodeExtraAttr = (data) => {\n    return Object.keys(data)\n                 .filter((key) => !([\"label\", \"id\"]).includes(key))\n                 .reduce((obj, key) => {\n                     obj[key] = data[key];\n                     return obj;\n                 }, {});\n};\n\nconst genericEdgesToImmutEdges = (edges, nodeMap = {}) => {\n    if(edges === null){\n        return false;\n    }\n\n    let newEdges = new List();\n\n    if(typeof edges === 'object') {\n        edges.forEach((edge) => {\n            let weight = 0;\n            let from = 0;\n            let to = 0;\n\n            if (\"weight\" in edge) {\n                weight = parseFloat(edge.weight);\n            }\n            if (\"from\" in edge) {\n                from = nodeMap[edge.from];\n            }\n            if (\"to\" in edge) {\n                to = nodeMap[edge.to];\n            }\n\n            newEdges = newEdges.push(new EdgeImmut(from, to, weight));\n        });\n    }\n    else{\n        return false;\n    }\n\n    return newEdges;\n};\n\nconst genericNodesToImmutNodes = (nodes) => {\n    if(nodes === null){\n       return false;\n    }\n\n    let newNodes = new List();\n    let nodeMap = {};\n\n    if(typeof nodes === 'object'){\n        let nodeNum = 0;\n        nodes.forEach((n) => {\n            let id = nodeNum++;\n            let label = null;\n            let extraAttrs = null;\n\n            if (\"label\" in n) {\n                label = n.label;\n            }\n            if (\"id\" in n){\n                nodeMap[n.id] = id;\n                if (\"label\" in n && n.label === n.id.toString()) {\n                    label = id.toString();\n                }\n            }\n            else {\n                nodeMap[id] = id;\n            }\n            if (\"attributes\" in n) {\n                extraAttrs = filterNodeExtraAttr(n.attributes);\n            }\n            else {\n                extraAttrs = filterNodeExtraAttr(n);\n            }\n\n            newNodes = newNodes.set(id, new NodeImmut(id, label, extraAttrs));\n        });\n    }\n    else if (typeof nodes === \"number\") {\n        // Create the nodes\n        for (let i = 0; i < Math.floor(nodes); i++) {\n            newNodes = newNodes.set(i, new NodeImmut(i));\n            nodeMap[i] = i;\n        }\n    }\n    else{\n        return false;\n    }\n\n    return {nodes: Object.freeze(newNodes), map: nodeMap};\n};\n\nexport default class GraphImmut {\n    constructor (nodes, edges = null, directed = false, weighted = false) {\n        this.directed = Object.freeze(directed);\n        this.weighted = Object.freeze(weighted);\n        let nodeMap = {};\n\n        // Make Nodes\n        if (typeof nodes === \"number\" || (typeof nodes === \"object\" && !(nodes instanceof List))) {\n            let n = genericNodesToImmutNodes(nodes);\n            this.nodes = n.nodes;\n            nodeMap = n.map;\n        }\n        else if(nodes instanceof List){\n            this.nodes = nodes;\n        }\n        else{\n            throw new Error(\"Illegal type of 'node' input to GraphImmut constructor\");\n        }\n        this.nodes = Object.freeze(this.nodes);\n        this.numNodes = Object.freeze(this.nodes.size);\n\n        // If we are given edges, add them to the graph\n        if (edges !== null && typeof edges === \"object\" && !(edges instanceof List)) {\n            this.edges = genericEdgesToImmutEdges(edges, nodeMap);\n        }\n        else if(edges instanceof List){\n            this.edges = edges;\n        }\n        else{\n            this.edges = new List();\n        }\n        this.edges = Object.freeze(this.edges);\n        this.numEdges = Object.freeze(this.edges.size);\n\n        if (new.target === GraphImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    alignNodeIDs (alignTo = 0){\n        let nodeMap = {};\n        let nodeCount = alignTo;\n        let newNodes = new List();\n        this.nodes.forEach((v) => {\n            let label = v.getLabel();\n            if (v.getLabel() === v.getID().toString()) {\n                label = nodeCount.toString();\n            }\n\n            newNodes = newNodes.set(nodeCount, new NodeImmut(nodeCount, label, v.getAllAttributes()));\n            nodeMap[v.getID()] = nodeCount++;\n        });\n\n        let newEdges = new List();\n        this.edges.forEach((v) => {\n            newEdges = newEdges.push(new EdgeImmut(nodeMap[v.getFrom()], nodeMap[v.getTo()], v.getWeight()));\n        });\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    getNode (id, rich = false) {\n        if (rich) {\n            return this.nodes.get(id);\n        }\n        return this.nodes.get(id).toPlain();\n    }\n\n    addNode (data = null) {\n        if (data === null) {\n            data = {};\n        }\n\n        let id = this.numNodes;\n        if (!(\"label\" in data)) {\n            data.label = id.toString();\n        }\n\n        let extraAttrs = filterNodeExtraAttr(data);\n\n        return new GraphImmut(this.nodes.set(id, new NodeImmut(id, data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    editNode (id, data) {\n        if (!this.nodes.has(id)) {\n            return false;\n        }\n\n        let extraAttrs = filterNodeExtraAttr(data);\n        if (!(\"label\" in data)) {\n            data.label = this.getNode(id, true).getLabel();\n        }\n        return new GraphImmut(this.nodes.set(id, this.getNode(id, true).editNode(data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    deleteNode (id) {\n        // Make sure the ID exists\n        if (!(id >= 0 && id < this.numNodes)) {\n            return false;\n        }\n\n        let nodeMap = {}; // Map for old IDs to new ones since we're deleting an entry\n\n        // Remove it from the node list\n        let nodeCount = 0;\n        let newNodes = this.nodes\n                           .filter((n) => {\n                               if (n.getID() === id) {\n                                   nodeMap[n.getID()] = -1;\n                               }\n                               else {\n                                   nodeMap[n.getID()] = nodeCount++;\n                               }\n\n                               return n.getID() !== id;\n                           })\n                           .map((node) => {\n                               let label = node.getLabel();\n                               if (node.getID().toString() === label) {\n                                   label = nodeMap[node.getID()].toString();\n                               }\n\n                               return new NodeImmut(nodeMap[node.getID()], label, node.getAllAttributes());\n                           });\n\n        // Remap edges\n        let newEdges = this.edges\n                           .filter((edge) => {\n                               return !(edge.getFrom() === id || edge.getTo() === id);\n                           })\n                           .map((edge) => {\n                               return new EdgeImmut(nodeMap[edge.getFrom()], nodeMap[edge.getTo()], edge.getWeight());\n                           });\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    addEdge (from, to, weight = 1) {\n        if (!this.weighted) {\n            weight = 1; // Ensure that edge weights are 1 if this is an unweighted graph\n        }\n\n        let newEdges = this.edges.push(new EdgeImmut(from, to, parseFloat(weight)));\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    deleteEdge (from, to, weight = null, deleteAll = true) {\n        if (weight !== null) {\n            weight = parseFloat(weight);\n        }\n\n        let foundOneEdge = false;\n        let newEdges = this.edges.filter((edge) => {\n            // If we're not deleting everything and we have found one edge, then do not filter anymore\n            if (foundOneEdge && !deleteAll) {\n                return true;\n            }\n\n            // If we have an exact match\n            if (edge.getFrom() === from && edge.getTo() === to && (weight === null || edge.getWeight() === weight)) {\n                foundOneEdge = true;\n                return false; // Remove this edge\n            }\n\n            // If we are undirected, check for opposing matches\n            if (!this.directed) {\n                if (edge.getFrom() === to && edge.getTo() === from && (weight === null || edge.getWeight() === weight)) {\n                    foundOneEdge = true;\n                    return false; // Remove this edge\n                }\n            }\n\n            return true;\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    editEdge (from, to, newWeight, oldWeight = null) {\n        // Editing only makes sense for weighted graphs.\n        // To change from/to, just delete the edge and add a new one\n        if (!this.weighted) {\n            return false;\n        }\n\n        let foundFirst = false;\n\n        if (oldWeight !== null) {\n            oldWeight = parseFloat(oldWeight);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge, index) => {\n            if (foundFirst) {\n                return;\n            }\n            if (edge.getFrom() === from && edge.getTo() === to && (oldWeight === null || edge.getWeight() === oldWeight)) {\n                newEdges = newEdges.set(index, edge.editEdge(parseFloat(newWeight)));\n                foundFirst = true;\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    getAllNodes (rich = false) {\n        if (rich) {\n            return this.nodes.toArray();\n        }\n        return this.nodes.map((node) => {\n            return node.toPlain();\n        }).toArray();\n    }\n\n    getAllNodesAsImmutableList () {\n        return this.nodes;\n    }\n\n    getAllEdgesAsImmutableList () {\n        return this.edges;\n    }\n\n    getAllEdges (rich = false) {\n        if (rich) {\n            return this.edges.toArray();\n        }\n        return this.edges.map((edge) => {\n            return edge.toPlain();\n        }).toArray();\n    }\n\n    getNumberOfNodes () {\n        return this.numNodes;\n    }\n\n    getNumberOfEdges () {\n        return this.numEdges;\n    }\n\n    getAllOutDegrees () {\n        let degrees = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() in degrees) {\n                degrees[edge.getFrom()]++;\n            }\n            else {\n                degrees[edge.getFrom()] = 1;\n            }\n        });\n\n        return degrees;\n    }\n\n    asWeighted () {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }), this.directed, true);\n    }\n\n    asUnweighted () {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }), this.directed, false);\n    }\n\n    asDirected (doubleEdges = false) {\n        if (!doubleEdges) {\n            return new GraphImmut(this.nodes, this.edges, true, this.weighted);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.getTo(), edge.getFrom(), edge.getWeight()));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, true, this.weighted);\n    }\n\n    asUndirected () {\n        let newEdges = List();\n        let addedEdges = {};\n\n        this.edges.forEach((edge) => {\n            let from = edge.getFrom();\n            let to = edge.getTo();\n            if (to > from) {\n                from = to;\n                to = edge.getFrom();\n            }\n            if (!(from + \"_\" + to in addedEdges)) {\n                addedEdges[from + \"_\" + to] = null;\n                newEdges = newEdges.push(new EdgeImmut(from, to, edge.getWeight()));\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, false, this.weighted);\n    }\n\n    asChangedDirectedWeighted (directed, weighted) {\n        let G = this;\n        if(directed && !this.directed){\n            G = this.asDirected();\n        }\n        else if (!directed && this.directed){\n            G = this.asUndirected();\n        }\n\n        if(weighted && !this.weighted){\n            G = this.asWeighted();\n        }\n        else if(!weighted && this.weighted){\n            G = this.asUnweighted();\n        }\n\n        return G;\n    }\n\n    getNodeAdjacency (id) {\n        let adj = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() === id) {\n                adj.push(edge.getTo());\n            }\n            else if (!this.directed && edge.getTo() === id) {\n                adj.push(edge.getFrom());\n            }\n        });\n\n        return adj;\n    }\n\n    getFullAdjacency () {\n        let adj = [];\n        this.nodes.forEach((n) => {\n            adj[n.getID()] = this.getNodeAdjacency(n.getID());\n        });\n\n        return adj;\n    }\n\n    areAdjacent (id1, id2) {\n        return this.getNodeAdjacency(id1).includes(id2);\n    }\n\n    getEdgesBetween (id1, id2) {\n        let edgeList = [];\n        this.edges.forEach((edge) => {\n            if (!this.directed && edge.getFrom() === id2 && edge.getTo() === id1) {\n                edgeList.push(edge);\n            }\n\n            if (edge.getFrom() === id1 && edge.getTo() === id2) {\n                edgeList.push(edge);\n            }\n        });\n\n        return edgeList;\n    }\n\n    getMinWeightEdgeBetween (id1, id2) {\n        let minWeight = Infinity;\n        this.getEdgesBetween(id1, id2).forEach((edge) => {\n            if (edge.getWeight() < minWeight) {\n                minWeight = edge.getWeight();\n            }\n        });\n\n        return minWeight;\n    }\n\n    // Take a multigraph and reduce all multiple edges to a single edge, weighted using the reducer\n    reduceMultiGraph (reducer, initialValue) {\n        if (typeof initialValue === \"undefined\") {\n            initialValue = 0;\n        }\n\n        let multiEdges = [];\n        this.nodes.forEach((node) => {\n            // If we have duplicates\n            let adj = this.getNodeAdjacency(node.getID());\n            let uniques = new Set(adj);\n            if (uniques.size < adj.length) {\n                uniques.forEach((to) => {\n                    let newWeight = this.getEdgesBetween(node.getID(), to).reduce((acc, edge) => {\n                        return reducer(acc, edge.getWeight());\n                    }, initialValue);\n\n                    multiEdges.push({from: node.getID(), to: to, weight: parseFloat(newWeight)});\n                });\n            }\n        });\n\n        // Remove all multigraph edges and replace them with single new edges\n        let newEdges = this.edges.filter((edge) => {\n            let keep = true;\n            multiEdges.forEach((duplicateEdge) => {\n                if (edge.getFrom() === duplicateEdge.from && edge.getTo() === duplicateEdge.to) {\n                    keep = false;\n                }\n            });\n\n            return keep;\n        });\n        multiEdges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.from, edge.to, edge.weight));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    isWeighted () {\n        return this.weighted;\n    }\n\n    isDirected () {\n        return this.directed;\n    }\n}\n","\"use strict\";\r\n\r\nexport default {\r\n    findVertexDegreesDirectional: (adjacencyMatrix) => {\r\n        // Adjacency stores IDs of edges TO\r\n        let degrees = [];\r\n        adjacencyMatrix.forEach((v, i) => {\r\n            if (i in degrees) {\r\n                degrees[i].out += v.length;\r\n            }\r\n            else {\r\n                degrees[i] = {out: v.length, in: 0};\r\n            }\r\n            v.forEach((outV) => {\r\n                if (outV in degrees) {\r\n                    degrees[outV].in += 1;\r\n                }\r\n                else {\r\n                    degrees[outV] = {in: 1, out: 0};\r\n                }\r\n            });\r\n        });\r\n\r\n        return degrees;\r\n    },\r\n\r\n    interpolateNodesFromEdges: (edges) => {\r\n        let nodes = [];\r\n        edges.forEach((v) => {\r\n            nodes[v.from] = {id: v.from, label: \"\" + v.from};\r\n            nodes[v.to] = {id: v.to, label: \"\" + v.to};\r\n        });\r\n\r\n        return nodes;\r\n    },\r\n};\r\n","\"use strict\";\r\n\r\nlet self = {\r\n    defaults: {\r\n        nodePhysics: true,\r\n        direction: false,\r\n        weights: false\r\n    },\r\n    current: {},\r\n\r\n    checkForLocalStorage: () => {\r\n        try {\r\n            let x = '__storage_test__';\r\n            localStorage.setItem(x, x);\r\n            localStorage.removeItem(x);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    saveSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.settings\", JSON.stringify(self.current));\r\n        }\r\n    },\r\n\r\n    loadSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            self.current = JSON.parse(localStorage.getItem(\"graphPlayground.settings\"));\r\n        }\r\n        if (self.current === null) {\r\n            self.current = {};\r\n        }\r\n        self.setAll();\r\n    },\r\n\r\n    setAll: () => {\r\n        window.network.setOptions({nodes: {physics: self.getOption(\"nodePhysics\")}});\r\n        window.network.setOptions({edges: {arrows: {to: self.getOption(\"direction\")}}});\r\n        if (self.getOption(\"weights\")) {\r\n            window.network.setOptions({\r\n                manipulation: {\r\n                    editEdge: {\r\n                        editWithoutDrag: window.main.visWeightEdgeEdit\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            window.network.setOptions({manipulation: {editEdge: window.main.visOptions.manipulation.editEdge}});\r\n        }\r\n    },\r\n\r\n    changeOption: (option, value) => {\r\n        self.current[option] = value;\r\n        self.saveSettings();\r\n        self.setAll();\r\n    },\r\n\r\n    getOption: (option) => {\r\n        if (option in self.current) {\r\n            return self.current[option];\r\n        }\r\n        return self.defaults[option];\r\n    },\r\n\r\n    resetToDefault: () => {\r\n        self.current = {};\r\n        self.saveSettings();\r\n        self.setAll();\r\n\r\n        // Reset graph to just a plain graph. Not sure if this should actually happen or not.\r\n        let G = window.main.graphState.graph.asChangedDirectedWeighted(self.defaults.direction, self.defaults.weights);\r\n        window.main.setData(window.main.graphState.getGraphData(G));\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport $ from 'jquery';\r\nimport {DataSet} from 'vis/index-network';\r\nimport help from './genericHelpers';\r\nimport GraphImmut from './GraphImmut/GraphImmut';\r\n\r\nlet self = {\r\n    backHistory: [],\r\n    forwardHistory: [],\r\n    maxHistory: 10,\r\n    upToDate: [\r\n        {\r\n            name: \"Chromatic Number\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {\r\n            name: \"graphColoring\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {name: \"vertices\", upToDate: true, always: true, type: \"property\"},\r\n        {name: \"edges\", upToDate: true, always: true, type: \"property\"},\r\n        {\r\n            name: \"eulerian\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintEulerian();\r\n            }\r\n        },\r\n        {\r\n            name: \"Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"connectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"Strongly Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"stronglyConnectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"cyclic\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintIsCyclic();\r\n            }\r\n        },\r\n    ],\r\n    state: {\r\n        stronglyConnectedComponents: null,\r\n        connectedComponents: null,\r\n        graphColoring: null,\r\n    },\r\n    graph: null,\r\n    graphProperties: {\r\n        vertices: 0,\r\n        edges: 0,\r\n        eulerian: false,\r\n        \"Chromatic Number\": null,\r\n        \"Connected Components\": null,\r\n        \"Strongly Connected Components\": null,\r\n        cyclic: false,\r\n    },\r\n\r\n    setUpToDate: (value = false, listOptions) => {\r\n        let all = listOptions === null || typeof listOptions === \"undefined\";\r\n        let property = false;\r\n        self.upToDate.forEach((v) => {\r\n            if ((!(\"always\" in v) || !v.always) && (all || listOptions.indexOf(v.name) > -1)) {\r\n                v.upToDate = value;\r\n                if (v.type === \"property\") {\r\n                    property = true;\r\n                }\r\n            }\r\n        });\r\n        if (property) {\r\n            self.makeAndPrintProperties();\r\n        }\r\n    },\r\n\r\n    getProperty: (property, updateIfNotUpdated = false) => {\r\n        let a = self.upToDate.find((v) => {\r\n            return (\"name\" in v && v.name === property);\r\n        });\r\n        if (!a.upToDate) {\r\n            if (\"applyFunc\" in a && updateIfNotUpdated) {\r\n                a.applyFunc();\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        if (a.type === \"state\") {\r\n            return self.state[property];\r\n        }\r\n        return self.graphProperties[property];\r\n    },\r\n\r\n    makeAndPrintProperties: (recalcLong = false) => {\r\n        let directional = window.settings.getOption(\"direction\");\r\n\r\n        self.graphProperties.vertices = self.graph.getNumberOfNodes();\r\n        self.graphProperties.edges = self.graph.getNumberOfEdges();\r\n\r\n        if (!directional) {\r\n            self.getProperty(\"eulerian\", true);\r\n        }\r\n\r\n        let p = Object.keys(self.graphProperties);\r\n        if (recalcLong) {\r\n            p.forEach((v) => {\r\n                self.getProperty(v, true);\r\n            });\r\n        }\r\n\r\n        let printableProperties = {};\r\n        p.forEach((v) => {\r\n            printableProperties[v] = self.getProperty(v);\r\n        });\r\n        self.printGraphProperties(printableProperties);\r\n    },\r\n\r\n    printGraphProperties: (properties) => {\r\n        let p = \"\";\r\n        Object.keys(properties).forEach((k) => {\r\n            if (properties[k] !== null) {\r\n                p += help.toTitleCase(k) + \": \" + properties[k] + \"\\n\";\r\n            }\r\n        });\r\n        p = p.trim();\r\n        p = help.htmlEncode(p);\r\n        $(\"#graphProps\").html(\"<p class='nav-link'>\" + p + \"</p>\");\r\n    },\r\n\r\n    addEdge: (from, to, weight = 0, graph = self.graph) => {\r\n        graph = graph.addEdge(from, to, weight);\r\n        window.main.setData({nodes: self.clearColorFromNodes(graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    addNode: (data, graph = self.graph) => {\r\n        graph = graph.addNode({label: data.label, x: data.x, y: data.y});\r\n        window.main.setData({nodes: self.clearColorFromNodes(graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    editNode: (id, label, graph = self.graph) => {\r\n        graph = graph.editNode(id, {label: label});\r\n        window.main.setData(self.getGraphData(graph), false, false);\r\n    },\r\n\r\n    editEdge: (from, to, newWeight, oldWeight, graph = self.graph) => {\r\n        graph = graph.editEdge(from, to, newWeight, oldWeight);\r\n        window.main.setData(self.getGraphData(graph), false, false);\r\n    },\r\n\r\n    deleteEdge: (from, to, weight = null, graph = self.graph) => {\r\n        graph = graph.deleteEdge(from, to, weight, false);\r\n        window.main.setData({nodes: self.clearColorFromNodes(graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    deleteNode: (id, graph = self.graph) => {\r\n        graph = graph.deleteNode(id);\r\n        window.main.setData({nodes: self.clearColorFromNodes(graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    clearColorFromNodes: (nodes) => {\r\n        nodes.forEach((v) => {\r\n            v.color = null;\r\n        });\r\n        return nodes;\r\n    },\r\n\r\n    nodeIDToLabel: (id, graph = self.graph) => {\r\n        let n = graph.getNode(id, true);\r\n        if (n !== false && n !== null && typeof n !== \"undefined\" && n.getLabel().trim().length > 0) {\r\n            return n.getLabel().trim();\r\n        }\r\n\r\n        return id.toString();\r\n    },\r\n\r\n    // Preferentially search by ID, label, and case-insensitive label\r\n    nodeLabelToID: (label, graph = self.graph) => {\r\n        let n = graph.getAllNodes(true);\r\n        n = n.filter((node) => {\r\n            return node.getLabel().toLowerCase() === label.toLowerCase() || node.getID().toString() === label;\r\n        });\r\n\r\n        if (n.length === 0) {\r\n            return -1;\r\n        }\r\n        else if (n.length === 1) {\r\n            return n[0].getID();\r\n        }\r\n\r\n        let rID = -1;\r\n        let found = false;\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getID().toString() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel().toLowerCase() === label.toLowerCase()) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        return rID;\r\n    },\r\n\r\n    // Return graph as a Vis compatible dataset\r\n    getGraphAsDataSet: (graph) => {\r\n        let d = self.getGraphData(graph);\r\n        if (graph.isWeighted()) {\r\n            d.edges.forEach((e) => {\r\n                e.label = e.weight.toString();\r\n            });\r\n        }\r\n\r\n        return {nodes: new DataSet(d.nodes), edges: new DataSet(d.edges)};\r\n    },\r\n\r\n    setLocations: (locations, graph = self.graph) => {\r\n        let newNodes = graph.getAllNodesAsImmutableList();\r\n        Object.keys(locations).forEach((i) => {\r\n            let v = locations[i];\r\n            let node = newNodes.get(i);\r\n            // Only change when there is actually a new position\r\n            if (node.getAttribute(\"x\") !== v.x || node.getAttribute(\"y\") !== v.y) {\r\n                // Batch up all changes that we'll be making\r\n                newNodes = newNodes.set(i, node.editNode(node.getLabel(), {x: v.x, y: v.y}));\r\n            }\r\n        });\r\n\r\n        return new GraphImmut(newNodes, graph.getAllEdgesAsImmutableList(), graph.isDirected(), graph.isWeighted());\r\n    },\r\n\r\n    getGraphData: (graph = self.graph, clearColors = false) => {\r\n        return {\r\n            nodes: clearColors ? self.clearColorFromNodes(graph.getAllNodes()) : graph.getAllNodes(),\r\n            edges: graph.getAllEdges(),\r\n            directed: graph.isDirected(),\r\n            weighted: graph.isWeighted()\r\n        };\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport $ from 'jquery';\r\nimport help from './genericHelpers';\r\nimport settings from './settings';\r\nimport randomColor from 'randomcolor';\r\nimport graphState from './graphState';\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\n\r\nlet self = {\r\n    graphState: graphState,\r\n    container: document.getElementById('network'),\r\n    // Function used to overwrite the edge edit functionality when weights are active\r\n    visWeightEdgeEdit: (data, callback) => {\r\n        help.showFormModal(($modal, vals) => {\r\n            callback(null);\r\n            $modal.modal(\"hide\");\r\n            vals = parseFloat(vals[0]);\r\n            self.graphState.editEdge(data.from.id, data.to.id, vals, parseFloat(data.label));\r\n        }, \"Edit Edge\", \"Save\", [\r\n            {\r\n                type: \"numeric\",\r\n                label: \"Weight/Capacity\",\r\n                initialValue: parseFloat(data.label)\r\n            }\r\n        ]);\r\n    },\r\n    visOptions: {\r\n        interaction: {hover: true},\r\n        manipulation: {\r\n            addNode: function (data, callback) {\r\n                let $popup = help.makeFormModal(\"Add Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: \"<p>Node ID: \" + self.graphState.getProperty(\"vertices\") + \"</p>\"\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: self.graphState.getProperty(\"vertices\")}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"add\", $popup.find(\"input\").first().val());\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            editNode: function (data, callback) {\r\n                let $popup = help.makeFormModal(\"Edit Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: \"<p>Node ID: \" + data.id + \"</p>\"\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: data.label}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"editNode\", $popup.find(\"input\").first().val());\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            addEdge: function (data, callback) {\r\n                let apply = function () {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(null);\r\n                    }\r\n                    self.graphState.addEdge(data.from, data.to);\r\n                };\r\n                if (data.from === data.to) {\r\n                    if (confirm(\"Do you want to connect the node to itself?\")) {\r\n                        apply();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                apply();\r\n            },\r\n            editEdge: function (data, callback) {\r\n                callback(null);\r\n                self.visOptions.manipulation.deleteEdge({edges: [data.id]});\r\n                self.visOptions.manipulation.addEdge(data);\r\n            },\r\n            deleteEdge: function (data, callback) {\r\n                if (typeof callback === \"function\") {\r\n                    callback(null);\r\n                }\r\n                data.edges.forEach((v) => {\r\n                    let weight = null;\r\n                    if (typeof window.network.body.data.edges._data[v].label !== \"undefined\") {\r\n                        weight = parseFloat(window.network.body.data.edges._data[v].label);\r\n                    }\r\n\r\n                    self.graphState.deleteEdge(window.network.body.edges[v].fromId,\r\n                        window.network.body.edges[v].toId, weight);\r\n                });\r\n            },\r\n            deleteNode: function (data, callback) {\r\n                callback(null);\r\n                data.nodes.forEach((v) => {\r\n                    self.graphState.deleteNode(v);\r\n                });\r\n            },\r\n        },\r\n    },\r\n\r\n    cancelEdit: (callback) => {\r\n        if (typeof callback === \"function\") {\r\n            callback(null);\r\n        }\r\n    },\r\n\r\n    saveData: (data, callback, operation, label) => {\r\n        data.label = label;\r\n        callback(null);\r\n\r\n        if (operation === \"add\") {\r\n            self.graphState.addNode(data);\r\n        }\r\n        else if (operation === \"editNode\") {\r\n            self.graphState.editNode(data.id, data.label);\r\n        }\r\n    },\r\n\r\n    nodeLabelIDValidator: (v) => {\r\n        if (self.graphState.nodeLabelToID(v) > -1) {\r\n            return true;\r\n        }\r\n        return \"Invalid Label or ID\";\r\n    },\r\n\r\n    applyColors: () => {\r\n        if (settings.getOption(\"direction\")) {\r\n            return;\r\n        }\r\n        let graphColors = self.graphState.getProperty(\"graphColoring\", true);\r\n        let chromaticNumber = self.graphState.getProperty(\"Chromatic Number\", true);\r\n\r\n        let colors = randomColor({count: chromaticNumber, luminosity: \"light\"});\r\n        let G = self.graphState.graph;\r\n        G.getAllNodes().forEach((v) => {\r\n            G = G.editNode(v.id, {color: colors[graphColors[v.id]]});\r\n        });\r\n        self.setData(self.graphState.getGraphData(G), false, false);\r\n    },\r\n\r\n    setData: (data, recalcProps = false, graphChanged = true, rearrangeGraph = false) => {\r\n        // Store existing positions in the data if we're supposed to keep the layout\r\n        if (rearrangeGraph) {\r\n            data.nodes.forEach((v) => {\r\n                delete v.x;\r\n                delete v.y;\r\n            });\r\n        }\r\n\r\n        if (graphChanged) {\r\n            self.saveState();\r\n        }\r\n\r\n        if (\"directed\" in data) {\r\n            settings.changeOption(\"direction\", data.directed);\r\n        }\r\n        if (\"weighted\" in data) {\r\n            settings.changeOption(\"weights\", data.weighted);\r\n        }\r\n        let directional = settings.getOption(\"direction\");\r\n        let weighted = settings.getOption(\"weights\");\r\n\r\n        let g = new GraphImmut(data.nodes, data.edges, directional, weighted);\r\n        self.graphState.graph = g;\r\n\r\n        // Set a new random seed so that the layout will be different\r\n        self.randomizeNetworkLayoutSeed(window.network);\r\n        window.network.setData(self.graphState.getGraphAsDataSet(g));\r\n        self.graphState.graph = self.graphState.setLocations(window.network.getPositions());\r\n\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        if (graphChanged) {\r\n            window.ui.printGraphAlgorithms();\r\n            help.printout(\"\");\r\n            self.graphState.setUpToDate();\r\n            self.graphState.makeAndPrintProperties(recalcProps);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveState: () => {\r\n        if (self.graphState.graph === null) {\r\n            return;\r\n        }\r\n\r\n        if (self.graphState.backHistory.length >= self.graphState.maxHistory) {\r\n            self.graphState.backHistory.shift();\r\n        }\r\n\r\n        self.graphState.backHistory.push(self.getStateForSaving());\r\n        self.graphState.forwardHistory = [];\r\n        $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n    },\r\n\r\n    getStateForSaving: () => {\r\n        let state = {};\r\n        Object.keys(self.graphState).forEach((k) => {\r\n            let v = self.graphState[k];\r\n            if (typeof v !== \"function\") {\r\n                if (typeof v !== \"object\") {\r\n                    state[k] = v;\r\n                }\r\n                else {\r\n                    if (k === \"graph\" && v !== null) {\r\n                        state[k] = v;\r\n                    }\r\n                    if (!k.toLowerCase().includes(\"history\")) {\r\n                        state[k] = $.extend(true, Array.isArray(v) ? [] : {}, v);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return state;\r\n    },\r\n\r\n    undo: () => {\r\n        if (self.graphState.backHistory.length > 0) {\r\n            self.applyState(true);\r\n        }\r\n    },\r\n\r\n    redo: () => {\r\n        if (self.graphState.forwardHistory.length > 0) {\r\n            self.applyState(false);\r\n        }\r\n    },\r\n\r\n    applyState: (undo = true, newState = null) => {\r\n        let firstLoad = newState !== null;\r\n        let currentState = self.getStateForSaving();\r\n\r\n        if (!firstLoad) {\r\n            if (undo) {\r\n                newState = self.graphState.backHistory.pop();\r\n            }\r\n            else {\r\n                newState = self.graphState.forwardHistory.pop();\r\n            }\r\n        }\r\n\r\n        newState.graph = new GraphImmut(newState.graph.nodes, newState.graph.edges, newState.graph.directed, newState.graph.weighted);\r\n\r\n        settings.changeOption(\"direction\", newState.graph.isDirected());\r\n        settings.changeOption(\"weights\", newState.graph.isWeighted());\r\n\r\n        self.graphState.graph = newState.graph;\r\n\r\n        window.network.setData(self.graphState.getGraphAsDataSet(self.graphState.graph));\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        window.ui.printGraphAlgorithms();\r\n        help.printout(\"\");\r\n\r\n        Object.keys(newState).forEach((k) => {\r\n            let v = newState[k];\r\n            if (typeof v !== \"object\") {\r\n                self.graphState[k] = v;\r\n            }\r\n            else if (!k.toLowerCase().includes(\"history\") && k.toLowerCase() !== \"graph\") {\r\n                if (k.toLowerCase() === \"uptodate\") {\r\n                    Object.keys(self.graphState[k]).forEach((oldKey) => {\r\n                        self.graphState[k][oldKey].upToDate = v[oldKey].upToDate;\r\n                    });\r\n                }\r\n                else {\r\n                    self.graphState[k] = $.extend(true, self.graphState[k], v);\r\n                }\r\n            }\r\n        });\r\n\r\n        self.graphState.makeAndPrintProperties();\r\n        if (undo && !firstLoad) {\r\n            $(\".icon-redo\").parent().parent().addClass(\"active\");\r\n            if (self.graphState.backHistory.length === 0) {\r\n                $(\".icon-undo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            self.graphState.forwardHistory.push(currentState);\r\n        }\r\n        else if (!undo && !firstLoad) {\r\n            $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n            if (self.graphState.forwardHistory.length === 0) {\r\n                $(\".icon-redo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            self.graphState.backHistory.push(currentState);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveStateLocalStorage: () => {\r\n        if (settings.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.lastState\", JSON.stringify(self.getStateForSaving()));\r\n        }\r\n    },\r\n\r\n    shuffleNetworkLayout: () => {\r\n        self.setData({\r\n            nodes: self.graphState.graph.getAllNodes(),\r\n            edges: self.graphState.graph.getAllEdges()\r\n        }, false, false, true);\r\n    },\r\n\r\n    randomizeNetworkLayoutSeed: (network) => {\r\n        let r = Math.round(Math.random() * 1000000);\r\n        network.layoutEngine.randomSeed = r;\r\n        network.layoutEngine.initialRandomSeed = r;\r\n    },\r\n\r\n    addNetworkListeners: (network) => {\r\n        // Enable edit node/edge when double clicking\r\n        network.on(\"doubleClick\", (p) => {\r\n            if (settings.getOption(\"weights\") && \"edges\" in p && p.edges.length === 1) {\r\n                network.editEdgeMode();\r\n            }\r\n            if (\"nodes\" in p && p.nodes.length === 1) {\r\n                network.editNode();\r\n            }\r\n        });\r\n\r\n        // Save locations of nodes after dragging\r\n        network.on(\"dragEnd\", () => {\r\n            self.graphState.graph = self.graphState.setLocations(network.getPositions());\r\n            self.saveStateLocalStorage(); // Save the new locations as part of the state\r\n        });\r\n\r\n        // Delete nodes/edges when hit \"Delete\"\r\n        let lastNetworkClickEvent = null;\r\n        network.on('click', (event) => {\r\n            lastNetworkClickEvent = event;\r\n        });\r\n\r\n        // Delete key to delete node or edge\r\n        $(document).on('keyup', (key) => {\r\n            if (key.key === \"Delete\" && lastNetworkClickEvent !== null) {\r\n                if ($(self.container).has($(lastNetworkClickEvent.event.target)).length > 0) {\r\n                    if ((\"edges\" in lastNetworkClickEvent && lastNetworkClickEvent.edges.length === 1)\r\n                        || (\"nodes\" in lastNetworkClickEvent && lastNetworkClickEvent.nodes.length === 1)) {\r\n                        if ($(':focus').parents(\".modal\").length === 0) {\r\n                            network.deleteSelected();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Undo/Redo keyboard commands\r\n        $(document).keydown((e) => {\r\n            if ((e.which === 89 && e.ctrlKey) || (e.which === 90 && e.ctrlKey && e.shiftKey)) {\r\n                self.redo();\r\n            }\r\n            else if (e.which === 90 && e.ctrlKey) {\r\n                self.undo();\r\n            }\r\n        });\r\n\r\n        // When clicking off of the network, remove the Delete functionality\r\n        $(document).on(\"click\", (e) => {\r\n            if ($(self.container).has(e.target).length === 0) {\r\n                lastNetworkClickEvent = null;\r\n            }\r\n        });\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport gHelp from './graphHelpers';\r\nimport help from './genericHelpers';\r\n\r\nconst petersenEdges = help.deepFreeze([\r\n    {from: 1, to: 2},\r\n    {from: 2, to: 3},\r\n    {from: 3, to: 4},\r\n    {from: 4, to: 5},\r\n    {from: 5, to: 1},\r\n\r\n    {from: 6, to: 8},\r\n    {from: 7, to: 9},\r\n    {from: 7, to: 10},\r\n    {from: 8, to: 10},\r\n    {from: 9, to: 6},\r\n\r\n    {from: 1, to: 6},\r\n    {from: 2, to: 7},\r\n    {from: 3, to: 8},\r\n    {from: 4, to: 9},\r\n    {from: 5, to: 10}\r\n]);\r\n\r\nconst konigsbergEdges = help.deepFreeze([\r\n    {from: 1, to: 2},\r\n    {from: 2, to: 3},\r\n    {from: 2, to: 4},\r\n    {from: 3, to: 4},\r\n    {from: 3, to: 4},\r\n    {from: 4, to: 1},\r\n    {from: 4, to: 1},\r\n]);\r\n\r\nconst completeGraph = (V) => {\r\n    let edges = [];\r\n    let nodes = [];\r\n\r\n    for (let i = 0; i < V; i++) {\r\n        nodes.push({id: i, label: i.toString()});\r\n        for (let j = i + 1; j < V; j++) {\r\n            edges.push({from: i, to: j});\r\n        }\r\n    }\r\n\r\n    return {nodes: nodes, edges: edges, directed: false, weighted: false};\r\n};\r\n\r\nconst hypercubeGraph = (D) => {\r\n    let edges = [];\r\n    let nodes = [];\r\n\r\n    let numNodes = Math.pow(2, D);\r\n\r\n    let pad = (str, max) => {\r\n        return str.length < max ? pad(\"0\" + str, max) : str;\r\n    };\r\n\r\n    const generateDifferByOne = (input, numBits) => {\r\n        let inputBits = pad((input).toString(2), numBits).split(\"\").reverse();\r\n        let allDiffer = [];\r\n\r\n        // 1 bit difference from input, increasing order, none less than input\r\n        for (let b = 0; b < numBits; b++) {\r\n            if (inputBits[b] === \"0\") {\r\n                let newNum = inputBits.slice();\r\n                newNum[b] = \"1\";\r\n                allDiffer.push(parseInt(newNum.reverse().join(\"\"), 2));\r\n            }\r\n        }\r\n\r\n        return allDiffer;\r\n    };\r\n\r\n    for (let i = 0; i < numNodes; i++) {\r\n        nodes.push({id: i, label: pad(i.toString(2), D)});\r\n        generateDifferByOne(i, D).forEach((j) => {\r\n            edges.push({from: i, to: j});\r\n        });\r\n    }\r\n\r\n    return help.deepFreeze({nodes: nodes, edges: edges, directed: false, weighted: false});\r\n};\r\n\r\nconst newCustomGraph = (V, directed = false, weighted = false) => {\r\n    let nodes = [];\r\n    for (let i = 0; i < V; i++) {\r\n        nodes.push({id: i, label: i.toString()});\r\n    }\r\n\r\n    return help.deepFreeze({nodes: nodes, edges: [], directed: directed, weighted: weighted});\r\n};\r\n\r\nexport default {\r\n    graphNames: help.deepFreeze([\"Petersen\", \"Konigsberg\", \"Complete\", \"Hypercube\"]),\r\n    Petersen: () => (help.deepFreeze({\r\n        edges: petersenEdges,\r\n        nodes: gHelp.interpolateNodesFromEdges(petersenEdges),\r\n        directed: false,\r\n        weighted: false,\r\n    })),\r\n    Konigsberg: () => (help.deepFreeze({\r\n        edges: konigsbergEdges,\r\n        nodes: gHelp.interpolateNodesFromEdges(konigsbergEdges),\r\n        directed: false,\r\n        weighted: false,\r\n    })),\r\n    Complete: () => {\r\n        help.showFormModal(($modal, vals) => {\r\n                $modal.modal(\"hide\");\r\n                window.main.setData(completeGraph(vals[0]), false, true, true);\r\n            },\r\n            \"Configurable Complete Graph\", \"Go\",\r\n            [{\r\n                type: \"numeric\", initialValue: 5, label: \"Number of Vertices\", validationFunc: (v) => {\r\n                    return v >= 0 || \"Number of vertices must be non-negative\";\r\n                }\r\n            }]);\r\n    },\r\n    Hypercube: () => {\r\n        help.showFormModal(($modal, vals) => {\r\n                $modal.modal(\"hide\");\r\n                window.main.setData(hypercubeGraph(vals[0]), false, true, true);\r\n            },\r\n            \"Configurable Hypercube Graph\", \"Go\",\r\n            [{\r\n                type: \"numeric\", initialValue: 3, label: \"Number of Dimensions\", validationFunc: (v) => {\r\n                    return v >= 0 || \"Number of dimensions must be non-negative\";\r\n                }\r\n            }]);\r\n    },\r\n    Custom: () => {\r\n        help.showFormModal(($modal, vals) => {\r\n                $modal.modal(\"hide\");\r\n                window.main.setData(newCustomGraph(vals[0], vals[1], vals[2]), false, true, true);\r\n            },\r\n            \"Configurable Graph\", \"Go\",\r\n            [\r\n                {\r\n                    type: \"numeric\", initialValue: 0, label: \"Number of Vertices\", validationFunc: (v) => {\r\n                        return v >= 0 || \"Number of vertices must be non-negative\";\r\n                    }\r\n                },\r\n                {type: \"checkbox\", initialValue: false, label: \"Directed\"},\r\n                {type: \"checkbox\", initialValue: false, label: \"Weighted\"},\r\n            ]);\r\n    },\r\n};\r\n","import gHelp from \"./graphHelpers\";\nimport settings from \"./settings\";\nimport help from \"./genericHelpers\";\nimport $ from \"jquery\";\n\n\nconst makeAndPrintShortestPath = (title, fn, weighted) => {\n    help.showFormModal(($modal, values) => {\n            $modal.modal(\"hide\");\n\n            let source = window.main.graphState.nodeLabelToID(values[0]);\n            let sink = window.main.graphState.nodeLabelToID(values[1]);\n\n            let a = fn(source, sink);\n            if (a === false) {\n                return;\n            }\n\n            let p = \"<h3>\" + title + \"</h3><hr>No path exists from \"\n                + help.htmlEncode(source) + \" to \" + help.htmlEncode(sink);\n\n            if (a.pathExists) {\n                p = title + \" From \" + window.main.graphState.nodeIDToLabel(source) + \" to \";\n                p += window.main.graphState.nodeIDToLabel(sink) + \": \" + a.distance;\n                if (weighted) {\n                    p += \"\\nWith weighted cost: \" + a.cost;\n                }\n                p += \"\\n\\nUsing Path: \";\n\n                p = help.htmlEncode(p);\n                a.path.forEach((v) => {\n                    p += help.htmlEncode(window.main.graphState.nodeIDToLabel(v)) + \" &rarr; \";\n                });\n                p = p.slice(0, -8);\n                p = \"<h3>\" + title + \"</h3><hr>\" + p;\n            }\n\n            help.printout(p);\n        },\n        title, \"Go\", [\n            {label: \"Start Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n            {label: \"End Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n        ]);\n};\n\nconst makeAndPrintComponents = async (stronglyConnected) => {\n    let a = null;\n    let cc = \"Connected Components\";\n    let componentKey = \"connectedComponents\";\n    let gg = await import(\"./GraphAlgorithms\");\n    const gAlgo = gg.default;\n\n    if (stronglyConnected) {\n        if (!settings.getOption(\"direction\")) {\n            return;\n        }\n        cc = \"Strongly \" + cc;\n        componentKey = \"stronglyConnectedComponents\";\n        a = gAlgo.stronglyConnectedComponents();\n    }\n    else {\n        if (settings.getOption(\"direction\")) {\n            return;\n        }\n        a = gAlgo.connectedComponents();\n    }\n\n    window.main.graphState.graphProperties[cc] = a.count;\n    window.main.graphState.setUpToDate(true, [cc, componentKey]);\n    window.main.graphState.state[componentKey] = a.components;\n\n    let components = help.flatten(a.components);\n    let p = \"Number of \" + cc + \": \" + a.count;\n    p += \"\\n\\n\";\n\n    components.forEach((v, i) => {\n        p += \"Vertex \" + window.main.graphState.nodeIDToLabel(i) + \" is in connected component #\" + v + \"\\n\";\n    });\n\n    p += \"\\n\" + JSON.stringify(help.rotate(a.components), null, 4) + \"\\n\\n\";\n    p = \"<h3>\" + cc + \"</h3><hr>\" + help.htmlEncode(p);\n\n    help.printout(p);\n};\n\nexport default class UIInteractions {\n    static getAlgorithms () {\n        return [\n            {\n                name: \"Graph Coloring\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintGraphColoring,\n                display: true\n            },\n            {\n                name: \"Connected Components\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintConnectedComponents,\n                display: true\n            },\n            {\n                name: \"Strongly Connected Components\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintStronglyConnectedComponents\n            },\n            {\n                name: \"Breadth-First Shortest Path\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintBFS,\n                display: true\n            },\n            {\n                name: \"Dijkstra Shortest Path\",\n                applyFunc: UIInteractions.makeAndPrintDijkstra,\n                display: true\n            },\n            {\n                name: \"Bellman-Ford Shortest Path\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintBFSP,\n                display: true\n            },\n            {\n                name: \"Ford-Fulkerson\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintFFMCMF,\n                display: true\n            },\n            {\n                name: \"Kruskal Minimum Spanning Tree\",\n                weighted: true,\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintKruskal,\n                display: true\n            },\n            {\n                name: \"Cyclic\",\n                applyFunc: UIInteractions.makeAndPrintIsCyclic,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Topological Sort\",\n                applyFunc: UIInteractions.makeAndPrintTopologicalSort,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Eulerian\",\n                directional: false,\n                display: false,\n                applyFunc: null\n            },\n            {\n                name: \"Eulerian\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintDirectionalEulerian\n            },\n        ];\n    }\n\n    static registerListeners () {\n        const makeSimpleClickListener = (selector, fn) => {\n            $(selector).on(\"click\", (e) => {\n                e.preventDefault();\n                fn();\n            });\n        };\n\n        makeSimpleClickListener(\"#print-help-link\", UIInteractions.printHelp);\n        makeSimpleClickListener(\"#graph-options-link\", UIInteractions.printOptions);\n        makeSimpleClickListener(\"#load-petersen-link\",\n            () => {\n                window.main.setData(window.predefined.Petersen(), false, true, true);\n            });\n        makeSimpleClickListener(\"#load-konigsberg-link\",\n            () => {\n                window.main.setData(window.predefined.Konigsberg(), false, true, true);\n            });\n        makeSimpleClickListener(\"#load-complete-link\", window.predefined.Complete);\n        makeSimpleClickListener(\"#load-hypercube-link\", window.predefined.Hypercube);\n        makeSimpleClickListener(\"#load-custom-link\", window.predefined.Custom);\n        makeSimpleClickListener(\"#undo-link\", window.main.undo);\n        makeSimpleClickListener(\"#redo-link\", window.main.redo);\n        makeSimpleClickListener(\"#calculate-all-properties-link\",\n            () => {\n                window.main.graphState.makeAndPrintProperties(true);\n            });\n        makeSimpleClickListener(\"#new-graph-layout-link\", window.main.shuffleNetworkLayout);\n        makeSimpleClickListener(\"#import-file-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeImportFileModal();\n        });\n        makeSimpleClickListener(\"#import-text-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeImportTextModal();\n        });\n        makeSimpleClickListener(\"#export-file-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeExportFileModal();\n        });\n        makeSimpleClickListener(\"#export-text-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeExportTextModal();\n        });\n    }\n\n    static printHelp () {\n        help.showSimpleModal(\"Help\",\n            \"<h4>For support see the <a href='https://github.com/MikeDombo/graphPlayground' \" +\n            \"target='_blank'>GitHub repository</a> for guides</h4>\" +\n            \"<h4>See <a href='https://github.com/MikeDombo/graphPlayground/issues'\" +\n            \" target='_blank'>GitHub issues</a> to submit bugs or feature requests.</h4>\");\n    }\n\n    static printOptions () {\n        help.showFormModal(\n            ($modal, vals) => {\n                $modal.modal(\"hide\");\n                if (settings.getOption(\"nodePhysics\") !== vals[0]) {\n                    settings.changeOption(\"nodePhysics\", vals[0]); // Physics\n                }\n                if (settings.getOption(\"direction\") !== vals[1]) {\n                    settings.changeOption(\"direction\", vals[1]);\n                    let G = window.main.graphState.graph;\n                    G = vals[1] ? G.asDirected(true) : G.asUndirected();\n                    // Clear node coloring because graph color doesn't apply to directed graphs\n                    window.main.setData(window.main.graphState.getGraphData(G, true));\n                }\n                if (settings.getOption(\"weights\") !== vals[2]) {\n                    settings.changeOption(\"weights\", vals[2]);\n                    let G = window.main.graphState.graph;\n                    G = vals[2] ? G.asWeighted() : G.asUnweighted();\n                    window.main.setData(window.main.graphState.getGraphData(G));\n                }\n            },\n            \"Options\", \"Save\", [\n                {label: \"Graph Physics\", initialValue: settings.getOption(\"nodePhysics\"), type: \"checkbox\"},\n                {label: \"Directed Graph\", initialValue: settings.getOption(\"direction\"), type: \"checkbox\"},\n                {label: \"Weighted Graph\", initialValue: settings.getOption(\"weights\"), type: \"checkbox\"}\n            ], null);\n    }\n\n    static async makeAndPrintGraphColoring () {\n        if (settings.getOption(\"direction\")) {\n            return;\n        }\n\n        // Use cached responses when able\n        let a = {\n            chromaticNumber: window.main.graphState.getProperty(\"Chromatic Number\"),\n            colors: window.main.graphState.state.graphColoring\n        };\n        if (!(a.chromaticNumber !== null && window.main.graphState.getProperty(\"graphColoring\") !== null)) {\n            let gg = await import(\"./GraphAlgorithms\");\n            const gAlgo = gg.default;\n            a = gAlgo.colorNetwork();\n        }\n\n        window.main.graphState.graphProperties[\"Chromatic Number\"] = a.chromaticNumber;\n        window.main.graphState.setUpToDate(true, [\"Chromatic Number\", \"graphColoring\"]);\n        window.main.graphState.state.graphColoring = a.colors;\n\n        let colors = help.flatten(a.colors);\n        let p = \"Number of Vertices: \" + colors.length;\n        p += \"\\nChromatic Number: \" + a.chromaticNumber;\n        p += \"\\n\\n\";\n\n        colors.forEach((v, i) => {\n            p += \"Vertex \" + window.main.graphState.nodeIDToLabel(i) + \" gets color \" + v + \"\\n\";\n        });\n\n        p += \"\\n\" + JSON.stringify(help.rotate(a.colors), null, 4) + \"\\n\\n\";\n\n        p = \"<h3>Graph Coloring Using Welsh-Powell Algorithm</h3><hr>\" + help.htmlEncode(p);\n        p += \"<br/><button class='btn btn-primary' onclick='main.applyColors()'>Apply New Colors To Graph</button>\";\n\n        help.printout(p);\n        window.main.applyColors();\n    }\n\n    static makeAndPrintConnectedComponents () {\n        makeAndPrintComponents(false);\n    }\n\n    static async makeAndPrintDirectionalEulerian () {\n        if (!settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        let t = gAlgo.directionalEulerian(gHelp.findVertexDegreesDirectional(window.main.graphState.graph.getFullAdjacency()));\n        window.main.graphState.setUpToDate(true, [\"eulerian\"]);\n        window.main.graphState.graphProperties.eulerian = t;\n    }\n\n    static async makeAndPrintEulerian () {\n        if (settings.getOption(\"direction\")) {\n            UIInteractions.makeAndPrintDirectionalEulerian();\n            return;\n        }\n\n        window.main.graphState.setUpToDate(true, [\"eulerian\"]);\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        window.main.graphState.graphProperties.eulerian = gAlgo.hasEulerianCircuit(window.main.graphState.graph.getAllOutDegrees());\n    }\n\n    static makeAndPrintStronglyConnectedComponents () {\n        makeAndPrintComponents(true);\n    }\n\n    static async makeAndPrintBFS () {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Breadth-First Shortest Path\", gAlgo.breadthFirstSearch);\n    }\n\n    static async makeAndPrintDijkstra () {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Dijkstra Shortest Path\", gAlgo.dijkstraSearch, true);\n    }\n\n    static async makeAndPrintBFSP () {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Bellman-Ford Shortest Path\", gAlgo.bellmanFord, true);\n    }\n\n    static makeAndPrintFFMCMF () {\n        if (!settings.getOption(\"direction\") || !settings.getOption(\"weights\")) {\n            return;\n        }\n        help.showFormModal(async ($modal, values) => {\n                $modal.modal(\"hide\");\n\n                let source = window.main.graphState.nodeLabelToID(values[0]);\n                let sink = window.main.graphState.nodeLabelToID(values[1]);\n                let gg = await import(\"./GraphAlgorithms\");\n                const gAlgo = gg.default;\n                let a = gAlgo.fordFulkerson(source, sink);\n\n                let p = \"<h3>Ford-Fulkerson</h3><hr>No path exists from \"\n                    + help.htmlEncode(window.main.graphState.nodeIDToLabel(source))\n                    + \" to \" + help.htmlEncode(window.main.graphState.nodeIDToLabel(sink));\n\n                if (a === false) {\n                    help.printout(p);\n                    return;\n                }\n\n                p = \"Ford-Fulkerson MaxFlow-MinCut Max Flow From \" + window.main.graphState.nodeIDToLabel(source)\n                    + \" to \" + window.main.graphState.nodeIDToLabel(sink) + \": \" + a.maxFlow;\n                p += \"\\n\\nUsing Capacities:\\n\\n\";\n                p = help.htmlEncode(p);\n                a.flowPath.forEach((v) => {\n                    p += window.main.graphState.nodeIDToLabel(v.from) + \"&rarr;\" + window.main.graphState.nodeIDToLabel(v.to)\n                        + \" using \" + v.flow + \" of \" + v.capacity + \" \\n\";\n                });\n                p = p.trim();\n                p = \"<h3>Ford-Fulkerson MaxFlow-MinCut</h3><hr>\" + p;\n\n                help.printout(p);\n            },\n            \"Ford-Fulkerson MaxFlow-MinCut\", \"Go\", [\n                {label: \"Source Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n                {label: \"Sink Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n            ]);\n    }\n\n    static async makeAndPrintKruskal () {\n        if (settings.getOption(\"direction\") || !settings.getOption(\"weights\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n\n        let a = gAlgo.kruskal();\n\n        let p = \"Kruskal's Minimum Spanning Tree Total Weight: \" + a.totalWeight;\n        p += \"\\n\\nUsing Edges:\\n\\n\";\n        p = help.htmlEncode(p);\n        a.mst.forEach((v) => {\n            p += window.main.graphState.nodeIDToLabel(v.from) + \"&rarr;\" + window.main.graphState.nodeIDToLabel(v.to) + \" \\n\";\n        });\n        p = p.trim();\n        p = \"<h3>Kruskal Minimum Spanning Tree</h3><hr>\" + p;\n\n        help.printout(p);\n    }\n\n    static async makeAndPrintIsCyclic () {\n        if (!settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        window.main.graphState.graphProperties.cyclic = gAlgo.isGraphCyclic();\n        window.main.graphState.setUpToDate(true, [\"cyclic\"]);\n    }\n\n    static async makeAndPrintTopologicalSort () {\n        if (!settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        let a = gAlgo.topologicalSort();\n\n        if (a === true) {\n            window.main.graphState.graphProperties.cyclic = true;\n            window.main.graphState.setUpToDate(true, [\"cyclic\"]);\n\n            let p = \"Topological sorting failed because the graph contains a cycle\";\n            p = \"<h3>Topological Sorting Failed</h3><hr>\" + p;\n            help.printout(p);\n\n            return;\n        }\n\n        let p = \"Topological Sorting:\\n\\n\";\n        p = help.htmlEncode(p);\n        a.forEach((v) => {\n            p += window.main.graphState.nodeIDToLabel(v.id) + \", \";\n        });\n        p = p.slice(0, -2);\n        p = \"<h3>Topological Sorting</h3><hr>\" + p;\n\n        help.printout(p);\n    }\n\n    static printGraphAlgorithms () {\n        let $div = $(\"#algorithms-pane\");\n        $div.empty();\n        let directional = settings.getOption(\"direction\");\n        let weighted = settings.getOption(\"weights\");\n\n        const addAlgoToPane = (alg) => {\n            $div.append($(\"<a>\", {class: \"nav-link\", href: \"#\"})\n                .text(alg.name).on(\"click\", (e) => {\n                    e.preventDefault();\n                    alg.applyFunc();\n                }));\n        };\n\n        let a = UIInteractions.getAlgorithms();\n        a.forEach((alg) => {\n            if (!alg.display) {\n                return;\n            }\n            if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n            else if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n        });\n    }\n}\n","\"use strict\";\r\n\r\nimport 'bootstrap';\r\nimport Raven from 'raven-js';\r\nimport {Network} from 'vis/index-network';\r\nimport main from './main';\r\nimport predefined from './predefinedGraphs';\r\nimport settings from './settings';\r\nimport UI from './UIInteractions';\r\n\r\nwindow.main = main;\r\nwindow.predefined = predefined;\r\nwindow.network = new Network(main.container, {}, main.visOptions);\r\nwindow.settings = settings;\r\nwindow.ui = UI;\r\n\r\n// Initialize Sentry.io error logging\r\nRaven.config('https://92aaeee7e2fb4ef4837a2261a029e8ed@sentry.home.mikedombrowski.com/2').install();\r\n\r\nwindow.Raven = Raven;\r\n\r\nmain.addNetworkListeners(window.network);\r\n\r\nsettings.loadSettings();\r\n\r\nlet loadDefault = true;\r\nif (settings.checkForLocalStorage()) {\r\n    let s = localStorage.getItem(\"graphPlayground.lastState\");\r\n    if (s !== null) {\r\n        s = JSON.parse(s);\r\n        if (\"nodes\" in s.graph) {\r\n            loadDefault = false;\r\n            main.applyState(false, s);\r\n        }\r\n    }\r\n}\r\nif (loadDefault) {\r\n    main.setData(predefined.Petersen(), false, true, true);\r\n}\r\n\r\nwindow.ui.registerListeners();\r\n"],"sourceRoot":""}