(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{104:function(e,t,r){"use strict";r.r(t);var o=r(1),n=r(27);let i={colorNetwork:(e=window.main.graphState)=>{let t=e.graph,r=o.a.datasetToArray(t.getAllNodes(),"id"),n=t.getAllOutDegrees(),i=o.a.sort(r,(e,t)=>n[e]<n[t]?1:n[e]===n[t]?0:-1),l={},h=0;for(;i.length>0;){let e=i.shift();l[e]=h;let r=[];r.push(e);for(let e=0;e<i.length;){let o=i[e],n=!1;for(let i=0;i<r.length;i++)if(t.areAdjacent(o,r[i])){e++,n=!0;break}n||(l[o]=h,r.push(o),i.splice(e,1))}h++}return{colors:l,chromaticNumber:o.a.max(o.a.flatten(l))+1}},connectedComponents:(e=window.main.graphState)=>{let t=e.graph,r={},o=0;const n=e=>{r[e]=o};for(let e=0;e<t.getNumberOfNodes();e++)if(!(e in r)){i.depthFirstSearch(t,e).forEach(n),o++}return{components:r,count:o}},depthFirstSearch:(e=window.main.graphState.graph,t)=>{let r=[],o=[];for(o.push(t);o.length>0;){let t=o.pop();r.includes(t)||(r.push(t),e.getNodeAdjacency(t).forEach(e=>{o.push(e)}))}return r},stronglyConnectedComponents:(e=window.main.graphState)=>{let t=e.graph,r=0,o={},n={},i=[],l={},h=0,a=e=>{if(o[e]=r,n[e]=r++,i.push(e),t.getNodeAdjacency(e).forEach(t=>{t in o?i.includes(t)&&(n[e]=Math.min(n[e],o[t])):(a(t),n[e]=Math.min(n[e],n[t]))}),n[e]===o[e]){let t=-1;if(i.length>0){do{t=i.pop(),l[t]=h}while(t!==e);h++}}};for(let e=0;e<t.getNumberOfNodes();e++)e in o||a(e);return{components:l,count:h}},breadthFirstSearch:(e,t,r=window.main.graphState)=>{let o=r.graph,n=[],i=[],l={};for(i.push(e);i.length>0;){let e=i.shift();n.includes(e)||(n.push(e),o.getNodeAdjacency(e).forEach(t=>{n.includes(t)||(l[t]=e,i.push(t))}))}if(n.includes(t)){let r=[];for(let o=t;o!==e;o=l[o])r.push(o);r.push(e),r.reverse();let n=0;for(let e=0;e<r.length-1;e++)n+=o.getMinWeightEdgeBetween(r[e],r[e+1]);return{pathExists:!0,path:r,distance:r.length,weight:n}}return{pathExists:!1,path:[],distance:-1,weight:-1}},dijkstraSearch:(e,t,r=window.main.graphState)=>{let n=r.graph;if(n.isDirected()||(n=n.asDirected(!0)),n.isWeighted()||(n=n.asWeighted()),void 0!==n.getAllEdges(!0).find(e=>e.getWeight()<0))return o.a.showSimpleModal("Dijkstra Error","<p>The Dijkstra algorithm only works on graphs with totally non-negative edge weights. Please fix the graph so that there are no negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves exactly this problem.</p>"),!1;let i=new function(){this._nodes=[],this.enqueue=function(e,t){this._nodes.push({key:t,priority:e}),this.sort()},this.dequeue=function(){return this._nodes.shift().key},this.sort=function(){this._nodes.sort(function(e,t){return e.priority-t.priority})},this.isEmpty=function(){return!this._nodes.length}},l={},h={},a=[];for(n.getAllNodes(!0).forEach(t=>{let r=1/0;t.getID()===e&&(r=0),l[t.getID()]=r,i.enqueue(r,t.getID()),h[t.getID()]=null});!i.isEmpty();){let e=i.dequeue();if(e===t){for(a=[];null!==h[e];)a.push(e),e=h[e];break}l[e]!==1/0&&n.getNodeAdjacency(e).forEach(t=>{let r=l[e]+n.getMinWeightEdgeBetween(e,t);r<l[t]&&(l[t]=r,h[t]=e,i.enqueue(r,t))})}return a.push(e),a.reverse(),l[t]!==1/0?{pathExists:!0,path:a,distance:a.length,cost:l[t]}:{pathExists:!1,path:[],distance:-1,cost:0}},bellmanFord:(e,t,r=window.main.graphState)=>{let n=r.graph,i=[],l=[];n.getAllNodes(!0).forEach(e=>{i[e.getID()]=1/0,l[e.getID()]=null}),i[e]=0;for(let e=0;e<n.getNumberOfNodes()-1;e++)n.getAllEdges(!0).forEach(e=>{i[e.getFrom()]+e.getWeight()<i[e.getTo()]&&(i[e.getTo()]=i[e.getFrom()]+e.getWeight(),l[e.getTo()]=e.getFrom())});let h=!1;if(n.getAllEdges(!0).forEach(e=>{i[e.getFrom()]+e.getWeight()<i[e.getTo()]&&(h=!0)}),i[t]!==1/0){let r=[t];for(;!r.includes(e);)r.push(l[r.slice().pop()]);return r.reverse(),{pathExists:!0,path:r,distance:r.length,cost:i[t]}}return h?(o.a.showSimpleModal("Bellman-Ford Error","<p>The Bellman-Ford algorithm only works on graphs with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>"),!1):{pathExists:!1,path:[],distance:-1,cost:0}},fordFulkerson:(e,t,r=window.main.graphState)=>{let o=r.graph;if(!o.isDirected())return!1;if(e===t)return!1;if(!i.breadthFirstSearch(e,t,r).pathExists)return!1;let n=(o=o.reduceMultiGraph((e,t)=>e+t)).getNumberOfNodes(),l=0,h=null,a=null,s={};o.getAllEdges(!0).forEach(e=>{s[e.getFrom()+"_"+e.getTo()]={from:e.getFrom(),to:e.getTo(),capacity:e.getWeight(),flow:0}});const g=(e,t)=>{e=e.split("_");let r=parseInt(e[0]),o=parseInt(e[1]);return t===r?o:r},p=(e,t)=>{let r=e.split("_");return t===parseInt(r[0])?s[e].flow:s[e].capacity-s[e].flow},d=(e,t,r)=>{let o=e.split("_");t===parseInt(o[0])?s[e].flow-=r:s[e].flow+=r},u=()=>{h=[],a=[];for(let e=0;e<n;++e)h.push(!1),a.push(null);let r=[];for(r.push(e),h[e]=!0;r.length>0;){let e=r.shift(),n=o.getNodeAdjacency(e);for(let o=0;o<n.length;o++){let i=e+"_"+n[o],l=g(i,e);if(!h[l]&&p(i,l)>0){if(a[l]=i,h[l]=!0,l===t)return!0;r.push(l)}}}return!1};for(;u();){let r=1/0;for(let o=t;o!==e;o=g(a[o],o))r=Math.min(r,p(a[o],o));for(let o=t;o!==e;o=g(a[o],o))d(a[o],o,r);l+=r}return{maxFlow:l,flowPath:(()=>{let e=[];for(let t=0;t<n;t++){let r=o.getNodeAdjacency(t);for(let o=0;o<r.length;o++){let n=t+"_"+r[o];s[n].flow>0&&e.push(s[n])}}return e})()}},kruskal:(e=window.main.graphState)=>{let t=e.graph;t.reduceMultiGraph(Math.min,1/0);let r=t.getAllEdges(!0);r.sort((e,t)=>e.getWeight()-t.getWeight());let o=[],n=new class{constructor(e){this.id=[];for(let t=0;t<e;t++)this.id.push(t)}union(e,t){let r=this.root(e),o=this.root(t);o!==r&&(this.id[o]=r)}root(e){for(;this.id[e]!==e;)e=this.id[e];return e}connected(e,t){return this.root(e)===this.root(t)}}(t.getNumberOfNodes());for(;r.length>0&&o.length<t.getNumberOfNodes()-1;){let e=r.shift();n.connected(e.getFrom(),e.getTo())||(n.union(e.getFrom(),e.getTo()),o.push(e))}return{mst:o,totalWeight:o.reduce((e,t)=>e+t.getWeight(),0)}},topologicalSort:(e=window.main.graphState)=>{let t=e.graph,r=t.getFullAdjacency(),o=n.a.findVertexDegreesDirectional(r),i=[],l=t.getAllNodes(!0).filter(e=>0===o[e.getID()].in),h=t.getAllEdges(!0);for(;0!==l.length;){let e=l.pop();i.push(e);let n=r[e.getID()];h=h.filter(t=>t.getFrom()!==e.getID()||!n.includes(t.getTo())||(o[t.getTo()].in--,r[e.getID()]=r[e.getID()].filter(e=>e!==t.getTo()),!1)),n.forEach(e=>{0===o[e].in&&l.push(t.getNode(e,!0))})}return h.length>0||i},isGraphCyclic:(e=window.main.graphState)=>!0===i.topologicalSort(e),directionalEulerian:(e,t=window.main.graphState)=>{let r=t.getProperty("stronglyConnectedComponents",!0),o=!0,n=-1;return e.forEach((e,t)=>{e.in!==e.out&&(o=!1),e.in>0&&(-1===n&&(n=r[t]),n!==r[t]&&(o=!1))}),o},hasEulerianCircuit:(e,t=window.main.graphState)=>{if(0!==e.filter(e=>e%2!=0).length)return!1;let r=t.getProperty("connectedComponents",!0),o=!0,n=-1;return e.forEach((e,t)=>{0!==e&&(-1===n&&(n=r[t]),n!==r[t]&&(o=!1))}),o}};t.default=i}}]);
//# sourceMappingURL=0-d0efe424f04db1f1f8d5.min.js.map