(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{103:function(e,t,r){"use strict";r.r(t);var o=r(1),n=r(11);let i=function(e){this.id=[];for(let t=0;t<e;t++)this.id.push(t)};i.prototype={constructor:i,union:function(e,t){let r=this.root(e),o=this.root(t);o!==r&&(this.id[o]=r)},root:function(e){for(;this.id[e]!==e;)e=this.id[e];return e},connected:function(e,t){return this.root(e)===this.root(t)}};var l=o.a.deepFreeze(i);let a={colorNetwork:(e=window.main.graphState)=>{let t=e.graph,r=o.a.datasetToArray(t.getAllNodes(),"id"),n=t.getAllOutDegrees(),i=o.a.sort(r,(e,t)=>n[e]<n[t]?1:n[e]===n[t]?0:-1),l={},a=0;for(;i.length>0;){let e=i.shift();l[e]=a;let r=[];r.push(e);for(let e=0;e<i.length;){let o=i[e],n=!1;for(let i=0;i<r.length;i++)if(t.areAdjacent(o,r[i])){e++,n=!0;break}n||(l[o]=a,r.push(o),i.splice(e,1))}a++}return{colors:l,chromaticNumber:o.a.max(o.a.flatten(l))+1}},connectedComponents:(e=window.main.graphState)=>{let t=e.graph,r={},o=0;const n=e=>{r[e]=o};for(let e=0;e<t.getNumberOfNodes();e++)if(!(e in r)){a.depthFirstSearch(t,e).forEach(n),o++}return{components:r,count:o}},depthFirstSearch:(e=window.main.graphState.graph,t)=>{let r=[],o=[];for(o.push(t);o.length>0;){let t=o.pop();r.includes(t)||(r.push(t),e.getNodeAdjacency(t).forEach(e=>{o.push(e)}))}return r},stronglyConnectedComponents:(e=window.main.graphState)=>{let t=e.graph,r=0,o={},n={},i=[],l={},a=0,h=e=>{if(o[e]=r,n[e]=r++,i.push(e),t.getNodeAdjacency(e).forEach(t=>{t in o?i.includes(t)&&(n[e]=Math.min(n[e],o[t])):(h(t),n[e]=Math.min(n[e],n[t]))}),n[e]===o[e]){let t=-1;if(i.length>0){do{t=i.pop(),l[t]=a}while(t!==e);a++}}};for(let e=0;e<t.getNumberOfNodes();e++)e in o||h(e);return{components:l,count:a}},breadthFirstSearch:(e,t,r=window.main.graphState)=>{let o=r.graph,n=[],i=[],l={};for(i.push(e);i.length>0;){let e=i.shift();n.includes(e)||(n.push(e),o.getNodeAdjacency(e).forEach(t=>{n.includes(t)||(l[t]=e,i.push(t))}))}if(n.includes(t)){let r=[];for(let o=t;o!==e;o=l[o])r.push(o);r.push(e),r.reverse();let n=0;for(let e=0;e<r.length-1;e++)n+=o.getMinWeightEdgeBetween(r[e],r[e+1]);return{pathExists:!0,path:r,distance:r.length,weight:n}}return{pathExists:!1,path:[],distance:-1,weight:-1}},dijkstraSearch:(e,t,r=window.main.graphState)=>{let n=r.graph;if(n.isDirected()||(n=n.asDirected(!0)),n.isWeighted()||(n=n.asWeighted()),void 0!==n.getAllEdges(!0).find(e=>e.getWeight()<0))return o.a.showSimpleModal("Dijkstra Error","<p>The Dijkstra algorithm only works on graphs with totally non-negative edge weights. Please fix the graph so that there are no negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves exactly this problem.</p>"),!1;let i=new function(){this._nodes=[],this.enqueue=function(e,t){this._nodes.push({key:t,priority:e}),this.sort()},this.dequeue=function(){return this._nodes.shift().key},this.sort=function(){this._nodes.sort(function(e,t){return e.priority-t.priority})},this.isEmpty=function(){return!this._nodes.length}},l={},a={},h=[];for(n.getAllNodes(!0).forEach(t=>{let r=1/0;t.getID()===e&&(r=0),l[t.getID()]=r,i.enqueue(r,t.getID()),a[t.getID()]=null});!i.isEmpty();){let e=i.dequeue();if(e===t){for(h=[];null!==a[e];)h.push(e),e=a[e];break}l[e]!==1/0&&n.getNodeAdjacency(e).forEach(t=>{let r=l[e]+n.getMinWeightEdgeBetween(e,t);r<l[t]&&(l[t]=r,a[t]=e,i.enqueue(r,t))})}return h.push(e),h.reverse(),l[t]!==1/0?{pathExists:!0,path:h,distance:h.length,cost:l[t]}:{pathExists:!1,path:[],distance:-1,cost:0}},bellmanFord:(e,t,r=window.main.graphState)=>{let n=r.graph,i=[],l=[];n.getAllNodes(!0).forEach(e=>{i[e.getID()]=1/0,l[e.getID()]=null}),i[e]=0;for(let e=0;e<n.getNumberOfNodes()-1;e++)n.getAllEdges(!0).forEach(e=>{i[e.getFrom()]+e.getWeight()<i[e.getTo()]&&(i[e.getTo()]=i[e.getFrom()]+e.getWeight(),l[e.getTo()]=e.getFrom())});let a=!1;if(n.getAllEdges(!0).forEach(e=>{i[e.getFrom()]+e.getWeight()<i[e.getTo()]&&(a=!0)}),i[t]!==1/0){let r=[t];for(;!r.includes(e);)r.push(l[r.slice().pop()]);return r.reverse(),{pathExists:!0,path:r,distance:r.length,cost:i[t]}}return a?(o.a.showSimpleModal("Bellman-Ford Error","<p>The Bellman-Ford algorithm only works on graphs with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>"),!1):{pathExists:!1,path:[],distance:-1,cost:0}},fordFulkerson:(e,t,r=window.main.graphState)=>{let o=r.graph;if(!o.isDirected())return!1;if(e===t)return!1;if(!a.breadthFirstSearch(e,t,r).pathExists)return!1;let n=(o=o.reduceMultiGraph((e,t)=>e+t)).getNumberOfNodes(),i=0,l=null,h=null,s={};o.getAllEdges(!0).forEach(e=>{s[e.getFrom()+"_"+e.getTo()]={from:e.getFrom(),to:e.getTo(),capacity:e.getWeight(),flow:0}});const g=(e,t)=>{e=e.split("_");let r=parseInt(e[0]),o=parseInt(e[1]);return t===r?o:r},p=(e,t)=>{let r=e.split("_");return t===parseInt(r[0])?s[e].flow:s[e].capacity-s[e].flow},u=(e,t,r)=>{let o=e.split("_");t===parseInt(o[0])?s[e].flow-=r:s[e].flow+=r},d=()=>{l=[],h=[];for(let e=0;e<n;++e)l.push(!1),h.push(null);let r=[];for(r.push(e),l[e]=!0;r.length>0;){let e=r.shift(),n=o.getNodeAdjacency(e);for(let o=0;o<n.length;o++){let i=e+"_"+n[o],a=g(i,e);if(!l[a]&&p(i,a)>0){if(h[a]=i,l[a]=!0,a===t)return!0;r.push(a)}}}return!1};for(;d();){let r=1/0;for(let o=t;o!==e;o=g(h[o],o))r=Math.min(r,p(h[o],o));for(let o=t;o!==e;o=g(h[o],o))u(h[o],o,r);i+=r}return{maxFlow:i,flowPath:(()=>{let e=[];for(let t=0;t<n;t++){let r=o.getNodeAdjacency(t);for(let o=0;o<r.length;o++){let n=t+"_"+r[o];s[n].flow>0&&e.push(s[n])}}return e})()}},kruskal:(e=window.main.graphState)=>{let t=e.graph;t.reduceMultiGraph(Math.min,1/0);let r=t.getAllEdges(!0);r.sort((e,t)=>e.getWeight()-t.getWeight());let o=[],n=new l(t.getNumberOfNodes());for(;r.length>0&&o.length<t.getNumberOfNodes()-1;){let e=r.shift();n.connected(e.getFrom(),e.getTo())||(n.union(e.getFrom(),e.getTo()),o.push(e))}return{mst:o,totalWeight:o.reduce((e,t)=>e+t.getWeight(),0)}},topologicalSort:(e=window.main.graphState)=>{let t=e.graph,r=t.getFullAdjacency(),o=n.a.findVertexDegreesDirectional(r),i=[],l=t.getAllNodes(!0).filter(e=>0===o[e.getID()].in),a=t.getAllEdges(!0);for(;0!==l.length;){let e=l.pop();i.push(e);let n=r[e.getID()];a=a.filter(t=>t.getFrom()!==e.getID()||!n.includes(t.getTo())||(o[t.getTo()].in--,r[e.getID()]=r[e.getID()].filter(e=>e!==t.getTo()),!1)),n.forEach(e=>{0===o[e].in&&l.push(t.getNode(e,!0))})}return a.length>0||i},isGraphCyclic:(e=window.main.graphState)=>!0===a.topologicalSort(e),directionalEulerian:(e,t=window.main.graphState)=>{let r=t.getProperty("stronglyConnectedComponents",!0),o=!0,n=-1;return e.forEach((e,t)=>{e.in!==e.out&&(o=!1),e.in>0&&(-1===n&&(n=r[t]),n!==r[t]&&(o=!1))}),o},hasEulerianCircuit:(e,t=window.main.graphState)=>{if(0!==e.filter(e=>e%2!=0).length)return!1;let r=t.getProperty("connectedComponents",!0),o=!0,n=-1;return e.forEach((e,t)=>{0!==e&&(-1===n&&(n=r[t]),n!==r[t]&&(o=!1))}),o}};t.default=a}}]);
//# sourceMappingURL=0-cbcd766730cd0475ef58.min.js.map