(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{105:function(t,e,n){"use strict";n.r(e);var r=n(2),o=n(28),i=function(){function t(t){this.id=[];for(var e=0;e<t;e++)this.id.push(e)}return t.prototype.union=function(t,e){var n=this.root(t),r=this.root(e);r!==n&&(this.id[r]=n)},t.prototype.root=function(t){for(;this.id[t]!==t;)t=this.id[t];return t},t.prototype.connected=function(t,e){return this.root(t)===this.root(e)},t}(),a=n(0),u=function(t,e,n,r){return new(n||(n=Promise))(function(o,i){function a(t){try{s(r.next(t))}catch(t){i(t)}}function u(t){try{s(r.throw(t))}catch(t){i(t)}}function s(t){t.done?o(t.value):new n(function(e){e(t.value)}).then(a,u)}s((r=r.apply(t,e||[])).next())})},s=function(t,e){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=r[2&i[0]?"return":i[0]?"throw":"next"])&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[0,o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=(o=a.trys).length>0&&o[o.length-1])&&(6===i[0]||2===i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a)}catch(t){i=[6,t],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}},c=function(){return function(){var t=this;this.colorNetwork=function(t){void 0===t&&(t=a.a.graph);for(var e=r.a.datasetToArray(t.getAllNodes(),"id"),n=t.getAllOutDegrees(),o=r.a.sort(e,function(t,e){return n[t]<n[e]?1:n[t]===n[e]?0:-1}),i={},u=0;o.length>0;){var s=o.shift();i[s]=u;var c=[];c.push(s);for(var h=0;h<o.length;){for(var l=o[h],f=!1,g=0;g<c.length;g++)if(t.areAdjacent(l,c[g])){h++,f=!0;break}f||(i[l]=u,c.push(l),o.splice(h,1))}u++}return{colors:i,chromaticNumber:r.a.max(r.a.flatten(i))+1}},this.connectedComponents=function(e){void 0===e&&(e=a.a.graph);for(var n={},r=0,o=function(t){n[t]=r},i=0;i<e.getNumberOfNodes();i++)i in n||(t.depthFirstSearch(e,i).forEach(o),r++);return Promise.resolve({components:n,count:r})},this.depthFirstSearch=function(t,e){void 0===t&&(t=a.a.graph);var n=[],r=[];for(r.push(e);r.length>0;){var o=r.pop();n.includes(o)||(n.push(o),t.getNodeAdjacency(o).forEach(function(t){r.push(t)}))}return n},this.stronglyConnectedComponents=function(t){void 0===t&&(t=a.a.graph);for(var e=0,n={},r={},o=[],i={},u=0,s=function(a){if(n[a]=e,r[a]=e++,o.push(a),t.getNodeAdjacency(a).forEach(function(t){t in n?o.includes(t)&&(r[a]=Math.min(r[a],n[t])):(s(t),r[a]=Math.min(r[a],r[t]))}),r[a]===n[a]){var c=-1;if(o.length>0){do{c=o.pop(),i[c]=u}while(c!==a);u++}}},c=0;c<t.getNumberOfNodes();c++)c in n||s(c);return Promise.resolve({components:i,count:u})},this.breadthFirstSearch=function(t,e,n){void 0===n&&(n=a.a.graph);var r=[],o=[],i={};o.push(t);for(var u=function(){var t=o.shift();r.includes(t)||(r.push(t),n.getNodeAdjacency(t).forEach(function(e){r.includes(e)||(i[e]=t,o.push(e))}))};o.length>0;)u();if(r.includes(e)){for(var s=[],c=e;c!==t;c=i[c])s.push(c);s.push(t),s.reverse();for(var h=0,l=0;l<s.length-1;l++)h+=n.getMinWeightEdgeBetween(s[l],s[l+1]);return{pathExists:!0,path:s,distance:s.length,weight:h}}return{pathExists:!1,path:[],distance:-1,weight:-1}},this.dijkstraSearch=function(t,e,n){if(void 0===n&&(n=a.a.graph),n.isDirected()||(n=n.asDirected(!0)),n.isWeighted()||(n=n.asWeighted()),void 0!==n.getAllEdges(!0).find(function(t){return t.getWeight()<0}))return r.a.showSimpleModal("Dijkstra Error","<p>The Dijkstra algorithm only works on graphs with totally non-negative edge weights. Please fix the graph so that there are no negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves exactly this problem.</p>"),!1;var o=new function(){this._nodes=[],this.enqueue=function(t,e){this._nodes.push({key:e,priority:t}),this.sort()},this.dequeue=function(){return this._nodes.shift().key},this.sort=function(){this._nodes.sort(function(t,e){return t.priority-e.priority})},this.isEmpty=function(){return!this._nodes.length}},i={},u={},s=[];n.getAllNodes(!0).forEach(function(e){var n=1/0;e.getID()===t&&(n=0),i[e.getID()]=n,o.enqueue(n,e.getID()),u[e.getID()]=null});for(var c=function(){var t=o.dequeue();if(t===e){for(s=[];null!==u[t];)s.push(t),t=u[t];return"break"}if(i[t]===1/0)return"continue";n.getNodeAdjacency(t).forEach(function(e){var r=i[t]+n.getMinWeightEdgeBetween(t,e);r<i[e]&&(i[e]=r,u[e]=t,o.enqueue(r,e))})};!o.isEmpty()&&"break"!==c(););return s.push(t),s.reverse(),i[e]!==1/0?{pathExists:!0,path:s,distance:s.length,cost:i[e]}:{pathExists:!1,path:[],distance:-1,cost:0}},this.bellmanFord=function(t,e,n){void 0===n&&(n=a.a.graph);var o=[],i=[];n.getAllNodes(!0).forEach(function(t){o[t.getID()]=1/0,i[t.getID()]=null}),o[t]=0;for(var u=0;u<n.getNumberOfNodes()-1;u++)n.getAllEdges(!0).forEach(function(t){o[t.getFrom()]+t.getWeight()<o[t.getTo()]&&(o[t.getTo()]=o[t.getFrom()]+t.getWeight(),i[t.getTo()]=t.getFrom())});var s=!1;if(n.getAllEdges(!0).forEach(function(t){o[t.getFrom()]+t.getWeight()<o[t.getTo()]&&(s=!0)}),o[e]!==1/0){for(var c=[e];!c.includes(t);)c.push(i[c.slice().pop()]);return c.reverse(),{pathExists:!0,path:c,distance:c.length,cost:o[e]}}return s?(r.a.showSimpleModal("Bellman-Ford Error","<p>The Bellman-Ford algorithm only works on graphs with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>"),!1):{pathExists:!1,path:[],distance:-1,cost:0}},this.fordFulkerson=function(e,n,r){if(void 0===r&&(r=a.a.graph),!r.isDirected())return!1;if(e===n)return!1;if(!t.breadthFirstSearch(e,n,r).pathExists)return!1;var o=(r=r.reduceMultiGraph(function(t,e){return t+e})).getNumberOfNodes(),i=0,u=null,s=null,c={};r.getAllEdges(!0).forEach(function(t){c[t.getFrom()+"_"+t.getTo()]={from:t.getFrom(),to:t.getTo(),capacity:t.getWeight(),flow:0}});for(var h=function(t,e){t=t.split("_");var n=parseInt(t[0]),r=parseInt(t[1]);return e===n?r:n},l=function(t,e){var n=t.split("_");return e===parseInt(n[0])?c[t].flow:c[t].capacity-c[t].flow},f=function(t,e,n){var r=t.split("_");e===parseInt(r[0])?c[t].flow-=n:c[t].flow+=n},g=function(){u=[],s=[];for(var t=0;t<o;++t)u.push(!1),s.push(null);var i=[];for(i.push(e),u[e]=!0;i.length>0;){t=i.shift();for(var a=0,c=r.getNodeAdjacency(t);a<c.length;a++){var f=t+"_"+c[a],g=h(f,t);if(!u[g]&&l(f,g)>0){if(s[g]=f,u[g]=!0,g===n)return!0;i.push(g)}}}return!1};g();){for(var p=1/0,d=n;d!==e;d=h(s[d],d))p=Math.min(p,l(s[d],d));for(d=n;d!==e;d=h(s[d],d))f(s[d],d,p);i+=p}return{maxFlow:i,flowPath:function(){for(var t=[],e=0;e<o;e++)for(var n=0,i=r.getNodeAdjacency(e);n<i.length;n++){var a=e+"_"+i[n];c[a].flow>0&&t.push(c[a])}return t}()}},this.kruskal=function(t){void 0===t&&(t=a.a.graph),t.reduceMultiGraph(Math.min,1/0);var e=t.getAllEdges(!0);e.sort(function(t,e){return t.getWeight()-e.getWeight()});for(var n=[],r=new i(t.getNumberOfNodes());e.length>0&&n.length<t.getNumberOfNodes()-1;){var o=e.shift();r.connected(o.getFrom(),o.getTo())||(r.union(o.getFrom(),o.getTo()),n.push(o))}return{mst:n,totalWeight:n.reduce(function(t,e){return t+e.getWeight()},0)}},this.topologicalSort=function(t){void 0===t&&(t=a.a.graph);for(var e=t.getFullAdjacency(),n=o.a.findVertexDegreesDirectional(e),r=[],i=t.getAllNodes(!0).filter(function(t){return 0===n[t.getID()].in}),u=t.getAllEdges(!0),s=function(){var o=i.pop();r.push(o);var a=e[o.getID()];u=u.filter(function(t){return t.getFrom()!==o.getID()||!a.includes(t.getTo())||(n[t.getTo()].in--,e[o.getID()]=e[o.getID()].filter(function(e){return e!==t.getTo()}),!1)}),a.forEach(function(e){0===n[e].in&&i.push(t.getNode(e,!0))})};0!==i.length;)s();return u.length>0||r},this.isGraphCyclic=function(e){return void 0===e&&(e=a.a.graph),!0===t.topologicalSort(e)},this.directionalEulerian=function(e){return u(t,void 0,void 0,function(){var t,n,r;return s(this,function(o){switch(o.label){case 0:return[4,a.a.getProperty("stronglyConnectedComponents",!0)];case 1:return t=o.sent(),n=!0,r=-1,e.forEach(function(e,o){e.in!==e.out&&(n=!1),e.in>0&&(-1===r&&(r=t[o]),r!==t[o]&&(n=!1))}),[2,n]}})})},this.hasEulerianCircuit=function(e){return u(t,void 0,void 0,function(){var t,n,r;return s(this,function(o){switch(o.label){case 0:return 0!==e.filter(function(t){return t%2!=0}).length?[2,!1]:[4,a.a.getProperty("connectedComponents",!0)];case 1:return t=o.sent(),n=!0,r=-1,e.forEach(function(e,o){0!==e&&(-1===r&&(r=t[o]),r!==t[o]&&(n=!1))}),[2,n]}})})}}}();e.default=c}}]);
//# sourceMappingURL=2-d8000a36a4ea585bbbc8.min.js.map