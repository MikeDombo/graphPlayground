{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/graphState.ts","webpack:///./src/js/genericHelpers.ts","webpack:///./src/js/main.ts","webpack:///./src/js/settings.ts","webpack:///./src/js/UIInteractions.ts","webpack:///./src/js/app.ts","webpack:///./src/js/graphHelpers.ts","webpack:///./src/js/GraphAlgorithmWorker.ts","webpack:///./src/js/GraphImmut/EdgeImmut.ts","webpack:///./src/js/GraphImmut/GraphImmut.ts","webpack:///./src/js/GraphImmut/NodeImmut.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","2","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","onScriptComplete","head","document","getElementsByTagName","script","createElement","charset","timeout","nc","setAttribute","src","p","0","1","jsonpScriptSrc","event","onerror","onload","clearTimeout","chunk","errorType","type","realSrc","target","error","Error","request","undefined","setTimeout","appendChild","all","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","slice","getInt","v","parseInt","GraphState","setUpToDate","listOptions","upToDate","forEach","always","indexOf","makeAndPrintProperties","getProperty","updateIfNotUpdated","ignoreDuplicate","a","find","applyFunc","_a","sent","state","graphProperties","recalcLong","directional","settings","getOption","vertices","graph","getNumberOfNodes","edges","getNumberOfEdges","keys","__awaiter","_this","printableProperties","map","_b","_c","printGraphProperties","properties","k","_genericHelpers__WEBPACK_IMPORTED_MODULE_1__","toTitleCase","trim","htmlEncode","getElementById","innerHTML","addEdge","from","to","weight","edgeFrom","edgeTo","main","setData","nodes","clearColorFromNodes","getAllNodes","clearColorFromEdges","getAllEdges","addNode","label","x","y","editNode","id","iId","getGraphData","editEdge","newWeight","oldWeight","newGraph","_GraphImmut_GraphImmut__WEBPACK_IMPORTED_MODULE_2__","deleteEdge","deleteNode","color","nodeIDToLabel","getNode","_GraphImmut_NodeImmut__WEBPACK_IMPORTED_MODULE_3__","getLabel","toString","nodeLabelToID","filter","node","toLowerCase","getID","rID","found","getGraphAsDataSet","isWeighted","vis_index_network__WEBPACK_IMPORTED_MODULE_0__","setLocations","locations","newNodes","getAllNodesAsImmutableList","getAttribute","set","getAllEdgesAsImmutableList","isDirected","clearNodeColors","clearEdgeColors","directed","weighted","workerPool","backHistory","forwardHistory","maxHistory","ui","makeAndPrintGraphColoring","makeAndPrintEulerian","getAlgorithms","makeAndPrintIsCyclic","stronglyConnectedComponents","connectedComponents","graphColoring","eulerian","Chromatic Number","Connected Components","Strongly Connected Components","cyclic","defaultCancelCb","$modal","modal","self","deepCopy","deep","clone","copy","options","copyIsArray","isPlainObject","obj","proto","getPrototypeOf","Ctor","constructor","arguments","this","Array","isArray","deepFreeze","freeze","getOwnPropertyNames","prop","isFrozen","sort","arr","compareFunction","datasetToArray","ds","keepOnlyKeys","getFileExtension","filename","split","string","textContent","replace","printout","text","escape","flatten","rotate","max","iterable","reduce","b","Math","str","match","toUpperCase","showSimpleModal","title","body","showFormModal","initialValue","makeFormModal","successText","form","footer","f","jquery__WEBPACK_IMPORTED_MODULE_0__","class","formRow","basicMap","extraAttrs","attrname","validFunc","container","validationFunc","generalValidator","valueMutator","$v","val","valid","removeClass","next","remove","addClass","after","append","checked","for","prepend","clickDismiss","$b","onclick","on","parseFloat","$options_1","optionText","oText","oIndex","optionValues","$footer","tabindex","role","aria-hidden","data-dismiss","aria-label","html","off","last","trigger","first","successCb","cancelCb","vals","hasErrors","each","tagName","attr","files","hasClass","__webpack_exports__","main_self","graphState","visWeightEdgeEdit","callback","genericHelpers","visOptions","interaction","hover","manipulation","_d","_e","_h","$popup","concat","_f","_g","saveData","cancelEdit","confirm","network","_data","fromId","toId","operation","nodeLabelIDValidator","applyColors","graphColors","chromaticNumber","colors","randomColor_default","count","luminosity","G","recalcProps","graphChanged","rearrangeGraph","saveState","changeOption","g","GraphImmut","randomizeNetworkLayoutSeed","getPositions","disableEditMode","enableEditMode","stopLoadingAnimation","isRunning","terminateAllWebWorkers","printGraphAlgorithms","saveStateLocalStorage","getStateForSaving","getElementsByClassName","item","parentElement","classList","add","includes","undo","applyState","redo","newState","firstLoad","currentState","pop","oldKey","then","checkForLocalStorage","localStorage","setItem","JSON","stringify","shuffleNetworkLayout","round","random","layoutEngine","randomSeed","initialRandomSeed","addNetworkListeners","editEdgeMode","lastNetworkClickEvent","addEventListener","contains","deleteSelected","ctrlKey","shiftKey","Settings","removeItem","saveSettings","current","loadSettings","parse","getItem","setAll","setOptions","physics","arrows","editWithoutDrag","option","defaults","resetToDefault","asChangedDirectedWeighted","direction","weights","nodePhysics","makeAndPrintShortestPath","fn","myName","UIInteractions_UIInteractions","printAlreadyRunning","values","source","sink","iStartedProgress","startLoadingAnimation","w","getWorkerIfPossible","cleanup","pathExists","distance","cost","G_1","path","send","args","convertToGraphImmut","makeAndPrintComponents","stronglyConnected","UIInteractions_awaiter","cc","componentKey","components","UIInteractions_WorkerProxy","WorkerProxy","listener","worker","postMessage","onmessage","terminate","UIInteractions","display","makeAndPrintFFMCMF","makeAndPrintKruskal","makeAndPrintTopologicalSort","makeAndPrintDirectionalEulerian","registerListeners","makeSimpleClickListener","selector","querySelector","preventDefault","printHelp","printOptions","predefined","default","Petersen","Konigsberg","Complete","Hypercube","Custom","makeImportFileModal","makeImportTextModal","makeExportFileModal","makeExportTextModal","asDirected","asUndirected","asWeighted","asUnweighted","_i","Worker","nextIndex","findIndex","GraphAlgorithmWorker_default","prog","style","printGC","w_1","scc","graphHelpers","findVertexDegreesDirectional","getFullAdjacency","getAllOutDegrees","cb","maxFlow","flowPath","flow","capacity","totalWeight","mst","EdgeImmut","getFrom","getTo","$div","addAlgoToPane","alg","navlink","innerText","index_network","js_UIInteractions","singleton","install","Raven","loadDefault","jsonGraph","app_awaiter","adjacencyMatrix","degrees","out","in","outV","interpolateNodesFromEdges","attributes","_newTarget","getWeight","attribute","getAllAttributes","toPlain","toReturn","assign","filterExtraAttr","labels","filterNodeExtraAttr","filterEdgeExtraAttr","genericEdgesToImmutEdges","nodeMap","newEdges","immutable__WEBPACK_IMPORTED_MODULE_0__","edge","_EdgeImmut__WEBPACK_IMPORTED_MODULE_2__","genericNodesToImmutNodes","floor","_NodeImmut__WEBPACK_IMPORTED_MODULE_1__","nodeNum_1","numNodes","size","numEdges","rich","has","nodeCount","deleteAll","foundOneEdge","foundFirst","index","toArray","_","doubleEdges","addedEdges","getNodeAdjacency","adj","areAdjacent","id1","id2","getEdgesBetween","edgeList","getMinWeightEdgeBetween","minWeight","Infinity","reduceMultiGraph","reducer","min","multiEdges","uniques","Set","acc","keep","duplicateEdge","NodeImmut"],"mappings":"aACA,SAAAA,EAAAC,GAQA,IAPA,IAMAC,EAAAC,EANAC,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GAIAM,EAAA,EAAAC,KACQD,EAAAH,EAAAK,OAAoBF,IAC5BJ,EAAAC,EAAAG,GACAG,EAAAP,IACAK,EAAAG,KAAAD,EAAAP,GAAA,IAEAO,EAAAP,GAAA,EAEA,IAAAD,KAAAG,EACAO,OAAAC,UAAAC,eAAAC,KAAAV,EAAAH,KACAc,EAAAd,GAAAG,EAAAH,IAKA,IAFAe,KAAAhB,GAEAO,EAAAC,QACAD,EAAAU,OAAAV,GAOA,OAHAW,EAAAR,KAAAS,MAAAD,EAAAb,OAGAe,IAEA,SAAAA,IAEA,IADA,IAAAC,EACAf,EAAA,EAAiBA,EAAAY,EAAAV,OAA4BF,IAAA,CAG7C,IAFA,IAAAgB,EAAAJ,EAAAZ,GACAiB,GAAA,EACAC,EAAA,EAAkBA,EAAAF,EAAAd,OAA2BgB,IAAA,CAC7C,IAAAC,EAAAH,EAAAE,GACA,IAAAf,EAAAgB,KAAAF,GAAA,GAEAA,IACAL,EAAAQ,OAAApB,IAAA,GACAe,EAAAM,IAAAC,EAAAN,EAAA,KAGA,OAAAD,EAIA,IAAAQ,KAKApB,GACAqB,EAAA,GAGAZ,KAQA,SAAAS,EAAA1B,GAGA,GAAA4B,EAAA5B,GACA,OAAA4B,EAAA5B,GAAA8B,QAGA,IAAAC,EAAAH,EAAA5B,IACAK,EAAAL,EACAgC,GAAA,EACAF,YAUA,OANAhB,EAAAd,GAAAa,KAAAkB,EAAAD,QAAAC,IAAAD,QAAAJ,GAGAK,EAAAC,GAAA,EAGAD,EAAAD,QAKAJ,EAAAO,EAAA,SAAAhC,GACA,IAAAiC,KAKAC,EAAA3B,EAAAP,GACA,OAAAkC,EAGA,GAAAA,EACAD,EAAAzB,KAAA0B,EAAA,QACK,CAEL,IAAAC,EAAA,IAAAC,QAAA,SAAAC,EAAAC,GACAJ,EAAA3B,EAAAP,IAAAqC,EAAAC,KAEAL,EAAAzB,KAAA0B,EAAA,GAAAC,GAGA,IAEAI,EAFAC,EAAAC,SAAAC,qBAAA,WACAC,EAAAF,SAAAG,cAAA,UAGAD,EAAAE,QAAA,QACAF,EAAAG,QAAA,IACArB,EAAAsB,IACAJ,EAAAK,aAAA,QAAAvB,EAAAsB,IAEAJ,EAAAM,IA3DA,SAAAjD,GACA,OAAAyB,EAAAyB,EAAA,OAA0ClD,OAAA,KAA6BmD,EAAA,uBAAAC,EAAA,wBAAsDpD,GAAA,UA0D7HqD,CAAArD,GAEAuC,EAAA,SAAAe,GAEAX,EAAAY,QAAAZ,EAAAa,OAAA,KACAC,aAAAX,GACA,IAAAY,EAAAnD,EAAAP,GACA,OAAA0D,EAAA,CACA,GAAAA,EAAA,CACA,IAAAC,EAAAL,IAAA,SAAAA,EAAAM,KAAA,UAAAN,EAAAM,MACAC,EAAAP,KAAAQ,QAAAR,EAAAQ,OAAAb,IACAc,EAAA,IAAAC,MAAA,iBAAAhE,EAAA,cAAA2D,EAAA,KAAAE,EAAA,KACAE,EAAAH,KAAAD,EACAI,EAAAE,QAAAJ,EACAH,EAAA,GAAAK,GAEAxD,EAAAP,QAAAkE,IAGA,IAAApB,EAAAqB,WAAA,WACA5B,GAAwBqB,KAAA,UAAAE,OAAAnB,KAClB,MACNA,EAAAY,QAAAZ,EAAAa,OAAAjB,EACAC,EAAA4B,YAAAzB,GAGA,OAAAP,QAAAiC,IAAApC,IAIAR,EAAA6C,EAAAzD,EAGAY,EAAA8C,EAAA5C,EAGAF,EAAA+C,EAAA,SAAA3C,EAAA4C,EAAAC,GACAjD,EAAAkD,EAAA9C,EAAA4C,IACAhE,OAAAmE,eAAA/C,EAAA4C,GAA0CI,YAAA,EAAAC,IAAAJ,KAK1CjD,EAAAsD,EAAA,SAAAlD,GACA,oBAAAmD,eAAAC,aACAxE,OAAAmE,eAAA/C,EAAAmD,OAAAC,aAAwDC,MAAA,WAExDzE,OAAAmE,eAAA/C,EAAA,cAAiDqD,OAAA,KAQjDzD,EAAA0D,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAzD,EAAAyD,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAA7E,OAAA8E,OAAA,MAGA,GAFA9D,EAAAsD,EAAAO,GACA7E,OAAAmE,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAzD,EAAA+C,EAAAc,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIA7D,EAAAiE,EAAA,SAAA5D,GACA,IAAA4C,EAAA5C,KAAAuD,WACA,WAA2B,OAAAvD,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAL,EAAA+C,EAAAE,EAAA,IAAAA,GACAA,GAIAjD,EAAAkD,EAAA,SAAAgB,EAAAC,GAAsD,OAAAnF,OAAAC,UAAAC,eAAAC,KAAA+E,EAAAC,IAGtDnE,EAAAyB,EAAA,GAGAzB,EAAAoE,GAAA,SAAAC,GAA8D,MAApBC,QAAAhC,MAAA+B,GAAoBA,GAE9D,IAAAE,EAAAC,OAAA,aAAAA,OAAA,iBACAC,EAAAF,EAAAxF,KAAAiF,KAAAO,GACAA,EAAAxF,KAAAX,EACAmG,IAAAG,QACA,QAAA/F,EAAA,EAAgBA,EAAA4F,EAAA1F,OAAuBF,IAAAP,EAAAmG,EAAA5F,IACvC,IAAAU,EAAAoF,EAIAlF,EAAAR,MAAA,QAEAU,k3CCpKMkF,EAAS,SAACC,GACZ,MAAgB,iBAANA,EACCA,EAEJC,SAASD,IAGpBE,EAAA,oBAAAA,KAyTA,OAhPWA,EAAAC,YAAP,SAAmBtB,EAAeuB,QAAf,IAAAvB,OAAA,GACf,IAAMb,EAAsB,OAAhBoC,QAA+C,IAAhBA,EACvCb,GAAW,EACfW,EAAWG,SAASC,QAAQ,SAACN,GAClB,WAAYA,GAAOA,EAAEO,UAAYvC,GAAOoC,EAAYI,QAAQR,EAAE5B,OAAS,KAC1E4B,EAAEK,SAAWxB,EACE,aAAXmB,EAAEzC,OACFgC,GAAW,MAInBA,GACAW,EAAWO,0BAINP,EAAAQ,YAAb,SAAyBnB,EAAkBoB,EAA4BC,eAA5B,IAAAD,OAAA,QAA4B,IAAAC,OAAA,iGAC7DC,EAAIX,EAAWG,SAASS,KAAK,SAACd,GAChC,MAAQ,SAAUA,GAAKA,EAAE5B,OAASmB,KAE/Bc,UAAH,KACI,cAAeQ,GAAKF,GACpB,EAAME,EAAEE,UAAUH,KADlB,mBACAI,EAAAC,oBAGA,SAAO,aAGf,MAAe,UAAXJ,EAAEtD,MACF,EAAOxB,QAAQC,QAAQkE,EAAWgB,MAAM3B,MAE5C,EAAOxD,QAAQC,QAAQkE,EAAWiB,gBAAgB5B,WAGzCW,EAAAO,uBAAb,SAAoCW,eAAA,IAAAA,OAAA,4GAC1BC,EAAczB,OAAO0B,SAASC,UAAU,aAE9CrB,EAAWiB,gBAAgBK,SAAWtB,EAAWuB,MAAMC,mBACvDxB,EAAWiB,gBAAgBQ,MAAQzB,EAAWuB,MAAMG,mBAE/CP,GAAD,MACA,EAAMnB,EAAWQ,YAAY,YAAY,GAAM,WAA/CM,EAAAC,wBAWJ,OARMpE,EAAIzC,OAAOyH,KAAK3B,EAAWiB,iBAC7BC,GACAvE,EAAEyD,QAAQ,SAAON,GAAC,OAAA8B,EAAAC,OAAA,qEACd,SAAM7B,EAAWQ,YAAYV,GAAG,kBAAhCgB,EAAAC,kBAIFe,MACN,EAAMjG,QAAQiC,IAAInB,EAAEoF,IAAI,SAAOjC,GAAC,OAAA8B,EAAAC,OAAA,6EACH,OAAzBf,EAAAgB,EAAoBE,EAAAlC,GAAK,EAAME,EAAWQ,YAAYV,kBAAtDgB,EAAAkB,GAAyBC,EAAAlB,kCAD7BD,EAAAC,OAIAf,EAAWkC,qBAAqBJ,aAG7B9B,EAAAkC,qBAAP,SAA4BC,GACxB,IAAIxF,EAAI,GACRzC,OAAOyH,KAAKQ,GAAY/B,QAAQ,SAACgC,GACP,OAAlBD,EAAWC,KACXzF,GAAQ0F,EAAA,EAAKC,YAAYF,GAAE,KAAKD,EAAWC,GAAE,QAGrDzF,EAAIA,EAAE4F,OACN5F,EAAI0F,EAAA,EAAKG,WAAW7F,GACpBT,SAASuG,eAAe,cAAcC,UAAY,uBAAuB/F,EAAC,QAGvEqD,EAAA2C,QAAP,SAAeC,EAAqBC,EAAmBC,EAAYvB,QAAZ,IAAAuB,MAAA,QAAY,IAAAvB,MAAQvB,EAAWuB,OAClF,IAAMwB,EAAWlD,EAAO+C,GAClBI,EAASnD,EAAOgD,GACtBtB,EAAQA,EAAMoB,QAAQI,EAAUC,EAAQF,GACxCpD,OAAOuD,KAAKC,SACRC,MAAOnD,EAAWoD,oBAAoB7B,EAAM8B,eAC5C5B,MAAOzB,EAAWsD,oBAAoB/B,EAAMgC,kBAI7CvD,EAAAwD,QAAP,SAAejK,EAAgBgI,QAAA,IAAAA,MAAQvB,EAAWuB,OAC9CA,EAAQA,EAAMiC,SAASC,MAAOlK,EAAKkK,MAAOC,EAAGnK,EAAKmK,EAAGC,EAAGpK,EAAKoK,IAC7DjE,OAAOuD,KAAKC,SACRC,MAAOnD,EAAWoD,oBAAoB7B,EAAM8B,eAC5C5B,MAAOzB,EAAWsD,oBAAoB/B,EAAMgC,kBAI7CvD,EAAA4D,SAAP,SAAgBC,EAAmBJ,EAAelC,QAAA,IAAAA,MAAQvB,EAAWuB,OACjE,IAAMuC,EAAMjE,EAAOgE,GACnBtC,EAAQA,EAAMqC,SAASE,GAAML,MAAKA,IAClC/D,OAAOuD,KAAKC,QAAQlD,EAAW+D,aAAaxC,IAAQ,GAAO,IAGxDvB,EAAAgE,SAAP,SAAgBpB,EAAuBC,EACvBoB,EAAmBC,EAAmB3C,QAAA,IAAAA,MAAQvB,EAAWuB,OACrE,IAAMwB,EAAWlD,EAAO+C,GAClBI,EAASnD,EAAOgD,GAChBsB,EAAW5C,EAAMyC,SAASjB,EAAUC,EAAQiB,EAAWC,GACzDC,aAAoBC,EAAA,GACpB1E,OAAOuD,KAAKC,QAAQlD,EAAW+D,aAAaI,IAAW,GAAO,IAI/DnE,EAAAqE,WAAP,SAAkBzB,EAAqBC,EAAmBC,EAAuBvB,QAAvB,IAAAuB,MAAA,WAAuB,IAAAvB,MAAQvB,EAAWuB,OAChG,IAAMwB,EAAWlD,EAAO+C,GAClBI,EAASnD,EAAOgD,GACtBtB,EAAQA,EAAM8C,WAAWtB,EAAUC,EAAQF,GAAQ,GACnDpD,OAAOuD,KAAKC,SACRC,MAAOnD,EAAWoD,oBAAoB7B,EAAM8B,eAC5C5B,MAAOzB,EAAWsD,oBAAoB/B,EAAMgC,kBAI7CvD,EAAAsE,WAAP,SAAkBT,EAAmBtC,QAAA,IAAAA,MAAQvB,EAAWuB,OACpD,IAAMuC,EAAMjE,EAAOgE,GACbM,EAAW5C,EAAM+C,WAAWR,GAC9BK,aAAoBC,EAAA,GACpB1E,OAAOuD,KAAKC,SACRC,MAAOnD,EAAWoD,oBAAoBe,EAASd,eAC/C5B,MAAOzB,EAAWsD,oBAAoB/B,EAAMgC,kBAKjDvD,EAAAoD,oBAAP,SAA2BD,GAIvB,OAHAA,EAAM/C,QAAQ,SAACN,GACXA,EAAEyE,MAAQ,OAEPpB,GAGJnD,EAAAsD,oBAAP,SAA2B7B,GAIvB,OAHAA,EAAMrB,QAAQ,SAACN,UACJA,EAAEyE,QAEN9C,GAGJzB,EAAAwE,cAAP,SAAqBX,EAAYtC,QAAA,IAAAA,MAAQvB,EAAWuB,OAChD,IAAMpC,EAAIoC,EAAMkD,QAAQZ,GAAI,GAC5B,OAAU,IAAN1E,GAAqB,OAANA,GAAcA,aAAauF,EAAA,GAAavF,EAAEwF,WAAWpC,OAAOxI,OAAS,EAC7EoF,EAAEwF,WAAWpC,OAGjBsB,EAAGe,YAIP5E,EAAA6E,cAAP,SAAqBpB,EAAelC,QAAA,IAAAA,MAAQvB,EAAWuB,OACnD,IAAIpC,EAAIoC,EAAM8B,aAAY,GAK1B,GAAiB,KAJjBlE,EAAIA,EAAE2F,OAAO,SAACC,GACV,OAAOA,EAAKJ,WAAWK,gBAAkBvB,EAAMuB,eAAiBD,EAAKE,QAAQL,aAAenB,KAG1F1J,OACF,OAAQ,EAEP,GAAiB,IAAboF,EAAEpF,OACP,OAAOoF,EAAE,GAAG8F,QAGhB,IAAIC,GAAO,EACPC,GAAQ,EASZ,OAPAhG,EAAEiB,QAAQ,SAAC2E,GACFI,GAASJ,EAAKE,QAAQL,aAAenB,IACtCyB,EAAMH,EAAKE,QACXE,GAAQ,KAIZA,EACOD,GAGX/F,EAAEiB,QAAQ,SAAC2E,GACFI,GAASJ,EAAKJ,aAAelB,IAC9ByB,EAAMH,EAAKE,QACXE,GAAQ,KAIZA,EACOD,GAGX/F,EAAEiB,QAAQ,SAAC2E,GACFI,GAASJ,EAAKJ,WAAWK,gBAAkBvB,EAAMuB,gBAClDE,EAAMH,EAAKE,QACXE,GAAQ,KAITD,KAIJlF,EAAAoF,kBAAP,SAAyB7D,GACrB,IAAMtD,EAAI+B,EAAW+D,aAAaxC,GAYlC,OAXIA,EAAM8D,cACNpH,EAAEwD,MAAMrB,QAAQ,SAAC3E,GACbA,EAAEgI,MAAQhI,EAAEqH,OAAO8B,aAG3B3G,EAAEwD,MAAMrB,QAAQ,SAAC3E,GACV,UAAWA,IACVA,EAAE8I,OAASA,MAAO9I,EAAE8I,WAIpBpB,MAAO,IAAImC,EAAA,QAAQrH,EAAEkF,OAAsB1B,MAAO,IAAI6D,EAAA,QAAQrH,EAAEwD,SAGrEzB,EAAAuF,aAAP,SAAoBC,EAAoDjE,QAAA,IAAAA,MAAQvB,EAAWuB,OACvF,IAAIkE,EAAWlE,EAAMmE,6BAWrB,OAVAxL,OAAOyH,KAAK6D,GAAWpF,QAAQ,SAACvG,GAC5B,IAAMiG,EAAI0F,EAAU3L,GACdkL,EAAOU,EAASlH,IAAIwB,SAASlG,IAE/BkL,EAAKY,aAAa,OAAS7F,EAAE4D,GAAKqB,EAAKY,aAAa,OAAS7F,EAAE6D,IAE/D8B,EAAWA,EAASG,IAAI7F,SAASlG,GAAIkL,EAAKnB,SAASmB,EAAKJ,YAAajB,EAAG5D,EAAE4D,EAAGC,EAAG7D,EAAE6D,QAInF,IAAIS,EAAA,EAAWqB,EAAUlE,EAAMsE,6BAA8BtE,EAAMuE,aAAcvE,EAAM8D,eAG3FrF,EAAA+D,aAAP,SAAoBxC,EAA0BwE,EAAyBC,QAAnD,IAAAzE,MAAQvB,EAAWuB,YAAO,IAAAwE,OAAA,QAAyB,IAAAC,OAAA,GACnE,IAAM7C,EAAQ5B,EAAM8B,cACd5B,EAAQF,EAAMgC,cACpB,OACIJ,MAAO4C,EAAkB/F,EAAWoD,oBAAoBD,GAASA,EACjE1B,MAAOuE,EAAkBhG,EAAWsD,oBAAoB7B,GAASA,EACjEwE,SAAU1E,EAAMuE,aAChBI,SAAU3E,EAAM8D,eArTVrF,EAAAmG,cACAnG,EAAAoG,eACApG,EAAAqG,kBACArG,EAAAsG,WAAa,GACbtG,EAAAG,WAENjC,KAAM,mBAAoBiC,UAAU,EAAO9C,KAAM,WACjDwD,UAAW,WACP,OAAOnB,OAAO6G,GAAGC,+BAIrBtI,KAAM,gBAAiBiC,UAAU,EAAO9C,KAAM,QAC9CwD,UAAW,WACP,OAAOnB,OAAO6G,GAAGC,+BAGxBtI,KAAM,WAAYiC,UAAU,EAAME,QAAQ,EAAMhD,KAAM,aACtDa,KAAM,QAASiC,UAAU,EAAME,QAAQ,EAAMhD,KAAM,aAEhDa,KAAM,WAAYiC,UAAU,EAAO9C,KAAM,WACzCwD,UAAW,SAAChH,GACR,OAAO6F,OAAO6G,GAAGE,qBAAqB5M,MAI1CqE,KAAM,uBAAwBiC,UAAU,EAAO9C,KAAM,WACrDwD,UAAW,WACPnB,OAAO6G,GAAGG,gBAAgB9F,KAAK,SAACd,GAAM,MAAW,yBAAXA,EAAE5B,OAAiC2C,eAI7E3C,KAAM,sBAAuBiC,UAAU,EAAO9C,KAAM,QACpDwD,UAAW,WACPnB,OAAO6G,GAAGG,gBAAgB9F,KAAK,SAACd,GAAM,MAAW,yBAAXA,EAAE5B,OAAiC2C,eAI7E3C,KAAM,gCAAiCiC,UAAU,EAAO9C,KAAM,WAC9DwD,UAAW,WACPnB,OAAO6G,GAAGG,gBAAgB9F,KAAK,SAACd,GAAM,MAAW,kCAAXA,EAAE5B,OAA0C2C,eAItF3C,KAAM,8BAA+BiC,UAAU,EAAO9C,KAAM,QAC5DwD,UAAW,WACPnB,OAAO6G,GAAGG,gBAAgB9F,KAAK,SAACd,GAAM,MAAW,kCAAXA,EAAE5B,OAA0C2C,eAItF3C,KAAM,SAAUiC,UAAU,EAAO9C,KAAM,WACvCwD,UAAW,WACP,OAAOnB,OAAO6G,GAAGI,0BAIf3G,EAAAgB,OACV4F,4BAA6B,KAC7BC,oBAAqB,KACrBC,cAAe,MAEL9G,EAAAuB,MAAoB,KACpBvB,EAAAiB,iBACVK,SAAU,EACVG,MAAO,EACPsF,UAAU,EACVC,mBAAoB,KACpBC,uBAAwB,KACxBC,gCAAiC,KACjCC,QAAQ,GAmPhBnH,EAzTA,oDC5DA6B,OAAAlE,EA2BMyJ,EAAkB,SAACC,GACrBA,EAAOC,MAAM,SAGXC,GACFC,SAAQ,SAACC,EAAeC,EAAYC,GAChC,IAiBIC,EAAS1J,EAAMxB,EAAKmL,EAjBlBC,EAAgB,SAACC,GACnB,IAAKA,GAAiC,uBAAvBnD,SAASvK,KAAK0N,GACzB,OAAO,EAGX,IAAIC,EAAQ9N,OAAO+N,eAAeF,GAElC,IAAKC,EACD,OAAO,EAIX,IAAIE,KAAY9N,eAAeC,KAAK2N,EAAO,gBAAkBA,EAAMG,YACnE,MAAuB,mBAATD,MAA4B9N,eAAewK,SAASvK,KAAK6N,QAAe9N,eAAewK,SAASvK,KAAKH,SAKnHqD,EAAS6K,UAAU,OACnBvO,EAAI,EACJE,EAASqO,UAAUrO,OAqBvB,IAlBsB,kBAAXwD,IACPkK,EAAOlK,EAGPA,EAAS6K,UAAUvO,OACnBA,KAIkB,iBAAX0D,GAAyC,mBAAXA,IACrCA,MAGA1D,IAAME,IACNwD,EAAS8K,KACTxO,KAGGA,EAAIE,EAAQF,IAGf,GAAgC,OAA3B+N,EAAUQ,UAAUvO,IAGrB,IAAKqE,KAAQ0J,EACTlL,EAAMa,EAAOW,GAITX,KAHJoK,EAAOC,EAAQ1J,MAQXuJ,GAAQE,IAASG,EAAcH,KAC9BE,EAAcS,MAAMC,QAAQZ,MAEzBE,GACAA,GAAc,EACdH,EAAQhL,GAAO4L,MAAMC,QAAQ7L,GAAOA,MAGpCgL,EAAQhL,GAAOoL,EAAcpL,GAAOA,KAIxCa,EAAOW,GAAQqJ,EAAKC,SAASC,EAAMC,EAAOC,SAG1BhK,IAATgK,IACPpK,EAAOW,GAAQyJ,IAO/B,OAAOpK,GAGXiL,WAAY,SAAIpK,GAWZ,OAVAlE,OAAOuO,OAAOrK,GAEdlE,OAAOwO,oBAAoBtK,GAAGgC,QAAQ,SAACuI,IAC/BvK,EAAEhE,eAAeuO,IAA8B,OAApBvK,EAAUuK,IACL,iBAApBvK,EAAUuK,IAAkD,mBAApBvK,EAAUuK,IAC1DzO,OAAO0O,SAAUxK,EAAUuK,KAC/BpB,EAAKiB,WAAYpK,EAAUuK,MAI5BvK,GAGXyK,KAAM,SAAIC,EAAUC,GAChB,OAAWD,EAAGlJ,QAAEiJ,KAAKE,IAGzBC,eAAgB,SAACC,EAAShK,GACtB,IAAMT,KAIN,OAHAyK,EAAG7I,QAAQ,SAACN,GACRtB,EAAEvE,KAAK6F,EAAEb,MAENsI,EAAKiB,WAAWhK,IAG3B0K,aAAc,SAAIJ,EAAUnH,GAUxB,OATAmH,EAAMA,EAAIlJ,SACNQ,QAAQ,SAACN,GACC5F,OAAOyH,KAAK7B,GACpBM,QAAQ,SAACnB,GACH0C,EAAKrB,QAAQrB,GAAO,UACba,EAAEb,OAIdsI,EAAKiB,WAAWM,IAG3BK,iBAAkB,SAACC,GACf,OAAOA,EAASC,MAAM,KAAKpO,QAAQ,GAAG,IAG1CuH,WAAY,SAAC8G,GACT,IAAM1K,EAAI1C,SAASG,cAAc,YAGjC,OAFAuC,EAAE2K,YAAcD,EAChBA,EAAS1K,EAAE8D,UAAU8G,QAAQ,kBAAmB,UAIpDC,SAAU,SAACC,EAAcC,GACjBA,IACAD,EAAO7H,EAAKW,WAAWmH,IAE3BzN,SAASuG,eAAe,YAAYC,UAAYgH,GAGpDE,QAAS,SAAI7H,GACT,IAAMvD,KAIN,OAHAtE,OAAOyH,KAAKI,GAAK3B,QAAQ,SAACvG,GACtB2E,EAAEvE,KAAK8H,EAAIlI,MAER0N,EAAKiB,WAAWhK,IAG3BqL,OAAQ,SAAC9H,GACL,IAAMvD,KASN,OARAtE,OAAOyH,KAAKI,GAAK3B,QAAQ,SAACvG,GAClBkI,EAAIlI,KAAM2E,EACVA,EAAEuD,EAAIlI,IAAII,KAAKJ,GAGf2E,EAAEuD,EAAIlI,KAAOA,KAGd0N,EAAKiB,WAAWhK,IAG3BsL,IAAK,SAACC,GACF,OAAOA,EAASC,OAAO,SAACrJ,EAAGsJ,GACvB,OAAOC,KAAKJ,IAAInJ,EAAGsJ,MAI3B3H,YAAa,SAAC6H,GACV,OAAOA,EAAIX,QAAQ,cAAe,SAACY,GAC/B,OAAOA,EAAMC,iBAIrBC,gBAAiB,SAACC,EAAeC,GAC7BjD,EAAKkD,cAAc,KAAMF,EAAO,OAAQlN,KAAM,OAAQqN,aAAcF,IAAQ,MAAM,IAGtFG,cAAe,SAACJ,EAAeK,EAAqBC,EAAsBC,QAAA,IAAAA,OAAA,GACtE,IAAMC,EAAIC,EAAE,SAAUC,MAAO,0BAC7BJ,EAAKzK,QAAQ,SAAC8K,EAASrR,GACb,iBAAkBqR,IACpBA,EAAQR,aAAe,IAG3B,IAAI7G,EAAK,cAAgBhK,EACrB,OAAQqR,GAA0B,KAAfA,EAAQrH,IAA4B,OAAfqH,EAAQrH,IAAqC,iBAAfqH,EAAQrH,KAC9EA,EAAKqH,EAAQrH,IAGjB,IAAMsH,GAA0BF,MAAO,eAAgBpH,GAAEA,EAAElF,MAAOuM,EAAQR,cAEtE,eAAgBQ,GAChBhR,OAAOyH,KAAKuJ,EAAQE,YAAYhL,QAAQ,SAACiL,GACO,mBAAjCH,EAAQE,WAAWC,KAC1BF,EAASE,GAAYH,EAAQE,WAAWC,MAKpD,IAAIC,EAAY,SAAC3M,EAAa4M,GAAyC,UACnE,mBAAoBL,IACpBI,EAAYJ,EAAQM,gBAGxB,IAAMC,EAAmB,SAAC1O,EAAY2O,QAAA,IAAAA,MAAA,MAClC,IAAMC,EAAKX,EAAEjO,EAAMQ,QACfqO,EAAMD,EAAGC,MACQ,OAAjBF,GAAiD,mBAAjBA,IAChCE,EAAMF,EAAaE,IAEvB,IAAMC,EAAQP,EAAUM,EAAKD,IAEf,IAAVE,EACAF,EAAGG,YAAY,cAAcC,KAAK,aAAelS,GAAGmS,UAGpDL,EAAGM,SAAS,cAC6B,IAArCN,EAAGI,KAAK,aAAelS,GAAGE,QAC1B4R,EAAGO,MAAMlB,EAAE,SAAUC,MAAO,mBAAoBpH,GAAI,YAAchK,IAAI6P,KAAKmC,MAKvF,GAAqB,SAAjBX,EAAQ7N,KACR0N,EAAEoB,OAAOnB,EAAEE,EAAQR,oBAElB,GAAqB,aAAjBQ,EAAQ7N,KACb8N,EAAS9N,KAAO,WAChB8N,EAASF,MAAQ,0BACVE,EAASxM,MACZuM,EAAQR,eACRS,EAASiB,QAAU,IAGvBrB,EAAEoB,OAAOnB,EAAE,SAAUC,MAAO,eACvBkB,OAAOnB,EAAE,WAAYqB,IAAKxI,EAAIoH,MAAO,qBACjCvB,KAAKwB,EAAQzH,OAAO6I,QAAQtB,EAAE,UAAWG,WAOlD,GAFAJ,EAAEoB,OAAOnB,EAAE,WAAYqB,IAAKxI,EAAIoH,MAAO,mBAAmBvB,KAAKwB,EAAQzH,QAElD,WAAjByH,EAAQ7N,KAAmB,CACvB,iBAAkB6N,IAAoC,IAAzBA,EAAQqB,eACrCpB,EAASF,OAAS,gBAEtB,IAAMuB,EAAKxB,EAAE,WAAYG,GAAUzB,KAAKwB,EAAQR,cAC5C,YAAaQ,GAAsC,mBAApBA,EAAQuB,SACvCD,EAAGE,GAAG,QAASxB,EAAQuB,SAE3B1B,EAAEoB,OAAOK,QAER,GAAqB,YAAjBtB,EAAQ7N,KACb8N,EAAS9N,KAAO,SAChB0N,EAAEoB,OAAOnB,EAAE,UAAWG,GAAUuB,GAAG,gBAAiB,SAACjR,GACjDgQ,EAAiBhQ,EAAGkR,oBAGvB,GAAqB,SAAjBzB,EAAQ7N,KACb8N,EAAS9N,KAAO,OAChB0N,EAAEoB,OAAOnB,EAAE,UAAWG,GAAUuB,GAAG,gBAAiBjB,SAEnD,GAAqB,SAAjBP,EAAQ7N,KACb8N,EAAS9N,KAAO,OAChB8N,EAASF,MAAQ,iCACjBF,EAAEoB,OAAOnB,EAAE,UAAWG,GAAUuB,GAAG,gBAAiBjB,SAEnD,GAAqB,aAAjBP,EAAQ7N,KAAqB,CAC5BmP,EAAKxB,EAAE,aAAcG,GAAUuB,GAAG,gBAAiBjB,GACrD,YAAaP,GACbsB,EAAGE,GAAG,QAASxB,EAAQuB,SAE3B1B,EAAEoB,OAAOK,QAER,GAAqB,WAAjBtB,EAAQ7N,KAAmB,CAChC,IAAMuP,EAAW5B,EAAE,WAAYG,GAC/BD,EAAQ2B,WAAWzM,QAAQ,SAAC0M,EAAOC,GAC3BA,EAAS7B,EAAQ8B,aAAajT,OAC9B6S,EAAST,OAAOnB,EAAE,YAAarM,MAAOuM,EAAQ8B,aAAaD,KAAUrD,KAAKoD,IAG1EF,EAAST,OAAOnB,EAAE,YAAYtB,KAAKoD,MAG3C/B,EAAEoB,OAAOS,EAASF,GAAG,gBAAiBjB,OAKlD,IAAIwB,EAAUjC,EAAE,SAAUC,MAAO,iBAC5BkB,OAAOnB,EAAE,YAAaC,MAAO,kBAAmB5N,KAAM,WAAWqM,KAAKkB,IACtEuB,OAAOnB,EAAE,YAAaC,MAAO,4BAA6B5N,KAAM,WAAWqM,KAAK,YAEtE,IAAXoB,IACAmC,EAAU,MAGd,IAAM5F,EAAU2D,EAAE,SAAUC,MAAO,aAAciC,SAAU,KAAMC,KAAM,SAAUC,cAAe,SAuBhG,OAtBA/F,EACK8E,OAAOnB,EAAE,SAAUC,MAAO,iBACtBkB,OAAOnB,EAAE,SAAUC,MAAO,kBACtBkB,OAAOnB,EAAE,SAAUC,MAAO,iBACtBkB,OAAOnB,EAAE,QAASC,MAAO,gBAAgBvB,KAAKa,IAC9C4B,OAAOnB,EAAE,YAAaC,MAAO,QAASoC,eAAgB,QAASC,aAAc,UACzEnB,OAAOnB,EAAE,UAAWoC,cAAe,SAASG,KAAK,cAGzDpB,OAAOpB,GACPoB,OAAOc,KAGpB5F,EAAOzG,KAAK,mBAAmB4M,IAAI,SAASd,GAAG,QAAS,SAACjR,GACvC,UAAVA,EAAEwD,KACF+L,EAAE,gBAAgByC,OAAOC,QAAQ,WAGzCrG,EAAOqF,GAAG,iBAAkB,WACxBrF,EAAOzG,KAAK,sDAAsD+M,QAAQD,QAAQ,WAG/ErG,GAGXoD,cAAe,SAACmD,EACArD,EAAeK,EAAqBC,EACpCgD,EAAsD/C,QAAtD,IAAA+C,MAAAzG,QAAsD,IAAA0D,OAAA,GAClE,IAAMzD,EAASE,EAAKoD,cAAcJ,EAAOK,EAAaC,EAAMC,GAE5DzD,EAAOqF,GAAG,QAAS,cAAe,WACN,mBAAbmB,EACPA,EAASxG,GAGTA,EAAOC,MAAM,UAElBoF,GAAG,QAAS,eAAgB,WAC3BrF,EAAOC,MAAM,UACdoF,GAAG,QAAS,eAAgB,WAC3B,IAAMoB,KACFC,GAAY,EAEhB1G,EAAOzG,KAAK,2BAA2BoN,KAAK,SAACnU,EAAGiG,GAC5C,IAAM6L,EAAKX,EAAElL,GAEe,WAAvB6L,EAAWsC,QACZH,EAAK7T,KAAK0R,EAAG/K,KAAK,aAAagL,OAEN,aAApBD,EAAGuC,KAAK,QACbJ,EAAK7T,KAAK0R,EAAGhD,KAAK,YAEO,SAApBgD,EAAGuC,KAAK,QACbJ,EAAK7T,KAAM0R,EAAGpN,IAAI,GAAW4P,OAEJ,WAApBxC,EAAGuC,KAAK,QACbJ,EAAK7T,KAAK0S,WAAWhB,EAAGC,QAGxBkC,EAAK7T,KAAK0R,EAAGC,OAGbD,EAAG+B,QAAQ,YAAYU,SAAS,gBAChCL,GAAY,KAKfA,GAAkC,mBAAdH,GACrBA,EAAUvG,EAAQyG,KAEvBpB,GAAG,kBAAmB,WACrBrF,EAAO2E,WACR1E,MAAM,UAIjB+G,EAAA,y5CCxVMC,GACFC,WAAYA,EAAA,EACZhD,UAAWrP,SAASuG,eAAe,WAEnC+L,kBAAmB,SAACjV,EAA2BkV,GAC3CC,EAAA,EAAKjE,cAAc,SAACpD,EAAQyG,GACxBW,EAAS,MACTpH,EAAOC,MAAM,QACb,IAAM3I,EAAQgO,WAAWmB,EAAK,IAC9BS,EAAA,EAAWvK,SAASzK,EAAKqJ,KAAKiB,GAAItK,EAAKsJ,GAAGgB,GAAIlF,EAAOgO,WAAWpT,EAAKkK,SACtE,YAAa,SAERpG,KAAM,UACNoG,MAAO,kBACPiH,aAAciC,WAAWpT,EAAKkK,WAI1CkL,YACIC,aAAcC,OAAO,GACrBC,cACItL,QAAS,SAAOjK,EAAMkV,GAAQ,OAAA7M,OAtF1CjE,OAsF0C,yFAIW,OAHtBqE,GAAAlB,EAAA4N,EAAA,GAAK/D,iBAAc,WAAY,WAEtCtN,KAAM,0BACuB,EAAMkR,EAAA,EAAW/N,YAAY,oBAEjB,WAFzCuO,EAAArE,aAAcsE,EAAeC,EAAAlO,OAAwC,cAExE1D,KAAM,OAAQoG,MAAO,UAAuB,EAAM8K,EAAA,EAAW/N,YAAY,2BALxE0O,EAASlN,EAAAtH,MAAAoG,EAAAmB,EAAAkN,QAAAC,EAAAD,SAKoBE,EAAA3E,aAAcuE,EAAAlO,OAAwCsO,SAGlF3C,GAAG,QAAS,eAAgB,WAC/BwC,EAAO5H,MAAM,QACbgH,EAAKgB,SAAS/V,EAAMkV,EAAU,MAAOS,EAAOtO,KAAK,SAAS+M,QAAQ/B,SACnEc,GAAG,QAAS,cAAe,WAC1BwC,EAAO5H,MAAM,QACbgH,EAAKiB,WAAWd,KACjB/B,GAAG,kBAAmB,WACrBwC,EAAOlD,SACPsC,EAAKiB,WAAWd,KACjBnH,MAAM,kBAEb1D,SAAU,SAACrK,EAAMkV,GACb,IAAMS,EAASR,EAAA,EAAK/D,cAAc,YAAa,SAEvCtN,KAAM,OACNqN,aAAc,eAAenR,EAAKsK,GAAE,SAEvCxG,KAAM,OAAQoG,MAAO,QAASiH,aAAcnR,EAAKkK,SAGtDyL,EAAOxC,GAAG,QAAS,eAAgB,WAC/BwC,EAAO5H,MAAM,QACbgH,EAAKgB,SAAS/V,EAAMkV,EAAU,WAAYS,EAAOtO,KAAK,SAAS+M,QAAQ/B,SACxEc,GAAG,QAAS,cAAe,WAC1BwC,EAAO5H,MAAM,QACbgH,EAAKiB,WAAWd,KACjB/B,GAAG,kBAAmB,WACrBwC,EAAOlD,SACPsC,EAAKiB,WAAWd,KACjBnH,MAAM,SAEb3E,QAAS,SAACpJ,EAAMkV,GACZ,IAAM/T,EAAQ,WACc,mBAAb+T,GACPA,EAAS,MAEbF,EAAA,EAAW5L,QAAQpJ,EAAKqJ,KAAMrJ,EAAKsJ,KAEnCtJ,EAAKqJ,OAASrJ,EAAKsJ,GAOvBnI,IANQ8U,QAAQ,+CACR9U,KAOZsJ,SAAU,SAACzK,EAAMkV,GACbA,EAAS,MACTH,EAAKK,WAAWG,aAAazK,YAAY5C,OAAQlI,EAAKsK,MACtDyK,EAAKK,WAAWG,aAAanM,QAAQpJ,IAEzC8K,WAAY,SAAC9K,EAAMkV,GACS,mBAAbA,GACPA,EAAS,MAEblV,EAAKkI,MAAMrB,QAAQ,SAACN,GAChB,IAAIgD,EAAS,UACyD,IAA1DpD,OAAO+P,QAAgBjF,KAAKjR,KAAKkI,MAAMiO,MAAM5P,GAAG2D,QACxDX,EAAS6J,WAAYjN,OAAO+P,QAAgBjF,KAAKjR,KAAKkI,MAAMiO,MAAM5P,GAAG2D,QAGzE8K,EAAA,EAAWlK,WAAY3E,OAAO+P,QAAgBjF,KAAK/I,MAAM3B,GAAG6P,OACvDjQ,OAAO+P,QAAgBjF,KAAK/I,MAAM3B,GAAG8P,KAAM9M,MAGxDwB,WAAY,SAAC/K,EAAMkV,GACfA,EAAS,MACTlV,EAAK4J,MAAM/C,QAAQ,SAACN,GAChByO,EAAA,EAAWjK,WAAWxE,QAMtCyP,WAAY,SAACd,GACe,mBAAbA,GACPA,EAAS,OAIjBa,SAAU,SAAC/V,EAAMkV,EAAUoB,EAAWpM,GAClCgL,EAAS,MAETlV,EAAKkK,MAAQA,EACK,QAAdoM,EACAtB,EAAA,EAAW/K,QAAQjK,GAEA,aAAdsW,GACLtB,EAAA,EAAW3K,SAASrK,EAAKsK,GAAItK,EAAKkK,QAI1CqM,qBAAsB,SAAChQ,GACnB,OAAIyO,EAAA,EAAW1J,cAAc/E,IAAM,GAG5B,uBAGXiQ,YAAa,kBAAAnO,OAnMjBjE,OAmMiB,iFACT,OAAI+B,OAAO0B,SAASC,UAAU,cAC1B,IAEgB,EAAMkN,EAAA,EAAW/N,YAAY,iBAAiB,WAC1C,OADlBwP,EAAclP,EAAAC,QACI,EAAMwN,EAAA,EAAW/N,YAAY,oBAAoB,kBAAnEyP,EAAkBnP,EAAAC,OAElBmP,EAASC,KAAaC,MAAOH,EAAiBI,WAAY,WAC5DC,EAAI/B,EAAA,EAAWhN,OAChB8B,cAAmCjD,QAAQ,SAACN,GAC3CwQ,EAAIA,EAAE1M,SAAS9D,EAAE+D,IAAKU,MAAO2L,EAAOF,EAAYlQ,EAAE+D,SAEtDyK,EAAKpL,QAAQqL,EAAA,EAAWxK,aAAauM,IAAI,GAAO,aAGpDpN,QAAS,SAAC3J,EAAMgX,EAAqBC,EAAqBC,QAA1C,IAAAF,OAAA,QAAqB,IAAAC,OAAA,QAAqB,IAAAC,OAAA,GAElDA,GACAlX,EAAK4J,MAAM/C,QAAQ,SAACN,UACTA,EAAE4D,SACF5D,EAAE6D,IAIb6M,GACAlC,EAAKoC,YAGL,aAAcnX,GACdmG,OAAO0B,SAASuP,aAAa,YAAapX,EAAK0M,UAE/C,aAAc1M,GACdmG,OAAO0B,SAASuP,aAAa,UAAWpX,EAAK2M,UAEjD,IAAM/E,EAAczB,OAAO0B,SAASC,UAAU,aACxC6E,EAAWxG,OAAO0B,SAASC,UAAU,WAErCuP,EAAI,IAAIC,EAAA,EAAWtX,EAAK4J,MAAO5J,EAAKkI,MAAON,EAAa+E,GAC9DqI,EAAA,EAAWhN,MAAQqP,EAGnBtC,EAAKwC,2BAA2BpR,OAAO+P,SACvC/P,OAAO+P,QAAQvM,QAAQqL,EAAA,EAAWnJ,kBAAkBwL,IACpDrC,EAAA,EAAWhN,MAAQgN,EAAA,EAAWhJ,aAAa7F,OAAO+P,QAAQsB,gBAE1DrR,OAAO+P,QAAQuB,kBACftR,OAAO+P,QAAQwB,iBAEXT,IACA9Q,OAAO6G,GAAG2K,uBACVxR,OAAO6G,GAAG4K,aACVzR,OAAO6G,GAAG6K,yBACV1R,OAAO6G,GAAG8K,uBACV3C,EAAA,EAAKjF,SAAS,IACd8E,EAAA,EAAWtO,cACXsO,EAAA,EAAWhO,uBAAuBgQ,IAGtCjC,EAAKgD,yBAGTZ,UAAW,WACkB,OAArBnC,EAAA,EAAWhN,QAIXgN,EAAA,EAAWnI,YAAYrM,QAAUwU,EAAA,EAAWjI,YAC5CiI,EAAA,EAAWnI,YAAY5L,QAG3B+T,EAAA,EAAWnI,YAAYnM,KAAKqU,EAAKiD,qBACjChD,EAAA,EAAWlI,kBACXnK,SAASsV,uBAAuB,aAAaC,KAAK,GAAGC,cAAcA,cAAcC,UAAUC,IAAI,YAGnGL,kBAAmB,WACf,IAAMvQ,KAkBN,OAjBA9G,OAAOyH,KAAK4M,EAAA,GAAYnO,QAAQ,SAACgC,GAC7B,IAAMtC,EAAUyO,EAAA,EAAmBnM,GAClB,mBAANtC,IACU,iBAANA,EACPkB,EAAMoB,GAAKtC,GAGD,UAANsC,GAAuB,OAANtC,IACjBkB,EAAMoB,GAAKtC,GAEVsC,EAAE4C,cAAc6M,SAAS,aAC1B7Q,EAAMoB,GAAKsM,EAAA,EAAKlH,UAAS,EAAMc,MAAMC,QAAQzI,SAAcA,QAMpEkB,GAGX8Q,KAAM,WACEvD,EAAA,EAAWnI,YAAYrM,OAAS,GAChCuU,EAAKyD,YAAW,IAIxBC,KAAM,WACEzD,EAAA,EAAWlI,eAAetM,OAAS,GACnCuU,EAAKyD,YAAW,IAIxBA,WAAY,SAACD,EAAaG,QAAb,IAAAH,OAAA,QAAa,IAAAG,MAAA,MACtB,IAAMC,EAAyB,OAAbD,EACZE,EAAe7D,EAAKiD,oBAErBW,IAEGD,EADAH,EACWvD,EAAA,EAAWnI,YAAYgM,MAGvB7D,EAAA,EAAWlI,eAAe+L,OAK7CH,EAAS1Q,MAAQ,IAAIsP,EAAA,EAAWoB,EAAS1Q,MAAM4B,MAAO8O,EAAS1Q,MAAME,MAAOwQ,EAAS1Q,MAAM0E,SAAUgM,EAAS1Q,MAAM2E,UAEpHxG,OAAO0B,SAASuP,aAAa,YAAasB,EAAS1Q,MAAMuE,cACzDpG,OAAO0B,SAASuP,aAAa,UAAWsB,EAAS1Q,MAAM8D,cAEvDkJ,EAAA,EAAWhN,MAAQ0Q,EAAS1Q,MAE5B7B,OAAO+P,QAAQvM,QAAQqL,EAAA,EAAWnJ,kBAAkBmJ,EAAA,EAAWhN,QAC/D7B,OAAO+P,QAAQuB,kBACftR,OAAO+P,QAAQwB,iBAEfvR,OAAO6G,GAAG8K,uBACV3C,EAAA,EAAKjF,SAAS,IAEdvP,OAAOyH,KAAKsQ,GAAU7R,QAAQ,SAACgC,GAC3B,IAAMtC,EAAImS,EAAS7P,GACF,iBAANtC,EACNyO,EAAA,EAAmBnM,GAAKtC,EAEnBsC,EAAE4C,cAAc6M,SAAS,YAAkC,UAApBzP,EAAE4C,gBACvB,aAApB5C,EAAE4C,cACF9K,OAAOyH,KAAM4M,EAAA,EAAmBnM,IAAIhC,QAAQ,SAACiS,GACxC9D,EAAA,EAAmBnM,GAAGiQ,GAAQlS,SAAYL,EAAUuS,GAAQlS,WAIhEoO,EAAA,EAAmBnM,GAAKsM,EAAA,EAAKlH,UAAS,EAAO+G,EAAA,EAAmBnM,GAAItC,MAKjFyO,EAAA,EAAWhO,yBAAyB+R,KAAK,WACjCR,IAASI,GACThW,SAASsV,uBAAuB,aAAaC,KAAK,GAAGC,cAAcA,cAAcC,UAAUC,IAAI,UACzD,IAAlCrD,EAAA,EAAWnI,YAAYrM,QACvBmC,SAASsV,uBAAuB,aAAaC,KAAK,GAAGC,cAAcA,cAAcC,UAAU3F,OAAO,UAEtGuC,EAAA,EAAWlI,eAAepM,KAAKkY,IAEzBL,GAASI,IACfhW,SAASsV,uBAAuB,aAAaC,KAAK,GAAGC,cAAcA,cAAcC,UAAUC,IAAI,UACtD,IAArCrD,EAAA,EAAWlI,eAAetM,QAC1BmC,SAASsV,uBAAuB,aAAaC,KAAK,GAAGC,cAAcA,cAAcC,UAAU3F,OAAO,UAEtGuC,EAAA,EAAWnI,YAAYnM,KAAKkY,IAGhC7D,EAAKgD,2BAIbA,sBAAuB,WACf5R,OAAO0B,SAASmR,wBAChBC,aAAaC,QAAQ,4BAA6BC,KAAKC,UAAUrE,EAAKiD,uBAI9EqB,qBAAsB,WAClBtE,EAAKpL,SACDC,MAAOoL,EAAA,EAAWhN,MAAM8B,cACxB5B,MAAO8M,EAAA,EAAWhN,MAAMgC,gBACzB,GAAO,GAAO,IAGrBuN,2BAA4B,SAACrB,GACzB,IAAMjR,EAAI0L,KAAK2I,MAAsB,IAAhB3I,KAAK4I,UAC1BrD,EAAQsD,aAAaC,WAAaxU,EAClCiR,EAAQsD,aAAaE,kBAAoBzU,GAG7C0U,oBAAqB,SAACzD,GAElBA,EAAQ/C,GAAG,cAAe,SAAC/P,GACnB+C,OAAO0B,SAASC,UAAU,YAAc,UAAW1E,GAAwB,IAAnBA,EAAE8E,MAAM1H,QAChE0V,EAAQ0D,eAER,UAAWxW,GAAwB,IAAnBA,EAAEwG,MAAMpJ,QACxB0V,EAAQ7L,aAKhB6L,EAAQ/C,GAAG,UAAW,WAClB6B,EAAA,EAAWhN,MAAQgN,EAAA,EAAWhJ,aAAakK,EAAQsB,gBACnDzC,EAAKgD,0BAIT,IAAI8B,EAA+B,KACnC3D,EAAQ/C,GAAG,QAAS,SAAC3P,GACjBqW,EAAwBrW,IAI5Bb,SAASmX,iBAAiB,QAAS,SAACpU,GAChB,WAAZA,EAAIA,KAA8C,OAA1BmU,GACpB9E,EAAK/C,UAAU+H,SAAUF,EAA8BrW,MAAMQ,UACxD,UAAW6V,GAAyE,IAA/CA,EAA8B3R,MAAM1H,QACtE,UAAWqZ,GAAyE,IAA/CA,EAA8BjQ,MAAMpJ,SAC7E0V,EAAQ8D,mBAOxBrX,SAASmX,iBAAiB,UAAW,SAAC5X,GACL,MAAxBA,EAAEwD,IAAI+F,eAAyBvJ,EAAE+X,SAAqC,MAAxB/X,EAAEwD,IAAI+F,eAAyBvJ,EAAE+X,SAAW/X,EAAEgY,SAC7FnF,EAAK0D,OAEwB,MAAxBvW,EAAEwD,IAAI+F,eAAyBvJ,EAAE+X,SACtClF,EAAKwD,SAKb5V,SAASmX,iBAAiB,QAAS,SAAC5X,GAC5B6S,EAAK/C,YAAc9P,EAAE8B,QAAW+Q,EAAK/C,UAAU+H,SAAS7X,EAAE8B,UAC1D6V,EAAwB,UAOxCnQ,EAAA,IChbA,oBAAAyQ,KA2EA,OAnEkBA,EAAAnB,qBAAd,WACI,IACI,IAAM7O,EAAI,mBAGV,OAFA8O,aAAaC,QAAQ/O,EAAGA,GACxB8O,aAAamB,WAAWjQ,IACjB,EAEX,MAAOjI,GACH,OAAO,IAIDiY,EAAAE,aAAd,WACQF,EAASnB,wBACTC,aAAaC,QAAQ,2BAA4BC,KAAKC,UAAUe,EAASG,WAInEH,EAAAI,aAAd,WACQJ,EAASnB,yBACTmB,EAASG,QAAUnB,KAAKqB,MAAMvB,aAAawB,QAAQ,8BAE9B,OAArBN,EAASG,UACTH,EAASG,YAEbH,EAASO,UAGCP,EAAAO,OAAd,WACIvU,OAAO+P,QAAQyE,YAAY/Q,OAAQgR,QAAST,EAASrS,UAAU,kBAC/D3B,OAAO+P,QAAQyE,YAAYzS,OAAQ2S,QAASvR,GAAI6Q,EAASrS,UAAU,iBAC/DqS,EAASrS,UAAU,WACnB3B,OAAO+P,QAAQyE,YACXpF,cACI9K,UACIqQ,gBAAiB3U,OAAOuD,KAAKuL,sBAMzC9O,OAAO+P,QAAQyE,YAAYpF,cAAe9K,SAAUtE,OAAOuD,KAAK0L,WAAWG,aAAa9K,aAIlF0P,EAAA/C,aAAd,SAA2B2D,EAAgB3V,GACvC+U,EAASG,QAAQS,GAAU3V,EAC3B+U,EAASE,eACTF,EAASO,UAGCP,EAAArS,UAAd,SAAwBiT,GACpB,OAAIA,KAAUZ,EAASG,QACZH,EAASG,QAAQS,GAErBZ,EAASa,SAASD,IAGfZ,EAAAc,eAAd,WACId,EAASG,WACTH,EAASE,eACTF,EAASO,SAGT,IAAM3D,EAAI/B,EAAA,EAAWhN,MAAMkT,0BAA0Bf,EAASa,SAASG,UAAWhB,EAASa,SAASI,SACpGjV,OAAOuD,KAAKC,QAAQqL,EAAA,EAAWxK,aAAauM,KAxExBoD,EAAAa,UACpBK,aAAa,EACbF,WAAW,EACXC,SAAS,GAEEjB,EAAAG,WAqEnBH,EA3EA,+0CCOMmB,EAA2B,SAACtK,EACAuK,EACA5O,GAC9B,IAAM6O,EAAS,gBACZC,EAAe7D,UAAU4D,GACxBC,EAAeC,oBAAoBF,IAGvCC,EAAe7D,UAAU4D,IAAU,EAEnCrG,EAAA,EAAKjE,cAAc,SAACpD,EAAQ6N,GACpB7N,EAAOC,MAAM,QAEb,IAAM6N,EAAS5G,EAAA,EAAW1J,cAAcqQ,EAAO,IACzCE,EAAO7G,EAAA,EAAW1J,cAAcqQ,EAAO,IAEvCG,EAAmBL,EAAeM,wBAClCC,EAAIP,EAAeQ,oBAAoB,SAAC/Z,GAC1C,IAAIkF,EAAIlF,EAAElC,KAOV,GANAgc,EAAEE,UACCJ,GACCL,EAAe9D,uBAEnB8D,EAAe7D,UAAU4D,IAAU,GAEzB,IAANpU,EAAJ,CAcAA,EAAIA,EAEJ,IAAIhE,EAAI,OAAO4N,EAAK,gCAAgCmE,EAAA,EAAKlM,WAAW2S,EAAOvQ,YAAW,OAAO8J,EAAA,EAAKlM,WAAW4S,EAAKxQ,YAElH,GAAIjE,EAAE+U,WAAY,CACd/Y,EAAO4N,EAAK,SAASgE,EAAA,EAAW/J,cAAc2Q,GAAO,OACrDxY,GAAQ4R,EAAA,EAAW/J,cAAc4Q,GAAK,KAAKzU,EAAEgV,SACzCzP,IACAvJ,GAAK,yBAAyBgE,EAAEiV,MAEpCjZ,GAAK,mBAELA,EAAI+R,EAAA,EAAKlM,WAAW7F,GACpB,IAAI4E,EAAQgN,EAAA,EAAWxK,aAAawK,EAAA,EAAWhN,OAAO,GAAO,GACzDsU,EAAI,IAAIhF,EAAA,EAAWtP,EAAM4B,MAAO5B,EAAME,MAAOF,EAAM0E,SAAU1E,EAAM2E,UACvEvF,EAAEmV,KAAK1V,QAAQ,SAACN,EAAWjG,GACvB8C,GAAQ+R,EAAA,EAAKlM,WAAW+L,EAAA,EAAW/J,cAAc1E,IAAG,WACjDjG,EAAI,IACHgc,EAAIA,EAAE7R,SAASrD,EAAEmV,KAAKjc,EAAI,GAAIiG,EAAG,KAAM,KAAM,cAGrDyO,EAAA,EAAWhN,MAAQsU,EACnBnW,OAAOuD,KAAKC,QAAQqL,EAAA,EAAWxK,aAAa8R,IACxC,GAAO,GAAO,GAClBlZ,EAAIA,EAAEiD,MAAM,GAAI,GAChBjD,EAAI,OAAO4N,EAAK,YAAY5N,EAGhC+R,EAAA,EAAKjF,SAAS9M,QAzCN4N,EAAMsH,SAAS,YACfnD,EAAA,EAAKpE,gBAAgB,iBAAkB,sPAKlCC,EAAMsH,SAAS,YACpBnD,EAAA,EAAKpE,gBAAgB,qBAAsB,iJAoCvDiL,EAAEQ,MACE1Y,KAAMyX,EACNkB,MAAOb,EAAQC,GACfa,qBAAqB,EACrB1U,MAAO7B,OAAOuD,KAAKsL,WAAWxK,kBAGtCwG,EAAO,OACF9G,MAAO,aAAcpG,KAAM,OAAQmO,eAAgB9L,OAAOuD,KAAK6M,uBAC/DrM,MAAO,WAAYpG,KAAM,OAAQmO,eAAgB9L,OAAOuD,KAAK6M,0BAIpEoG,EAAyB,SAAOC,GAA0B,OAAAC,OApGhEzY,OAoGgE,4DAK5D,GAJIgD,EAAI,KACJ0V,EAAK,uBACLC,EAAe,sBAEfH,EAAmB,CACnB,IAAKzW,OAAO0B,SAASC,UAAU,aAC3B,UAEJgV,EAAK,YAAcA,EACnBC,EAAe,mCAGf,GAAI5W,OAAO0B,SAASC,UAAU,aAC1B,UAIR,OAAG2T,EAAe7D,UAAUkF,IACxBrB,EAAeC,oBAAoBoB,IACnC,EAAOxa,QAAQE,OAAO,sBAE1BiZ,EAAe7D,UAAUkF,IAAM,EAEzBhB,EAAmBL,EAAeM,yBAClCC,EAAIP,EAAeQ,oBAAoB,SAAC/Z,GAC1CkF,EAAIlF,EAAElC,KACNgc,EAAEE,UAEFlH,EAAA,EAAWtN,gBAAgBoV,GAAM1V,EAAEyP,MACnC7B,EAAA,EAAWtO,aAAY,GAAOoW,EAAIC,IAClC/H,EAAA,EAAWvN,MAAMsV,GAAgB3V,EAAE4V,WAEnC,IAAMA,EAAa7H,EAAA,EAAK9E,QAAQjJ,EAAE4V,YAC9B5Z,EAAI,aAAa0Z,EAAE,KAAK1V,EAAEyP,MAC9BzT,GAAK,OAEL4Z,EAAWnW,QAAQ,SAACN,EAAGjG,GACnB8C,GAAK,UAAU4R,EAAA,EAAW/J,cAAc3K,GAAE,+BAA+BiG,EAAC,OAG9EnD,GAAK,KAAK+V,KAAKC,UAAUjE,EAAA,EAAK7E,OAAOlJ,EAAE4V,YAAa,KAAM,GAAE,OAC5D5Z,EAAI,OAAO0Z,EAAE,YAAY3H,EAAA,EAAKlM,WAAW7F,GAEtC0Y,GACCL,EAAe9D,uBAEnB8D,EAAe7D,UAAUkF,IAAM,EAE/B3H,EAAA,EAAKjF,SAAS9M,MAEhBoZ,MACE1Y,KAAMiZ,EACNN,QACAzU,MAAO7B,OAAOuD,KAAKsL,WAAWxK,eAC9BkS,qBAAqB,cAI7BO,EAAA,WAKI,SAAAC,EAAY5S,EAAY0R,EAAWmB,GAAnC,IAAA7U,EAAAwG,KACIA,KAAKxE,GAAKA,EACVwE,KAAKsO,OAASpB,EACdlN,KAAKqO,SAAWA,EAChBnB,EAAEqB,aAAavZ,KAAM,KAAMwG,GAAEA,IAC7B0R,EAAEsB,UAAY,SAACpb,GACXoG,EAAK6U,UAAUnd,KAAMkC,EAAElC,KAAKA,QAYxC,OARWkd,EAAAtc,UAAA4b,KAAP,SAAYxc,GACR8O,KAAKsO,OAAOC,YAAYrd,IAGrBkd,EAAAtc,UAAAsb,QAAP,WACIpN,KAAKsO,OAAOG,YACZvI,EAAA,EAAWpI,WAAWkC,KAAKxE,IAAM,MAEzC4S,EAvBA,GAyBAzB,EAAA,oBAAA+B,KAklBA,OAhlBWA,EAAArQ,cAAP,WACI,QAEQxI,KAAM,iBACNiD,aAAa,EACbN,UAAWkW,EAAevQ,0BAC1BwQ,SAAS,IAGT9Y,KAAM,uBACNiD,aAAa,EACbN,UAAW,WACPqV,GAAuB,IAE3Bc,SAAS,IAGT9Y,KAAM,gCACNiD,aAAa,EACb6V,SAAS,EACTnW,UAAW,WACPqV,GAAuB,MAI3BhY,KAAM,8BACNiD,aAAa,EACbN,UAAW,WACPgU,EAAyB,8BAA+B,sBAAsB,IAElFmC,SAAS,IAGT9Y,KAAM,yBACN2C,UAAW,WACPgU,EAAyB,yBAA0B,kBAAkB,IAEzEmC,SAAS,IAGT9Y,KAAM,6BACNgI,UAAU,EACV/E,aAAa,EACbN,UAAW,WACPgU,EAAyB,6BAA8B,eAAe,IAE1EmC,SAAS,IAGT9Y,KAAM,iBACNgI,UAAU,EACV/E,aAAa,EACbN,UAAWkW,EAAeE,mBAC1BD,SAAS,IAGT9Y,KAAM,gCACNgI,UAAU,EACV/E,aAAa,EACbN,UAAWkW,EAAeG,oBAC1BF,SAAS,IAGT9Y,KAAM,SACN2C,UAAWkW,EAAepQ,qBAC1BxF,aAAa,EACb6V,SAAS,IAGT9Y,KAAM,mBACN2C,UAAWkW,EAAeI,4BAC1BhW,aAAa,EACb6V,SAAS,IAGT9Y,KAAM,WACNiD,aAAa,EACb6V,SAAS,EACTnW,UAAW,OAGX3C,KAAM,WACNiD,aAAa,EACb6V,SAAS,EACTnW,UAAWkW,EAAeK,mCAK/BL,EAAAM,kBAAP,eAAAxV,EAAAwG,KACUiP,EAA0B,SAACC,EAAkBzC,GAC/C5Y,SAASsb,cAAcD,GAAUlE,iBAAiB,QAAS,SAAC5X,GACxDA,EAAEgc,iBACF3C,OAIRwC,EAAwB,mBAAoBP,EAAeW,WAC3DJ,EAAwB,sBAAuBP,EAAeY,cAC9DL,EAAwB,sBAAuB,kBAAAlB,EAAAvU,OAAA,2EACvB,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAApB0Y,EAAc9W,EAAAC,OAAoC8W,QACxDnY,OAAOuD,KAAKC,QAAQ0U,EAAWE,YAAY,GAAO,GAAM,cAE5DR,EAAwB,wBAAyB,kBAAAlB,EAAAvU,OAAA,2EACzB,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAApB0Y,EAAc9W,EAAAC,OAAoC8W,QACxDnY,OAAOuD,KAAKC,QAAQ0U,EAAWG,cAAc,GAAO,GAAM,cAE9DT,EAAwB,sBAAuB,kBAAAlB,EAAAvU,OAAA,qEACvB,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CG,sBAEfV,EAAwB,uBAAwB,kBAAAlB,EAAAvU,OAAA,qEACxB,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CI,uBAEfX,EAAwB,oBAAqB,kBAAAlB,EAAAvU,OAAA,qEACrB,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CK,oBAEfZ,EAAwB,aAAc5X,OAAOuD,KAAK6O,MAClDwF,EAAwB,aAAc5X,OAAOuD,KAAK+O,MAClDsF,EAAwB,iCAAkC,kBAAAlB,EAAAvU,OAAA,8CACtD,SAAO0M,EAAA,EAAWhO,wBAAuB,UAE7C+W,EAAwB,yBAA0B5X,OAAOuD,KAAK2P,sBAC9D0E,EAAwB,oBAAqB,kBAAAlB,EAAAvU,OAAA,qEAC5B,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CM,iCAERb,EAAwB,oBAAqB,kBAAAlB,EAAAvU,OAAA,qEAC5B,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CO,iCAERd,EAAwB,oBAAqB,kBAAAlB,EAAAvU,OAAA,qEAC5B,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CQ,iCAERf,EAAwB,oBAAqB,kBAAAlB,EAAAvU,OAAA,qEAC5B,SAAM3G,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAAN4B,EAAAC,OAAoC8W,QAC7CS,kCAILvB,EAAAW,UAAP,WACIhJ,EAAA,EAAKpE,gBAAgB,OAAQ,0RAM1ByM,EAAAY,aAAP,WACIjJ,EAAA,EAAKjE,cACD,SAACpD,EAAQyG,GAKL,GAJAzG,EAAOC,MAAM,QACT5H,OAAO0B,SAASC,UAAU,iBAAmByM,EAAK,IAClDpO,OAAO0B,SAASuP,aAAa,cAAe7C,EAAK,IAEjDpO,OAAO0B,SAASC,UAAU,eAAiByM,EAAK,GAAI,CACpDpO,OAAO0B,SAASuP,aAAa,YAAa7C,EAAK,IAC/C,IAAIwC,EAAI/B,EAAA,EAAWhN,MACnB+O,EAAIxC,EAAK,GAAKwC,EAAEiI,YAAW,GAAQjI,EAAEkI,eAErC9Y,OAAOuD,KAAKC,QAAQqL,EAAA,EAAWxK,aAAauM,GAAG,IAEnD,GAAI5Q,OAAO0B,SAASC,UAAU,aAAeyM,EAAK,GAAI,CAClDpO,OAAO0B,SAASuP,aAAa,UAAW7C,EAAK,IACzCwC,EAAI/B,EAAA,EAAWhN,MACnB+O,EAAIxC,EAAK,GAAKwC,EAAEmI,aAAenI,EAAEoI,eACjChZ,OAAOuD,KAAKC,QAAQqL,EAAA,EAAWxK,aAAauM,MAGpD,UAAW,SACN7M,MAAO,gBAAiBiH,aAAchL,OAAO0B,SAASC,UAAU,eAAgBhE,KAAM,aACtFoG,MAAO,iBAAkBiH,aAAchL,OAAO0B,SAASC,UAAU,aAAchE,KAAM,aACrFoG,MAAO,iBAAkBiH,aAAchL,OAAO0B,SAASC,UAAU,WAAYhE,KAAM,aACrF,OAGJ0Z,EAAA3F,uBAAP,WACI,IAAe,IAAAuH,EAAA,EAAA7X,EAAAyN,EAAA,EAAWpI,WAAXwS,EAAA7X,EAAA/G,OAAA4e,IAAsB,CAAjC,IAAM7Y,EAACgB,EAAA6X,GACH7Y,aAAaJ,OAAOkZ,QACpB9Y,EAAEgX,YAGVvI,EAAA,EAAWpI,eAGR4Q,EAAAvB,oBAAP,SAA2BqB,GACvB,IAAIgC,EAAYtK,EAAA,EAAWpI,WAAW2S,UAAU,SAAChZ,GAC7C,OAAa,OAANA,QAA2B,IAANA,KAEd,IAAf+Y,IACCA,EAAYtK,EAAA,EAAWpI,WAAWpM,QAGtC,IAAMwb,EAAI,IAAIwD,EAAApY,EAEd,OADA4N,EAAA,EAAWpI,WAAW0S,GAAatD,EAC5B,IAAIiB,EAAYqC,EAAWtD,EAAGsB,IAGlCE,EAAAzB,sBAAP,WACI,IAAM0D,EAAO9c,SAASuG,eAAe,gBACrC,MAA0B,SAAvBuW,EAAKC,MAAMjC,UACVgC,EAAKC,MAAMjC,QAAW,QACf,IAKRD,EAAA7F,qBAAP,WACI,IAAM8H,EAAO9c,SAASuG,eAAe,gBACX,SAAvBuW,EAAKC,MAAMjC,UACVgC,EAAKC,MAAMjC,QAAW,SAIvBD,EAAA9B,oBAAP,SAA2B/W,GACvB,IAAIiB,EAAI,YACLjB,IACCiB,EAAIjB,GAERwQ,EAAA,EAAKpE,gBAAgB,uBAAwB,MAAQnL,EAAI,iEAItD4X,EAAAvQ,0BAAP,eAAA3E,EAAAwG,KACU0M,EAAS,iBACf,OAAGgC,EAAe5F,UAAU4D,IACxBgC,EAAe9B,oBAAoBF,GAC5BlZ,QAAQE,OAAO,qBAE1Bgb,EAAe5F,UAAU4D,IAAU,EAE5B,IAAIlZ,QAAc,SAAOC,GAAO,OAAAsa,EAAAvU,OAAA,qFACnC,OAAInC,OAAO0B,SAASC,UAAU,cAC1B0V,EAAe5F,UAAU4D,IAAU,GACnC,EAAOjZ,aAKW,EAAMyS,EAAA,EAAW/N,YAAY,oCAA/CM,EAAAmP,gBAAkBhO,EAAAlB,OAClBD,EAAAoP,OAAQ3B,EAAA,EAAWvN,MAAM8F,cAFzBnG,IAKEuY,EAAU,WACZ3K,EAAA,EAAWtN,gBAAgB,oBAAsBN,EAAEsP,gBACnD1B,EAAA,EAAWtO,aAAY,GAAO,mBAAoB,kBACjDsO,EAAA,EAAWvN,MAAM8F,cAAuBnG,EAAEuP,OAE3C,IAAMA,EAASxB,EAAA,EAAK9E,QAAQjJ,EAAEuP,QAC1BvT,EAAI,uBAAuBuT,EAAOnW,OACtC4C,GAAK,uBAAuBgE,EAAEsP,gBAC9BtT,GAAK,OAELuT,EAAO9P,QAAQ,SAACN,EAAGjG,GACf8C,GAAK,UAAU4R,EAAA,EAAW/J,cAAc3K,GAAE,eAAeiG,EAAC,OAG9DnD,GAAK,KAAK+V,KAAKC,UAAUjE,EAAA,EAAK7E,OAAOlJ,EAAEuP,QAAS,KAAM,GAAE,OAExDvT,EAAI,2DAA2D+R,EAAA,EAAKlM,WAAW7F,GAC/EA,GAAK,uGAEL+R,EAAA,EAAKjF,SAAS9M,GACd+C,OAAOuD,KAAK8M,eAGVsF,EAAmB0B,EAAezB,yBAElCtT,EAAsB,OAAtBrB,EAAEsP,kBAA6B,EAAM1B,EAAA,EAAW/N,YAAY,mBAA5D,YAA8BwB,EAAoD,OAAnDC,EAAAlB,+BAAhC,GAmBDmY,IACG7D,GACC0B,EAAe7F,yBApBbiI,EAAIpC,EAAevB,oBAAoB,SAAC/Z,GAC1CkF,EAAIlF,EAAElC,KACN2f,IACAC,EAAE1D,UACCJ,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAU4D,IAAU,EACnCjZ,EAAQL,EAAElC,SAEZwc,MACE1Y,KAAM,eACN2Y,QACAzU,MAAO7B,OAAOuD,KAAKsL,WAAWxK,eAC9BkS,qBAAqB,iBAY9Bc,EAAAK,gCAAP,eAAAvV,EAAAwG,KACU0M,EAAS,WACf,OAAGgC,EAAe5F,UAAU4D,IACxBgC,EAAe9B,oBAAoBF,GAC5BlZ,QAAQE,OAAO,qBAE1Bgb,EAAe5F,UAAU4D,IAAU,EAE5B,IAAIlZ,QAAc,SAAOC,GAAO,OAAAsa,EAAAvU,OAAA,+EACnC,OAAKnC,OAAO0B,SAASC,UAAU,cAKzBgU,EAAmB0B,EAAezB,wBAClCC,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1C8S,EAAA,EAAWtN,gBAAgB8F,SAAWtL,EAAElC,KACxCgV,EAAA,EAAWtO,aAAY,GAAO,aAC9BsV,EAAEE,UACCJ,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAU4D,IAAU,EACnCjZ,EAAQL,EAAElC,SAGF,EAAMgV,EAAA,EAAW/N,YAAY,+BAA+B,MAhBpEuW,EAAe5F,UAAU4D,IAAU,GACnC,EAAOjZ,oBAeLsd,EAAMtY,EAAAC,OAEZwU,EAAEQ,MACE1Y,KAAM,sBACN2Y,MAAOqD,EAAA,EAAMC,6BAA6B/K,EAAA,EAAWhN,MAAMgY,oBAAqBH,kBAKrFrC,EAAAtQ,qBAAP,SAA4B/F,GAA5B,IAAAmB,EAAAwG,UAA4B,IAAA3H,OAAA,GACxB,IAAMqU,EAAS,WACf,GAAGgC,EAAe5F,UAAU4D,GAAQ,CAChC,GAAGrU,EACC,OAGJ,OADAqW,EAAe9B,oBAAoBF,GAC5BlZ,QAAQE,OAAO,mBAI1B,OAFAgb,EAAe5F,UAAU4D,IAAU,EAE5B,IAAIlZ,QAAc,SAAOC,GAAO,OAAAsa,EAAAvU,OAAA,+EACnC,OAAInC,OAAO0B,SAASC,UAAU,cAC1B0V,EAAe5F,UAAU4D,IAAU,GACnC,EAAOjZ,EAAQib,EAAeK,sCAG5B/B,EAAmB0B,EAAezB,yBAC7B,EAAM/G,EAAA,EAAW/N,YAAY,uBAAuB,mBAAzD6V,EAAKvV,EAAAC,QAELwU,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1C8S,EAAA,EAAWtN,gBAAgB8F,SAAWtL,EAAElC,KACxCgV,EAAA,EAAWtO,aAAY,GAAO,aAC3BoV,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAU4D,IAAU,EACnCQ,EAAEE,UACF3Z,EAAQL,EAAElC,SAEZwc,MAAM1Y,KAAM,qBAAsB2Y,MAAOzH,EAAA,EAAWhN,MAAMiY,mBAAoBnD,iBAIjFU,EAAAE,mBAAP,eAAApV,EAAAwG,KACI,GAAK3I,OAAO0B,SAASC,UAAU,cAAiB3B,OAAO0B,SAASC,UAAU,WAA1E,CAGA,IAAM0T,EAAS,iBACZgC,EAAe5F,UAAU4D,GACxBgC,EAAe9B,oBAAoBF,IAGvCgC,EAAe5F,UAAU4D,IAAU,EAEnCrG,EAAA,EAAKjE,cAAc,SAAOpD,EAAQ6N,GAAM,OAAAkB,EAAAvU,OAAA,qEAChCwF,EAAOC,MAAM,QAEP6N,EAAS5G,EAAA,EAAW1J,cAAcqQ,EAAO,IACzCE,EAAO7G,EAAA,EAAW1J,cAAcqQ,EAAO,IAEzCvU,EAA4B,KAE1B8Y,EAAK,WACP,IAAI9c,EAAI,kDACRA,GAAQ+R,EAAA,EAAKlM,WAAW+L,EAAA,EAAW/J,cAAc2Q,IAAQ,OAAOzG,EAAA,EAAKlM,WAAW+L,EAAA,EAAW/J,cAAc4Q,KAE/F,IAANzU,GAIJA,EAAIA,EAEJhE,EAAI,+CAA+C4R,EAAA,EAAW/J,cAAc2Q,GAAO,IACnFxY,GAAK,MAAM4R,EAAA,EAAW/J,cAAc4Q,GAAK,KAAKzU,EAAE+Y,QAChD/c,GAAK,4BACLA,EAAI+R,EAAA,EAAKlM,WAAW7F,GACpBgE,EAAEgZ,SAASvZ,QAAQ,SAACN,GAChBnD,GAAQ4R,EAAA,EAAW/J,cAAc1E,EAAE8C,MAAK,SAAS2L,EAAA,EAAW/J,cAAc1E,EAAE+C,IAAG,UAAU/C,EAAE8Z,KAAI,OAAO9Z,EAAE+Z,SAAQ,OAGpHld,EAAI,8CADJA,EAAIA,EAAE4F,QAGNmM,EAAA,EAAKjF,SAAS9M,IAfV+R,EAAA,EAAKjF,SAAS9M,IAkBhB0Y,EAAmB0B,EAAezB,yBAClCC,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1CkF,EAAIlF,EAAElC,KACNwd,EAAe5F,UAAU4D,IAAU,EACnC0E,IACGpE,GACC0B,EAAe7F,uBAEnBqE,EAAEE,aAEJM,MACE1Y,KAAM,gBACN2Y,MAAOb,EAAQC,GACfa,qBAAqB,EACrB1U,MAAO7B,OAAOuD,KAAKsL,WAAWxK,0BAGtC,gCAAiC,OAC5BN,MAAO,cAAepG,KAAM,OAAQmO,eAAgB9L,OAAOuD,KAAK6M,uBAChErM,MAAO,YAAapG,KAAM,OAAQmO,eAAgB9L,OAAOuD,KAAK6M,2BAIpEiH,EAAAG,oBAAP,WACI,IAAIxX,OAAO0B,SAASC,UAAU,cAAiB3B,OAAO0B,SAASC,UAAU,WAAzE,CAKA,GAAG0V,EAAe5F,UAAgB,QAC9B4F,EAAe9B,oBAFJ,eACf,CAIA8B,EAAe5F,UAAgB,SAAI,EAEnC,IAAMkE,EAAmB0B,EAAezB,wBAClCC,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1C,IAAMkF,EAAelF,EAAElC,KACvBgc,EAAEE,UAEF,IAAI9Y,EAAI,iDAAiDgE,EAAEmZ,YAC3Dnd,GAAK,uBACLA,EAAI+R,EAAA,EAAKlM,WAAW7F,GACpBgE,EAAEoZ,IAAI3Z,QAAQ,SAACN,GAEXnD,GAAQ4R,EAAA,EAAW/J,cAAc,IAAKwV,EAAA,EAAUla,GAAIma,WAAU,SAE9Dtd,GAAQ4R,EAAA,EAAW/J,cAAc,IAAKwV,EAAA,EAAUla,GAAIoa,SAAQ,OAGhEvd,EAAI,8CADJA,EAAIA,EAAE4F,QAGH8S,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAgB,SAAI,EAEnCzC,EAAA,EAAKjF,SAAS9M,KAElB4Y,EAAEQ,MACE1Y,KAAM,UACN2Y,QACAC,qBAAqB,EACrB1U,MAAO7B,OAAOuD,KAAKsL,WAAWxK,oBAI/BgT,EAAApQ,qBAAP,WACI,GAAKjH,OAAO0B,SAASC,UAAU,aAA/B,CAKA,OAAG0V,EAAe5F,UAAgB,QAC9B4F,EAAe9B,oBAFJ,UAGJpZ,QAAQE,OAAO,qBAE1Bgb,EAAe5F,UAAgB,QAAI,EAE5B,IAAItV,QAAc,SAACC,GACtB,IAAMuZ,EAAmB0B,EAAezB,wBAClCC,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1C8S,EAAA,EAAWtN,gBAAgBkG,OAAS1L,EAAElC,KACtCgV,EAAA,EAAWtO,aAAY,GAAO,WAC9BsV,EAAEE,UACCJ,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAgB,QAAI,EACnCrV,MAEJyZ,EAAEQ,MACE1Y,KAAM,gBACN2Y,QACAC,qBAAqB,EACrB1U,MAAO7B,OAAOuD,KAAKsL,WAAWxK,sBAKnCgT,EAAAI,4BAAP,WACI,GAAKzX,OAAO0B,SAASC,UAAU,aAA/B,CAIA,IAAM0T,EAAS,mBACf,GAAGgC,EAAe5F,UAAU4D,GACxBgC,EAAe9B,oBAAoBF,OADvC,CAIAgC,EAAe5F,UAAU4D,IAAU,EAEnC,IAAMM,EAAmB0B,EAAezB,wBAClCC,EAAIwB,EAAevB,oBAAoB,SAAC/Z,GAC1C,IAAMkF,EAA2BlF,EAAElC,KAQnC,GAPAgc,EAAEE,UAECJ,GACC0B,EAAe7F,uBAEnB6F,EAAe5F,UAAU4D,IAAU,GAEzB,IAANpU,EAKA,OAJA4N,EAAA,EAAWtN,gBAAgBkG,QAAS,EACpCoH,EAAA,EAAWtO,aAAY,GAAO,gBAC9ByO,EAAA,EAAKjF,SAAS,wGAKlB,IAAI9M,EAAI,2BACRA,EAAI+R,EAAA,EAAKlM,WAAW7F,GACnBgE,EAAYP,QAAQ,SAACN,GAClBnD,GAAQ4R,EAAA,EAAW/J,cAAc1E,EAAE+D,IAAG,OAG1ClH,EAAI,oCADJA,EAAIA,EAAEiD,MAAM,GAAI,IAGhB8O,EAAA,EAAKjF,SAAS9M,KAElB4Y,EAAEQ,MACE1Y,KAAM,kBACN2Y,QACAC,qBAAqB,EACrB1U,MAAO7B,OAAOuD,KAAKsL,WAAWxK,oBAI/BgT,EAAA1F,qBAAP,WACI,IAAM8I,EAAOje,SAASuG,eAAe,mBACrC0X,EAAKzX,UAAY,GACjB,IAAMvB,EAAczB,OAAO0B,SAASC,UAAU,aACxC6E,EAAWxG,OAAO0B,SAASC,UAAU,WAErC+Y,EAAgB,SAACC,GACnB,IAAMC,EAAUpe,SAASG,cAAc,KACvCie,EAAQ3I,UAAUC,IAAI,YACtB0I,EAAQ7d,aAAa,OAAQ,KAC7B6d,EAAQC,UAAYF,EAAInc,KACxBoc,EAAQjH,iBAAiB,QAAS,SAAC5X,GAC/BA,EAAEgc,iBACF4C,EAAIxZ,cAGRsZ,EAAKtc,YAAYyc,IAGXvD,EAAerQ,gBACvBtG,QAAQ,SAACia,GACFA,EAAIrD,UAGJ,gBAAiBqD,GAAOA,EAAIlZ,cAAgBA,KAAkB,gBAAiBkZ,KAC3E,aAAcA,GAAOA,EAAInU,WAAaA,IAAe,aAAcmU,GACpED,EAAcC,KAGZ,aAAcA,GAAOA,EAAInU,WAAaA,IAAe,aAAcmU,KACpE,gBAAiBA,GAAOA,EAAIlZ,cAAgBA,IAAkB,gBAAiBkZ,GAChFD,EAAcC,OA5kBhBtD,EAAA5F,aAilBlB4F,EAllBA,mzCCpKArX,OAAOuD,KAAOA,EACdvD,OAAO+P,QAAU,IAAI+K,EAAA,QAAQvX,EAAKsI,aAAetI,EAAK0L,YACtDjP,OAAO0B,SAAWA,EAClB1B,OAAO6G,GAAKkU,EAGZC,EAAA,OAAa,6EAA6EC,UAC1Fjb,OAAOkb,MAAQF,EAEfzX,EAAKiQ,oBAAoBxT,OAAO+P,SAEhCrO,EAAS0S,eAET,IAAI+G,GAAc,EAClB,GAAIzZ,EAASmR,uBAAwB,CACjC,IAAMpX,EAAYqX,aAAawB,QAAQ,6BACvC,GAAU,OAAN7Y,EAAY,CACZ,IAAM2f,EAAiBpI,KAAKqB,MAAM5Y,GAC9B,UAAW2f,GAAa,UAAWA,EAAUvZ,QAC7CsZ,GAAc,EACd5X,EAAK8O,YAAW,EAAO+I,KAI/BD,GACCE,OA7CLpd,OA6CK,2EACuB,SAAMzC,EAAAO,EAAA,GAAA6W,KAAApX,EAAAgE,KAAA,0BAApB0Y,EAAc9W,EAAAC,OAAoC8W,QACxD5U,EAAKC,QAAQ0U,EAAWE,YAAY,GAAO,GAAM,YAIzDpY,OAAO6G,GAAG8Q,qDCzCVhJ,EAAA,GACIiL,6BAA8B,SAAC0B,GAE3B,IAAMC,KAkBN,OAjBAD,EAAgB5a,QAAQ,SAACN,EAAGjG,GACpBA,KAAKohB,EACLA,EAAQphB,GAAGqhB,KAAOpb,EAAE/F,OAGpBkhB,EAAQphB,IAAMqhB,IAAKpb,EAAE/F,OAAQohB,GAAI,GAErCrb,EAAEM,QAAQ,SAACgb,GACHA,KAAQH,EACRA,EAAQG,GAAMD,IAAM,EAGpBF,EAAQG,IAASD,GAAI,EAAGD,IAAK,OAKlCD,GAGXI,0BAA2B,SAAC5Z,GACxB,IAAM0B,KAMN,OALA1B,EAAMrB,QAAQ,SAACN,GACXqD,EAAMrD,EAAE8C,OAASiB,GAAI/D,EAAE8C,KAAMa,MAAO3D,EAAE8C,KAAKgC,YAC3CzB,EAAMrD,EAAE+C,KAAOgB,GAAI/D,EAAE+C,GAAIY,MAAO3D,EAAE+C,GAAG+B,cAGlCzB,wBCzCf5H,EAAAD,QAAA,WACA,WAAAsd,OAAA1d,EAAAyB,EAAA,mECYA,IAAAqd,EAAA,WAMI,SAAAA,EAAYpX,EAA+BC,EAAaC,EAAiBsI,+BAAjB,IAAAtI,MAAA,QAAiB,IAAAsI,MAAA,MAAzE,IAAAvJ,EAAAwG,KACwB,iBAATzF,IACPwI,EAAalR,OAAOyH,KAAKiB,GACpBkC,OAAO,SAAC7F,GAAQ,QAAE,OAAQ,KAAM,UAAU4S,SAAS5S,KACnD+K,OAAO,SAACjC,EAAU9I,GAEf,OADA8I,EAAI9I,GAAyB2D,EAAM3D,GAC5B8I,OAGflF,EAAKD,EAAKC,GACVC,EAASF,EAAKE,OACdF,EAAOA,EAAKA,MAGhByF,KAAKiT,cACc,OAAflQ,GAA6C,iBAAfA,GAC9BlR,OAAOyH,KAAKyJ,GAAYhL,QAAQ,SAACnB,GAC7B4C,EAAKyZ,WAAWrc,GAAO/E,OAAOuO,OAAO2C,EAAWnM,MAIxDoJ,KAAKiT,WAAaphB,OAAOuO,OAAOJ,KAAKiT,YACrCjT,KAAKzF,KAAO1I,OAAOuO,OAAO7F,GAC1ByF,KAAKxF,GAAK3I,OAAOuO,OAAO5F,GACxBwF,KAAKvF,OAAS5I,OAAOuO,OAAOkE,WAAW7J,IAEnCyY,IAAevB,GACf9f,OAAOuO,OAAOJ,MAiD1B,OA7CI2R,EAAA7f,UAAA8f,QAAA,WACI,OAAO5R,KAAKzF,MAGhBoX,EAAA7f,UAAA+f,MAAA,WACI,OAAO7R,KAAKxF,IAGhBmX,EAAA7f,UAAAqhB,UAAA,WACI,OAAOnT,KAAKvF,QAGhBkX,EAAA7f,UAAAwL,aAAA,SAAa8V,GACT,OAAIA,KAAapT,KAAKiT,WACXjT,KAAKiT,WAAWG,GAGpB,MAGXzB,EAAA7f,UAAAuhB,iBAAA,WACI,OAAOrT,KAAKiT,YAGhBtB,EAAA7f,UAAAwhB,QAAA,eAAA9Z,EAAAwG,KACUuT,GAA4BhZ,KAAMyF,KAAKzF,KAAMC,GAAIwF,KAAKxF,GAAIC,OAAQuF,KAAKvF,QAO7E,OANA5I,OAAOyH,KAAK0G,KAAKiT,YAAYlb,QAAQ,SAACnB,GAC5BA,KAAO2c,IACTA,EAAS3c,GAAO4C,EAAKyZ,WAAWrc,MAIjC2c,GAGX5B,EAAA7f,UAAA6J,SAAA,SAASC,EAAmBmH,QAAA,IAAAA,UAExB,IAAMkQ,EAAaphB,OAAO2hB,UAAWxT,KAAKiT,YAK1C,OAJAphB,OAAOyH,KAAKyJ,GAAYhL,QAAQ,SAACnB,GAC7Bqc,EAAWrc,GAAOmM,EAAWnM,KAG1B,IAAI+a,EAAU3R,KAAK4R,UAAW5R,KAAK6R,QACxB,OAAdjW,EAAqBoE,KAAKmT,YAAcvX,EAAWqX,IAE/DtB,EAlFA,kECHM8B,EAAkB,SAACviB,EAAWwiB,GAChC,OAAO7hB,OAAOyH,KAAKpI,GACduL,OAAO,SAAC7F,GAAQ,OAAC,EAAS4S,SAAS5S,KACnC+K,OAAO,SAACjC,EAAU9I,GAEf,OADA8I,EAAI9I,GAAO1F,EAAK0F,GACT8I,QAIbiU,EAAsB,SAACziB,GACzB,OAAOuiB,EAAgBviB,GAAO,QAAS,QAGrC0iB,EAAsB,SAAC1iB,GACzB,OAAOuiB,EAAgBviB,GAAO,OAAQ,KAAM,YAG1C2iB,EAA2B,SAACza,EAAY0a,GAC1C,QAD0C,IAAAA,UAC5B,OAAV1a,EACA,OAAO,EAGX,IAAI2a,EAA4BliB,OAAAmiB,EAAA,KAAAniB,GAEhC,MAAqB,iBAAVuH,IACPA,EAAMrB,QAAQ,SAACkc,GACX,IAAIxZ,EAAS,EACTF,EAAO,EACPC,EAAK,EACLuI,KAEA,WAAYkR,IACZxZ,EAAS6J,WAAW2P,EAAKxZ,SAEzB,SAAUwZ,IACV1Z,EAAOuZ,EAAQG,EAAK1Z,OAEpB,OAAQ0Z,IACRzZ,EAAKsZ,EAAQG,EAAKzZ,KAGlBuI,EAAa6Q,EADb,eAAgBK,EACiBA,EAAKhB,WAGLgB,GAGrCF,EAAWA,EAASniB,KAAK,IAAIsiB,EAAA,EAAU3Z,EAAMC,EAAIC,EAAQsI,MAO1DgR,IAGLI,EAA2B,SAACrZ,GAC9B,GAAc,OAAVA,EACA,OAAO,EAGX,IAAIsC,EAA4BvL,OAAAmiB,EAAA,KAAAniB,GAC1BiiB,KAEN,GAAqB,iBAAVhZ,EAEP,IAAK,IAAItJ,EAAI,EAAGA,EAAIqQ,KAAKuS,MAAMtZ,GAAQtJ,IACnC4L,EAAWA,EAASG,IAAI/L,EAAG,IAAI6iB,EAAA,EAAU7iB,IACzCsiB,EAAQtiB,GAAKA,MAGhB,IAAqB,iBAAVsJ,EA8BZ,OAAO,EA7BP,IAAIwZ,EAAU,EACdxZ,EAAM/C,QAAQ,SAACjB,GACX,IAAM0E,EAAK8Y,IACPlZ,EAAQ,KACR2H,EAAa,KAEb,UAAWjM,IACXsE,EAAQtE,EAAEsE,OAEV,OAAQtE,GACRgd,EAAQhd,EAAE0E,IAAMA,EACZ,UAAW1E,GAAKA,EAAEsE,QAAUtE,EAAE0E,GAAGe,aACjCnB,EAAQI,EAAGe,aAIfuX,EAAQtY,GAAMA,EAGduH,EAAa4Q,EADb,eAAgB7c,EACiBA,EAAEmc,WAGFnc,GAGrCsG,EAAWA,EAASG,IAAI/B,EAAI,IAAI6Y,EAAA,EAAU7Y,EAAIJ,EAAO2H,MAO7D,OAAQjI,MAAOjJ,OAAOuO,OAAOhD,GAAW1D,IAAKoa,IAGjDtL,EAAA,WAQI,SAAAA,EAAY1N,EACA1B,EACAwE,EAAkBC,+BADlB,IAAAzE,MAAA,WACA,IAAAwE,OAAA,QAAkB,IAAAC,OAAA,GAC1BmC,KAAKpC,SAAW/L,OAAOuO,OAAOxC,GAC9BoC,KAAKnC,SAAWhM,OAAOuO,OAAOvC,GAC9B,IAAIiW,KAGJ,GAAqB,iBAAVhZ,IAAwC,iBAAVA,GAAwBA,aAAiBkZ,EAAA,MAQ7E,MAAIlZ,aAAiBkZ,EAAA,MAItB,MAAM,IAAI5e,MAAM,0DAHhB4K,KAAKlF,MAAQA,MATyE,CACtF,IAAMhE,EAAIqd,EAAyBrZ,GACnC,GAAiB,iBAANhE,EACP,MAAM,IAAI1B,MAAM,+BAEpB4K,KAAKlF,MAAQhE,EAAEgE,MACfgZ,EAAUhd,EAAE4C,IAYhB,GAJAsG,KAAKlF,MAAQjJ,OAAOuO,OAAOJ,KAAKlF,OAChCkF,KAAKuU,SAAW1iB,OAAOuO,OAAOJ,KAAKlF,MAAM0Z,MAG3B,OAAVpb,GAAmC,iBAAVA,GAAwBA,aAAiB4a,EAAA,KAO7D5a,aAAiB4a,EAAA,KACtBhU,KAAK5G,MAAQA,EAGb4G,KAAK5G,MAAQvH,OAAAmiB,EAAA,KAAAniB,OAX4D,CACzE,IAAMuB,EAAIygB,EAAyBza,EAAO0a,GAC1C,GAAiB,iBAAN1gB,EACP,MAAM,IAAIgC,MAAM,8BAEpB4K,KAAK5G,MAAQhG,EAQjB4M,KAAK5G,MAAQvH,OAAOuO,OAAOJ,KAAK5G,OAChC4G,KAAKyU,SAAW5iB,OAAOuO,OAAOJ,KAAK5G,MAAMob,MAErCtB,IAAe1K,GACf3W,OAAOuO,OAAOJ,MAqX1B,OAjXIwI,EAAA1W,UAAAsK,QAAA,SAAQZ,EAAYkZ,GAChB,YADgB,IAAAA,OAAA,KACZlZ,GAAMwE,KAAKuU,YAGXG,EACO1U,KAAKlF,MAAM5E,IAAIsF,GAEnBwE,KAAKlF,MAAM5E,IAAIsF,GAAI8X,YAG9B9K,EAAA1W,UAAAqJ,QAAA,SAAQjK,QAAA,IAAAA,MAAA,MACS,OAATA,IACAA,MAGJ,IAAMsK,EAAKwE,KAAKuU,SACV,UAAWrjB,IACbA,EAAKkK,MAAQI,EAAGe,YAGpB,IAAMwG,EAAa4Q,EAAoBziB,GAEvC,OAAO,IAAIsX,EAAWxI,KAAKlF,MAAMyC,IAAI/B,EAAI,IAAI6Y,EAAA,EAAU7Y,EAAItK,EAAKkK,MAAO2H,IACnE/C,KAAK5G,MAAO4G,KAAKpC,SAAUoC,KAAKnC,WAGxC2K,EAAA1W,UAAAyJ,SAAA,SAASC,EAAYtK,GACjB,IAAK8O,KAAKlF,MAAM6Z,IAAInZ,GAChB,OAAO,EAGX,IAAMuH,EAAa4Q,EAAoBziB,GAIvC,MAHM,UAAWA,IACbA,EAAKkK,MAAS4E,KAAK5D,QAAQZ,GAAI,GAAoBc,YAEhD,IAAIkM,EAAWxI,KAAKlF,MAAMyC,IAAI/B,EAAKwE,KAAK5D,QAAQZ,GAAI,GAAoBD,SAASrK,EAAKkK,MAAO2H,IAChG/C,KAAK5G,MAAO4G,KAAKpC,SAAUoC,KAAKnC,WAGxC2K,EAAA1W,UAAAmK,WAAA,SAAWT,GAEP,KAAMA,GAAM,GAAKA,EAAKwE,KAAKuU,UACvB,OAAO,EAGX,IAAMT,KAGFc,EAAY,EA8BhB,OAAO,IAAIpM,EA7BuBxI,KAAKlF,MAClC2B,OAAO,SAAC3F,GAQL,OAPIA,EAAE8F,UAAYpB,EACdsY,EAAQhd,EAAE8F,UAAY,EAGtBkX,EAAQhd,EAAE8F,SAAWgY,IAGlB9d,EAAE8F,UAAYpB,IAExB9B,IAAI,SAACgD,GACF,IAAItB,EAAQsB,EAAKJ,WAKjB,OAJII,EAAKE,QAAQL,aAAenB,IAC5BA,EAAQ0Y,EAAQpX,EAAKE,SAASL,YAG3B,IAAI8X,EAAA,EAAUP,EAAQpX,EAAKE,SAAUxB,EAAOsB,EAAK2W,sBAI9BrT,KAAK5G,MAClCqD,OAAO,SAACwX,GACL,QAASA,EAAKrC,YAAcpW,GAAMyY,EAAKpC,UAAYrW,KAEtD9B,IAAI,SAACua,GACF,OAAO,IAAIC,EAAA,EAAUJ,EAAQG,EAAKrC,WAAYkC,EAAQG,EAAKpC,SAAUoC,EAAKd,YAAac,EAAKZ,sBAG1DrT,KAAKpC,SAAUoC,KAAKnC,WAGlE2K,EAAA1W,UAAAwI,QAAA,SAAQC,EAAcC,EAAYC,QAAA,IAAAA,MAAA,GACzBuF,KAAKnC,WACNpD,EAAS,GAGb,IAAMsZ,EAAW/T,KAAK5G,MAAMxH,KAAK,IAAIsiB,EAAA,EAAU3Z,EAAMC,EAAI8J,WAAW7J,KACpE,OAAO,IAAI+N,EAAWxI,KAAKlF,MAAOiZ,EAAU/T,KAAKpC,SAAUoC,KAAKnC,WAGpE2K,EAAA1W,UAAAkK,WAAA,SAAWzB,EAAcC,EAAYC,EAAoBoa,GAAzD,IAAArb,EAAAwG,UAAqC,IAAAvF,MAAA,WAAoB,IAAAoa,OAAA,GACtC,OAAXpa,IACAA,EAAS6J,WAAW7J,IAGxB,IAAIqa,GAAe,EACbf,EAA4B/T,KAAK5G,MAAMqD,OAAO,SAACwX,GAEjD,SAAIa,GAAiBD,MAKjBZ,EAAKrC,YAAcrX,GAAQ0Z,EAAKpC,UAAYrX,GAAkB,OAAXC,GAAmBwZ,EAAKd,cAAgB1Y,OAM1FjB,EAAKoE,UACFqW,EAAKrC,YAAcpX,GAAMyZ,EAAKpC,UAAYtX,GAAoB,OAAXE,GAAmBwZ,EAAKd,cAAgB1Y,KAN/Fqa,GAAe,GACR,MAcf,OAAO,IAAItM,EAAWxI,KAAKlF,MAAOiZ,EAAU/T,KAAKpC,SAAUoC,KAAKnC,WAGpE2K,EAAA1W,UAAA6J,SAAA,SAASpB,EAAcC,EAAYoB,EAAgBC,EAAuBK,GAA1E,IAAA1C,EAAAwG,UAAmD,IAAAnE,MAAA,WAAuB,IAAAK,MAAA,MACtE,IAAI6Y,GAAa,EAEC,OAAdlZ,IACAA,EAAYyI,WAAWzI,IAG3B,IAAIkY,EAAW/T,KAAK5G,MAsBpB,OArBA4G,KAAK5G,MAAMrB,QAAQ,SAACkc,EAAMe,GAClBD,KAIEd,EAAKrC,YAAcrX,GAAQ0Z,EAAKpC,UAAYrX,IACzChB,EAAKiE,cAAgBwW,EAAKrC,YAAcpX,GAAMyZ,EAAKpC,UAAYtX,IAClD,OAAdsB,GAAsBoY,EAAKd,cAAgBtX,IAG3CkY,EADU,OAAV7X,EACW6X,EAASxW,IAAIyX,EACpBf,EAAKtY,SAAuB,OAAdC,EAAqB,KAAO0I,WAAW1I,IAChDM,MAAOA,KAGL6X,EAASxW,IAAIyX,EAAOf,EAAKtY,SAAuB,OAAdC,EAAqB,KAAO0I,WAAW1I,KAExFmZ,GAAa,KAId,IAAIvM,EAAWxI,KAAKlF,MAAOiZ,EAAU/T,KAAKpC,SAAUoC,KAAKnC,WAGpE2K,EAAA1W,UAAAkJ,YAAA,SAAY0Z,GACR,YADQ,IAAAA,OAAA,GACJA,EACO1U,KAAKlF,MAAMma,UAEfjV,KAAKlF,MAAMpB,IAAI,SAACgD,GACnB,OAAOA,EAAK4W,YACb2B,WAGPzM,EAAA1W,UAAAuL,2BAAA,WACI,OAAO2C,KAAKlF,OAGhB0N,EAAA1W,UAAA0L,2BAAA,WACI,OAAOwC,KAAK5G,OAGhBoP,EAAA1W,UAAAoJ,YAAA,SAAYwZ,GACR,YADQ,IAAAA,OAAA,GACJA,EACO1U,KAAK5G,MAAM6b,UAEfjV,KAAK5G,MAAMM,IAAI,SAACua,GACnB,OAAOA,EAAKX,YACb2B,WAGPzM,EAAA1W,UAAAqH,iBAAA,WACI,OAAO6G,KAAKuU,UAGhB/L,EAAA1W,UAAAuH,iBAAA,WACI,OAAO2G,KAAKyU,UAGhBjM,EAAA1W,UAAAqf,iBAAA,WACI,IAAMyB,KAaN,OAZA5S,KAAKlF,MAAM/C,QAAQ,SAACmd,EAAG1jB,GACnBohB,EAAQphB,GAAK,IAEjBwO,KAAK5G,MAAMrB,QAAQ,SAACkc,GACZA,EAAKrC,YAAagB,EAClBA,EAAQqB,EAAKrC,aAGbgB,EAAQqB,EAAKrC,WAAa,IAI3BgB,GAGXpK,EAAA1W,UAAAse,WAAA,WACI,OAAO,IAAI5H,EAAWxI,KAAKlF,MAAOkF,KAAK5G,MAAMM,IAAI,SAACua,GAC9C,OAAOA,EAAKtY,SAAS,KACFqE,KAAKpC,UAAU,IAG1C4K,EAAA1W,UAAAue,aAAA,WACI,OAAO,IAAI7H,EAAWxI,KAAKlF,MAAOkF,KAAK5G,MAAMM,IAAI,SAACua,GAC9C,OAAOA,EAAKtY,SAAS,KACFqE,KAAKpC,UAAU,IAG1C4K,EAAA1W,UAAAoe,WAAA,SAAWiF,GACP,QADO,IAAAA,OAAA,IACFA,EACD,OAAO,IAAI3M,EAAWxI,KAAKlF,MAAOkF,KAAK5G,OAAO,EAAM4G,KAAKnC,UAG7D,IAAIkW,EAAW/T,KAAK5G,MAKpB,OAJA4G,KAAK5G,MAAMrB,QAAQ,SAACkc,GAChBF,EAAWA,EAASniB,KAAK,IAAIsiB,EAAA,EAAUD,EAAKpC,QAASoC,EAAKrC,UAAWqC,EAAKd,YAAac,EAAKZ,uBAGzF,IAAI7K,EAAWxI,KAAKlF,MAAOiZ,GAAU,EAAM/T,KAAKnC,WAG3D2K,EAAA1W,UAAAqe,aAAA,WACI,IAAI4D,EAA4BliB,OAAAmiB,EAAA,KAAAniB,GAC1BujB,KAeN,OAbApV,KAAK5G,MAAMrB,QAAQ,SAACkc,GAChB,IAAI1Z,EAAO0Z,EAAKrC,UACZpX,EAAKyZ,EAAKpC,QACVrX,EAAKD,IACLA,EAAOC,EACPA,EAAKyZ,EAAKrC,WAELrX,EAAI,IAAIC,KAAQ4a,IACrBA,EAAc7a,EAAI,IAAIC,GAAQ,KAC9BuZ,EAAWA,EAASniB,KAAK,IAAIsiB,EAAA,EAAU3Z,EAAMC,EAAIyZ,EAAKd,YAAac,EAAKZ,wBAIzE,IAAI7K,EAAWxI,KAAKlF,MAAOiZ,GAAU,EAAO/T,KAAKnC,WAG5D2K,EAAA1W,UAAAsa,0BAAA,SAA0BxO,EAAmBC,GACzC,IAAIoK,EAAgBjI,KAepB,OAdIpC,IAAaoC,KAAKpC,SAClBqK,EAAIA,EAAEiI,cAEAtS,GAAYoC,KAAKpC,WACvBqK,EAAIA,EAAEkI,gBAGNtS,IAAamC,KAAKnC,SAClBoK,EAAIA,EAAEmI,cAEAvS,GAAYmC,KAAKnC,WACvBoK,EAAIA,EAAEoI,gBAGHpI,GAGXO,EAAA1W,UAAAujB,iBAAA,SAAiB7Z,GAAjB,IAAAhC,EAAAwG,KACUsV,KAUN,OATAtV,KAAK5G,MAAMrB,QAAQ,SAACkc,GACZA,EAAKrC,YAAcpW,EACnB8Z,EAAI1jB,KAAKqiB,EAAKpC,SAERrY,EAAKoE,UAAYqW,EAAKpC,UAAYrW,GACxC8Z,EAAI1jB,KAAKqiB,EAAKrC,aAIf0D,GAGX9M,EAAA1W,UAAAof,iBAAA,eAAA1X,EAAAwG,KACUsV,KAKN,OAJAtV,KAAKlF,MAAM/C,QAAQ,SAACjB,GAChBwe,EAAIxe,EAAE8F,SAAWpD,EAAK6b,iBAAiBve,EAAE8F,WAGtC0Y,GAGX9M,EAAA1W,UAAAyjB,YAAA,SAAYC,EAAaC,GACrB,OAAOzV,KAAKqV,iBAAiBG,GAAKhM,SAASiM,IAG/CjN,EAAA1W,UAAA4jB,gBAAA,SAAgBF,EAAaC,GAA7B,IAAAjc,EAAAwG,KACU2V,KACN,OAAIH,GAAOxV,KAAKuU,UAAYkB,GAAOzV,KAAKuU,SAC7BoB,GAGX3V,KAAK5G,MAAMrB,QAAQ,SAACkc,GACXza,EAAKoE,UAAYqW,EAAKrC,YAAc6D,GAAOxB,EAAKpC,UAAY2D,GAC7DG,EAAS/jB,KAAKqiB,GAGdA,EAAKrC,YAAc4D,GAAOvB,EAAKpC,UAAY4D,GAC3CE,EAAS/jB,KAAKqiB,KAIf0B,IAGXnN,EAAA1W,UAAA8jB,wBAAA,SAAwBJ,EAAaC,GACjC,IAAII,EAAYC,IAOhB,OANA9V,KAAK0V,gBAAgBF,EAAKC,GAAK1d,QAAQ,SAACkc,GAChCA,EAAKd,YAAc0C,IACnBA,EAAY5B,EAAKd,eAIlB0C,GAIXrN,EAAA1W,UAAAikB,iBAAA,SAAiBC,EAAsD3T,GAAvE,IAAA7I,EAAAwG,UAAiB,IAAAgW,MAA4CnU,KAAKoU,UAAK,IAAA5T,MAAAyT,KACnE,IAAMI,KACNlW,KAAKlF,MAAM/C,QAAQ,SAAC2E,GAEhB,IAAM4Y,EAAM9b,EAAK6b,iBAAiB3Y,EAAKE,SACjCuZ,EAAU,IAAIC,IAAId,GACpBa,EAAQ3B,KAAOc,EAAI5jB,QACnBykB,EAAQpe,QAAQ,SAACyC,GACb,IAAMoB,EAAYpC,EAAKkc,gBAAgBhZ,EAAKE,QAASpC,GAAImH,OAAO,SAAC0U,EAAKpC,GAClE,OAAO+B,EAAQK,EAAKpC,EAAKd,cAC1B9Q,GAEH6T,EAAWtkB,MAAM2I,KAAMmC,EAAKE,QAASpC,GAAEA,EAAEC,OAAQ6J,WAAW1I,SAMxE,IAAImY,EAAW/T,KAAK5G,MAAMqD,OAAO,SAACwX,GAC9B,IAAIqC,GAAO,EAOX,OANAJ,EAAWne,QAAQ,SAACwe,GACZtC,EAAKrC,YAAc2E,EAAchc,MAAQ0Z,EAAKpC,UAAY0E,EAAc/b,KACxE8b,GAAO,KAIRA,IAMX,OAJAJ,EAAWne,QAAQ,SAACkc,GAChBF,EAAWA,EAASniB,KAAK,IAAIsiB,EAAA,EAAUD,EAAK1Z,KAAM0Z,EAAKzZ,GAAIyZ,EAAKxZ,WAG7D,IAAI+N,EAAWxI,KAAKlF,MAAOiZ,EAAU/T,KAAKpC,SAAUoC,KAAKnC,WAGpE2K,EAAA1W,UAAAkL,WAAA,WACI,OAAOgD,KAAKnC,UAGhB2K,EAAA1W,UAAA2L,WAAA,WACI,OAAOuC,KAAKpC,UAEpB4K,EAxaA,yCC3GA,IAAAgO,EAAA,WAKI,SAAAA,EAAYhb,EAASJ,EAA6B2H,+BAA7B,IAAA3H,MAAA,WAA6B,IAAA2H,MAAA,MAAlD,IAAAvJ,EAAAwG,KAEQA,KAAK5E,MADK,OAAVA,EACaI,EAAGe,WAGHnB,EAGjB4E,KAAKiT,cACc,OAAflQ,GAA6C,iBAAfA,GAC9BlR,OAAOyH,KAAKyJ,GAAYhL,QAAQ,SAACnB,GAC7B4C,EAAKyZ,WAAWrc,GAAO/E,OAAOuO,OAAO2C,EAAWnM,MAIxDoJ,KAAKiT,WAAaphB,OAAOuO,OAAOJ,KAAKiT,YACrCjT,KAAK5E,MAAQvJ,OAAOuO,OAAOJ,KAAK5E,OAChC4E,KAAKxE,GAAK3J,OAAOuO,OAAO5E,GAEpB0X,IAAesD,GACf3kB,OAAOuO,OAAOJ,MAkD1B,OA9CIwW,EAAA1kB,UAAAwhB,QAAA,eAAA9Z,EAAAwG,KACUuT,GAA4B/X,GAAIwE,KAAKxE,GAAIJ,MAAO4E,KAAK5E,OAO3D,OANAvJ,OAAOyH,KAAK0G,KAAKiT,YAAYlb,QAAQ,SAACnB,GAC5BA,KAAO2c,IACTA,EAAS3c,GAAO4C,EAAKyZ,WAAWrc,MAIjC2c,GAGXiD,EAAA1kB,UAAA8K,MAAA,WACI,OAAOoD,KAAKxE,IAGhBgb,EAAA1kB,UAAAwK,SAAA,WACI,OAAO0D,KAAK5E,OAGhBob,EAAA1kB,UAAAwL,aAAA,SAAa8V,GACT,OAAIA,KAAapT,KAAKiT,WACXjT,KAAKiT,WAAWG,GAGpB,MAGXoD,EAAA1kB,UAAAuhB,iBAAA,WACI,OAAOrT,KAAKiT,YAGhBuD,EAAA1kB,UAAAyJ,SAAA,SAASH,EAAmB2H,QAAnB,IAAA3H,MAAA,WAAmB,IAAA2H,MAAA,MACV,OAAV3H,IACAA,EAAQ4E,KAAK1D,YAIjB,IAAM2W,EAAaphB,OAAO2hB,UAAWxT,KAAKiT,YAO1C,OANkB,OAAflQ,GACClR,OAAOyH,KAAKyJ,GAAYhL,QAAQ,SAACnB,GAC7Bqc,EAAWrc,GAAOmM,EAAWnM,KAI9B,IAAI4f,EAAUxW,KAAKpD,QAASxB,EAAO6X,IAElDuD,EA3EA","file":"bundle-33f48160f4a3d58c14aa.min.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \"-\" + {\"0\":\"7166824719c2bb4b67f0\",\"1\":\"721d0d36e3cd9358e9db\"}[chunkId] + \".min.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\tvar error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\thead.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([104,4]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\"use strict\";\r\n\r\nimport {DataSet, Edge} from 'vis/index-network';\r\nimport help from './genericHelpers';\r\nimport GraphImmut from './GraphImmut/GraphImmut';\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\nimport NodeImmut, {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\n\r\ninterface UpToDateProperties {\r\n    name: string;\r\n    upToDate: boolean;\r\n    type: string;\r\n    always?: boolean;\r\n    applyFunc?: (ignoreDuplicate?: boolean) => any;\r\n    [index: string]: string|boolean|((ignoreDuplicate?: boolean) => any)\r\n}\r\n\r\ninterface GraphProperties {\r\n    vertices: number;\r\n    edges: number;\r\n    eulerian: boolean;\r\n    \"Chromatic Number\": number | null;\r\n    \"Connected Components\": number | null;\r\n    \"Strongly Connected Components\": number | null;\r\n    cyclic: boolean;\r\n\r\n    [index: string]: boolean | number | null;\r\n}\r\n\r\ninterface GraphStateData {\r\n    stronglyConnectedComponents: null | { [key: number]: number };\r\n    connectedComponents: null | { [key: number]: number };\r\n    graphColoring: null | number[];\r\n\r\n    [index: string]: null | number[] | { [key: number]: number };\r\n}\r\n\r\nexport interface AddNodeI {\r\n    id?: number\r\n    label: string;\r\n    x: number;\r\n    y: number;\r\n    color?:string;\r\n}\r\n\r\nexport interface GraphStateHistory {\r\n    upToDate: UpToDateProperties[];\r\n    state: GraphStateData;\r\n    graph: GraphImmut;\r\n    graphProperties: GraphProperties;\r\n    [index: string]: UpToDateProperties[]|GraphStateData|GraphImmut|GraphProperties;\r\n}\r\n\r\nconst getInt = (v: string|number): number => {\r\n    if(typeof v === 'number'){\r\n        return v;\r\n    }\r\n    return parseInt(v);\r\n};\r\n\r\nexport default class GraphState {\r\n    public static workerPool: Worker[] = [];\r\n    public static backHistory: GraphStateHistory[] = [];\r\n    public static forwardHistory: GraphStateHistory[] = [];\r\n    public static maxHistory = 10;\r\n    public static upToDate: UpToDateProperties[] = [\r\n        {\r\n            name: \"Chromatic Number\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {\r\n            name: \"graphColoring\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {name: \"vertices\", upToDate: true, always: true, type: \"property\"},\r\n        {name: \"edges\", upToDate: true, always: true, type: \"property\"},\r\n        {\r\n            name: \"eulerian\", upToDate: false, type: \"property\",\r\n            applyFunc: (i) => {\r\n                return window.ui.makeAndPrintEulerian(i);\r\n            }\r\n        },\r\n        {\r\n            name: \"Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.getAlgorithms().find((v) => v.name === 'Connected Components').applyFunc();\r\n            }\r\n        },\r\n        {\r\n            name: \"connectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.getAlgorithms().find((v) => v.name === 'Connected Components').applyFunc();\r\n            }\r\n        },\r\n        {\r\n            name: \"Strongly Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.getAlgorithms().find((v) => v.name === 'Strongly Connected Components').applyFunc();\r\n            }\r\n        },\r\n        {\r\n            name: \"stronglyConnectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.getAlgorithms().find((v) => v.name === 'Strongly Connected Components').applyFunc();\r\n            }\r\n        },\r\n        {\r\n            name: \"cyclic\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintIsCyclic();\r\n            }\r\n        },\r\n    ];\r\n    public static state: GraphStateData = {\r\n        stronglyConnectedComponents: null,\r\n        connectedComponents: null,\r\n        graphColoring: null,\r\n    };\r\n    public static graph: GraphImmut = null;\r\n    public static graphProperties: GraphProperties = {\r\n        vertices: 0,\r\n        edges: 0,\r\n        eulerian: false,\r\n        \"Chromatic Number\": null,\r\n        \"Connected Components\": null,\r\n        \"Strongly Connected Components\": null,\r\n        cyclic: false,\r\n    };\r\n\r\n    static setUpToDate(value = false, listOptions?: string[]) {\r\n        const all = listOptions === null || typeof listOptions === \"undefined\";\r\n        let property = false;\r\n        GraphState.upToDate.forEach((v) => {\r\n            if ((!(\"always\" in v) || !v.always) && (all || listOptions.indexOf(v.name) > -1)) {\r\n                v.upToDate = value;\r\n                if (v.type === \"property\") {\r\n                    property = true;\r\n                }\r\n            }\r\n        });\r\n        if (property) {\r\n            GraphState.makeAndPrintProperties();\r\n        }\r\n    }\r\n\r\n    static async getProperty(property: string, updateIfNotUpdated = false, ignoreDuplicate = false): Promise<any> {\r\n        const a = GraphState.upToDate.find((v) => {\r\n            return (\"name\" in v && v.name === property);\r\n        });\r\n        if (!a.upToDate) {\r\n            if (\"applyFunc\" in a && updateIfNotUpdated) {\r\n                await a.applyFunc(ignoreDuplicate);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        if (a.type === \"state\") {\r\n            return Promise.resolve(GraphState.state[property]);\r\n        }\r\n        return Promise.resolve(GraphState.graphProperties[property]);\r\n    }\r\n\r\n    static async makeAndPrintProperties(recalcLong = false) {\r\n        const directional = window.settings.getOption(\"direction\");\r\n\r\n        GraphState.graphProperties.vertices = GraphState.graph.getNumberOfNodes();\r\n        GraphState.graphProperties.edges = GraphState.graph.getNumberOfEdges();\r\n\r\n        if (!directional) {\r\n            await GraphState.getProperty(\"eulerian\", true, true);\r\n        }\r\n\r\n        const p = Object.keys(GraphState.graphProperties);\r\n        if (recalcLong) {\r\n            p.forEach(async (v) => {\r\n                await GraphState.getProperty(v, true);\r\n            });\r\n        }\r\n\r\n        const printableProperties: any = {};\r\n        await Promise.all(p.map(async (v) => {\r\n            printableProperties[v] = await GraphState.getProperty(v);\r\n        }));\r\n\r\n        GraphState.printGraphProperties(printableProperties);\r\n    }\r\n\r\n    static printGraphProperties(properties: any) {\r\n        let p = \"\";\r\n        Object.keys(properties).forEach((k) => {\r\n            if (properties[k] !== null) {\r\n                p += `${help.toTitleCase(k)}: ${properties[k]}\\n`;\r\n            }\r\n        });\r\n        p = p.trim();\r\n        p = help.htmlEncode(p);\r\n        document.getElementById(\"graphProps\").innerHTML = `<p class='nav-link'>${p}</p>`;\r\n    }\r\n\r\n    static addEdge(from: number|string, to: number|string, weight = 0, graph = GraphState.graph) {\r\n        const edgeFrom = getInt(from);\r\n        const edgeTo = getInt(to);\r\n        graph = graph.addEdge(edgeFrom, edgeTo, weight);\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: GraphState.clearColorFromEdges(graph.getAllEdges() as EdgeImmutPlain[])\r\n        });\r\n    }\r\n\r\n    static addNode(data: AddNodeI, graph = GraphState.graph) {\r\n        graph = graph.addNode({label: data.label, x: data.x, y: data.y});\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: GraphState.clearColorFromEdges(graph.getAllEdges() as EdgeImmutPlain[])\r\n        });\r\n    }\r\n\r\n    static editNode(id: number|string, label: string, graph = GraphState.graph) {\r\n        const iId = getInt(id);\r\n        graph = graph.editNode(iId, {label});\r\n        window.main.setData(GraphState.getGraphData(graph), false, false);\r\n    }\r\n\r\n    static editEdge(from: number | string, to: number | string,\r\n                    newWeight: number, oldWeight: number, graph = GraphState.graph) {\r\n        const edgeFrom = getInt(from);\r\n        const edgeTo = getInt(to);\r\n        const newGraph = graph.editEdge(edgeFrom, edgeTo, newWeight, oldWeight);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData(GraphState.getGraphData(newGraph), false, false);\r\n        }\r\n    }\r\n\r\n    static deleteEdge(from: number|string, to: number|string, weight: number = null, graph = GraphState.graph) {\r\n        const edgeFrom = getInt(from);\r\n        const edgeTo = getInt(to);\r\n        graph = graph.deleteEdge(edgeFrom, edgeTo, weight, false);\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: GraphState.clearColorFromEdges(graph.getAllEdges() as EdgeImmutPlain[])\r\n        });\r\n    }\r\n\r\n    static deleteNode(id: number|string, graph = GraphState.graph) {\r\n        const iId = getInt(id);\r\n        const newGraph = graph.deleteNode(iId);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData({\r\n                nodes: GraphState.clearColorFromNodes(newGraph.getAllNodes() as NodeImmutPlain[]),\r\n                edges: GraphState.clearColorFromEdges(graph.getAllEdges() as EdgeImmutPlain[])\r\n            });\r\n        }\r\n    }\r\n\r\n    static clearColorFromNodes(nodes: NodeImmutPlain[]): NodeImmutPlain[] {\r\n        nodes.forEach((v) => {\r\n            v.color = null;\r\n        });\r\n        return nodes;\r\n    }\r\n\r\n    static clearColorFromEdges(edges: EdgeImmutPlain[]): EdgeImmutPlain[] {\r\n        edges.forEach((v) => {\r\n            delete v.color;\r\n        });\r\n        return edges;\r\n    }\r\n\r\n    static nodeIDToLabel(id: number, graph = GraphState.graph): string {\r\n        const n = graph.getNode(id, true);\r\n        if (n !== false && n !== null && n instanceof NodeImmut && n.getLabel().trim().length > 0) {\r\n            return n.getLabel().trim();\r\n        }\r\n\r\n        return id.toString();\r\n    }\r\n\r\n    // Preferentially search by ID, label, and case-insensitive label\r\n    static nodeLabelToID(label: string, graph = GraphState.graph) {\r\n        let n = graph.getAllNodes(true) as NodeImmut[];\r\n        n = n.filter((node) => {\r\n            return node.getLabel().toLowerCase() === label.toLowerCase() || node.getID().toString() === label;\r\n        });\r\n\r\n        if (n.length === 0) {\r\n            return -1;\r\n        }\r\n        else if (n.length === 1) {\r\n            return n[0].getID();\r\n        }\r\n\r\n        let rID = -1;\r\n        let found = false;\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getID().toString() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel().toLowerCase() === label.toLowerCase()) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        return rID;\r\n    }\r\n\r\n    // Return graph as a Vis compatible dataset\r\n    static getGraphAsDataSet(graph: GraphImmut): { nodes: DataSet<vis.Node>; edges: DataSet<vis.Edge> } {\r\n        const d = GraphState.getGraphData(graph);\r\n        if (graph.isWeighted()) {\r\n            d.edges.forEach((e) => {\r\n                e.label = e.weight.toString();\r\n            });\r\n        }\r\n        d.edges.forEach((e) => {\r\n            if('color' in e) {\r\n                e.color = {color: e.color};\r\n            }\r\n        });\r\n\r\n        return {nodes: new DataSet(d.nodes as vis.Node[]), edges: new DataSet(d.edges as vis.Edge[])};\r\n    }\r\n\r\n    static setLocations(locations: {[key: string]: {x: number; y: number}}, graph = GraphState.graph): GraphImmut {\r\n        let newNodes = graph.getAllNodesAsImmutableList();\r\n        Object.keys(locations).forEach((i) => {\r\n            const v = locations[i];\r\n            const node = newNodes.get(parseInt(i));\r\n            // Only change when there is actually a new position\r\n            if (node.getAttribute(\"x\") !== v.x || node.getAttribute(\"y\") !== v.y) {\r\n                // Batch up all changes that we'll be making\r\n                newNodes = newNodes.set(parseInt(i), node.editNode(node.getLabel(), {x: v.x, y: v.y}));\r\n            }\r\n        });\r\n\r\n        return new GraphImmut(newNodes, graph.getAllEdgesAsImmutableList(), graph.isDirected(), graph.isWeighted());\r\n    }\r\n\r\n    static getGraphData(graph = GraphState.graph, clearNodeColors = false, clearEdgeColors = false): GraphPlain {\r\n        const nodes = graph.getAllNodes() as NodeImmutPlain[];\r\n        const edges = graph.getAllEdges() as EdgeImmutPlain[];\r\n        return {\r\n            nodes: clearNodeColors ? GraphState.clearColorFromNodes(nodes) : nodes,\r\n            edges: clearEdgeColors ? GraphState.clearColorFromEdges(edges) : edges,\r\n            directed: graph.isDirected(),\r\n            weighted: graph.isWeighted()\r\n        };\r\n    }\r\n}\r\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\n\r\ndeclare interface ModalFormRow {\r\n    type: string;\r\n    label?: string;\r\n    initialValue?: any;\r\n    id?: string | number;\r\n    extraAttrs?: any;\r\n    validationFunc?: (value?: any, container?: JQuery) => boolean | string;\r\n    clickDismiss?: boolean;\r\n    onclick?: (...args: any[]) => void;\r\n    optionText?: any[];\r\n    optionValues?: any[];\r\n}\r\n\r\ndeclare interface BasicMapType {\r\n    class: string;\r\n    id: string;\r\n    value: any,\r\n\r\n    [key: number]: any,\r\n\r\n    [key: string]: any\r\n}\r\n\r\nconst defaultCancelCb = ($modal: JQuery) => {\r\n    $modal.modal(\"hide\");\r\n};\r\n\r\nconst self = {\r\n    deepCopy(deep: boolean, clone: any, copy: any) {\r\n        const isPlainObject = (obj: any) => {\r\n            if (!obj || {}.toString.call(obj) !== \"[object Object]\") {\r\n                return false;\r\n            }\r\n\r\n            let proto = Object.getPrototypeOf(obj);\r\n\r\n            if (!proto) {\r\n                return true;\r\n            }\r\n\r\n            // Objects with prototype are plain iff they were constructed by a global Object function\r\n            let Ctor = ({}).hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n            return typeof Ctor === \"function\" && ({}).hasOwnProperty.toString.call(Ctor) === ({}).hasOwnProperty.toString.call(Object);\r\n        };\r\n\r\n\r\n        let options, name, src, copyIsArray,\r\n            target = arguments[0] || {},\r\n            i = 1,\r\n            length = arguments.length;\r\n\r\n        // Handle a deep copy situation\r\n        if (typeof target === \"boolean\") {\r\n            deep = target;\r\n\r\n            // Skip the boolean and the target\r\n            target = arguments[i] || {};\r\n            i++;\r\n        }\r\n\r\n        // Handle case when target is a string or something (possible in deep copy)\r\n        if (typeof target !== \"object\" && typeof target !== \"function\") {\r\n            target = {};\r\n        }\r\n\r\n        if (i === length) {\r\n            target = this;\r\n            i--;\r\n        }\r\n\r\n        for (; i < length; i++) {\r\n\r\n            // Only deal with non-null/undefined values\r\n            if ((options = arguments[i]) != null) {\r\n\r\n                // Extend the base object\r\n                for (name in options) {\r\n                    src = target[name];\r\n                    copy = options[name];\r\n\r\n                    // Prevent never-ending loop\r\n                    if (target === copy) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Recurse if we're merging plain objects or arrays\r\n                    if (deep && copy && (isPlainObject(copy) ||\r\n                        (copyIsArray = Array.isArray(copy)))) {\r\n\r\n                        if (copyIsArray) {\r\n                            copyIsArray = false;\r\n                            clone = src && Array.isArray(src) ? src : [];\r\n\r\n                        } else {\r\n                            clone = src && isPlainObject(src) ? src : {};\r\n                        }\r\n\r\n                        // Never move original objects, clone them\r\n                        target[name] = self.deepCopy(deep, clone, copy);\r\n\r\n                        // Don't bring in undefined values\r\n                    } else if (copy !== undefined) {\r\n                        target[name] = copy;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Return the modified object\r\n        return target;\r\n    },\r\n\r\n    deepFreeze: <T>(o: T): Readonly<T> => {\r\n        Object.freeze(o);\r\n\r\n        Object.getOwnPropertyNames(o).forEach((prop: string | number) => {\r\n            if (o.hasOwnProperty(prop) && (o as any)[prop] !== null\r\n                && (typeof (o as any)[prop] === \"object\" || typeof (o as any)[prop] === \"function\")\r\n                && !Object.isFrozen((o as any)[prop])) {\r\n                self.deepFreeze((o as any)[prop]);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    },\r\n\r\n    sort: <T>(arr: T[], compareFunction: (a: any, b: any) => number): T[] => {\r\n        return [...arr].sort(compareFunction);\r\n    },\r\n\r\n    datasetToArray: (ds: any, key: string): Readonly<any[]> => {\r\n        const r: any[] = [];\r\n        ds.forEach((v: { [index: string]: any }) => {\r\n            r.push(v[key]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    keepOnlyKeys: <T>(arr: T[], keys: string[]): Readonly<T[]> => {\r\n        arr = arr.slice();\r\n        arr.forEach((v: any) => {\r\n            const k = Object.keys(v);\r\n            k.forEach((key) => {\r\n                if (keys.indexOf(key) < 0) {\r\n                    delete v[key];\r\n                }\r\n            });\r\n        });\r\n        return self.deepFreeze(arr);\r\n    },\r\n\r\n    getFileExtension: (filename: string): string => {\r\n        return filename.split(\".\").splice(-1)[0];\r\n    },\r\n\r\n    htmlEncode: (string: string): string => {\r\n        const t = document.createElement(\"textarea\");\r\n        t.textContent = string;\r\n        string = t.innerHTML.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>');\r\n        return string;\r\n    },\r\n\r\n    printout: (text: string, escape?: string): void => {\r\n        if (escape) {\r\n            text = this.htmlEncode(escape);\r\n        }\r\n        document.getElementById(\"printout\").innerHTML = text;\r\n    },\r\n\r\n    flatten: <T>(map: { [key: string]: T }): Readonly<T[]> => {\r\n        const r: T[] = [];\r\n        Object.keys(map).forEach((i) => {\r\n            r.push(map[i]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    rotate: (map: {[key: string]: any}): Readonly<any> => {\r\n        const r: any = {};\r\n        Object.keys(map).forEach((i) => {\r\n            if (map[i] in r) {\r\n                r[map[i]].push(i);\r\n            }\r\n            else {\r\n                r[map[i]] = [i];\r\n            }\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    max: (iterable: any[]): number => {\r\n        return iterable.reduce((a, b) => {\r\n            return Math.max(a, b);\r\n        });\r\n    },\r\n\r\n    toTitleCase: (str: string): string => {\r\n        return str.replace(/(?:^|\\s)\\w/g, (match) => {\r\n            return match.toUpperCase();\r\n        });\r\n    },\r\n\r\n    showSimpleModal: (title: string, body: string): void => {\r\n        self.showFormModal(null, title, null, [{type: \"html\", initialValue: body}], null, false);\r\n    },\r\n\r\n    makeFormModal: (title: string, successText: string, form: ModalFormRow[], footer = true): JQuery => {\r\n        const f = $(\"<div>\", {class: \"modal-body form-group\"});\r\n        form.forEach((formRow, i) => {\r\n            if (!(\"initialValue\" in formRow)) {\r\n                formRow.initialValue = \"\";\r\n            }\r\n\r\n            let id = \"form-modal-\" + i;\r\n            if (\"id\" in formRow && formRow.id !== \"\" && formRow.id !== null && typeof formRow.id === \"string\") {\r\n                id = formRow.id;\r\n            }\r\n\r\n            const basicMap: BasicMapType = {class: \"form-control\", id, value: formRow.initialValue};\r\n\r\n            if (\"extraAttrs\" in formRow) {\r\n                Object.keys(formRow.extraAttrs).forEach((attrname) => {\r\n                    if (typeof formRow.extraAttrs[attrname] !== \"function\") {\r\n                        basicMap[attrname] = formRow.extraAttrs[attrname];\r\n                    }\r\n                });\r\n            }\r\n\r\n            let validFunc = (value?: any, container?: JQuery): string | boolean => true;\r\n            if (\"validationFunc\" in formRow) {\r\n                validFunc = formRow.validationFunc;\r\n            }\r\n\r\n            const generalValidator = (event: any, valueMutator: (v: any) => any = null) => {\r\n                const $v = $(event.target);\r\n                let val = $v.val();\r\n                if (valueMutator !== null && typeof valueMutator === \"function\") {\r\n                    val = valueMutator(val);\r\n                }\r\n                const valid = validFunc(val, $v);\r\n\r\n                if (valid === true) {\r\n                    $v.removeClass(\"is-invalid\").next(\"#feedback-\" + i).remove();\r\n                }\r\n                else {\r\n                    $v.addClass(\"is-invalid\");\r\n                    if ($v.next(\"#feedback-\" + i).length === 0) {\r\n                        $v.after($(\"<div>\", {class: \"invalid-feedback\", id: \"feedback-\" + i}).text(valid));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (formRow.type === \"html\") {\r\n                f.append($(formRow.initialValue));\r\n            }\r\n            else if (formRow.type === \"checkbox\") {\r\n                basicMap.type = \"checkbox\";\r\n                basicMap.class = \"form-check-input\";\r\n                delete basicMap.value;\r\n                if (formRow.initialValue) {\r\n                    basicMap.checked = \"\";\r\n                }\r\n\r\n                f.append($(\"<div>\", {class: \"form-check\"})\r\n                    .append($(\"<label>\", {for: id, class: \"form-check-label\"})\r\n                        .text(formRow.label).prepend($(\"<input>\", basicMap))\r\n                    )\r\n                );\r\n            }\r\n            else {\r\n                f.append($(\"<label>\", {for: id, class: \"col-form-label\"}).text(formRow.label));\r\n\r\n                if (formRow.type === \"button\") {\r\n                    if (\"clickDismiss\" in formRow && formRow.clickDismiss === true) {\r\n                        basicMap.class += \" btn-dismiss\";\r\n                    }\r\n                    const $b = $(\"<button>\", basicMap).text(formRow.initialValue);\r\n                    if (\"onclick\" in formRow && typeof formRow.onclick === \"function\") {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"numeric\") {\r\n                    basicMap.type = \"number\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", (e) => {\r\n                        generalValidator(e, parseFloat);\r\n                    }));\r\n                }\r\n                else if (formRow.type === \"text\") {\r\n                    basicMap.type = \"text\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"file\") {\r\n                    basicMap.type = \"file\";\r\n                    basicMap.class = \"form-control-file form-control\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"textarea\") {\r\n                    const $b = $(\"<textarea>\", basicMap).on(\"blur validate\", generalValidator);\r\n                    if (\"onclick\" in formRow) {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"select\") {\r\n                    const $options = $(\"<select>\", basicMap);\r\n                    formRow.optionText.forEach((oText, oIndex) => {\r\n                        if (oIndex < formRow.optionValues.length) {\r\n                            $options.append($(\"<option>\", {value: formRow.optionValues[oIndex]}).text(oText));\r\n                        }\r\n                        else {\r\n                            $options.append($(\"<option>\").text(oText));\r\n                        }\r\n                    });\r\n                    f.append($options.on(\"blur validate\", generalValidator));\r\n                }\r\n            }\r\n        });\r\n\r\n        let $footer = $(\"<div>\", {class: \"modal-footer\"})\r\n            .append($(\"<button>\", {class: \"btn btn-success\", type: \"button\"}).text(successText))\r\n            .append($(\"<button>\", {class: \"btn btn-danger btn-cancel\", type: \"button\"}).text(\"Cancel\"));\r\n\r\n        if (footer === false) {\r\n            $footer = null;\r\n        }\r\n\r\n        const $modal = ($(\"<div>\", {class: \"modal fade\", tabindex: \"-1\", role: \"dialog\", \"aria-hidden\": \"true\"}));\r\n        $modal\r\n            .append($(\"<div>\", {class: \"modal-dialog\"})\r\n                .append($(\"<div>\", {class: \"modal-content\"})\r\n                    .append($(\"<div>\", {class: \"modal-header\"})\r\n                        .append($(\"<h5>\", {class: \"modal-title\"}).text(title))\r\n                        .append($(\"<button>\", {class: \"close\", \"data-dismiss\": \"modal\", \"aria-label\": \"close\"})\r\n                            .append($(\"<span>\", {\"aria-hidden\": \"true\"}).html(\"&times;\"))\r\n                        )\r\n                    )\r\n                    .append(f)\r\n                    .append($footer)\r\n                )\r\n            );\r\n        $modal.find(\"input, textarea\").off(\"keyup\").on(\"keyup\", (e) => {\r\n            if (e.key === \"Enter\") {\r\n                $(\".btn-success\").last().trigger(\"click\");\r\n            }\r\n        });\r\n        $modal.on(\"shown.bs.modal\", () => {\r\n            $modal.find(\"input[type='text'], input[type='number'], textarea\").first().trigger(\"focus\");\r\n        });\r\n\r\n        return $modal;\r\n    },\r\n\r\n    showFormModal: (successCb: ($modal: JQuery, vals: any[]) => void,\r\n                    title: string, successText: string, form: ModalFormRow[],\r\n                    cancelCb: ($modal: JQuery) => void = defaultCancelCb, footer = true) => {\r\n        const $modal = self.makeFormModal(title, successText, form, footer);\r\n\r\n        $modal.on(\"click\", \".btn-cancel\", () => {\r\n            if (typeof cancelCb === \"function\") {\r\n                cancelCb($modal);\r\n            }\r\n            else {\r\n                $modal.modal(\"hide\");\r\n            }\r\n        }).on(\"click\", \".btn-dismiss\", () => {\r\n            $modal.modal(\"hide\");\r\n        }).on(\"click\", \".btn-success\", () => {\r\n            const vals: any[] = [];\r\n            let hasErrors = false;\r\n\r\n            $modal.find(\"input, textarea, select\").each((i, v) => {\r\n                const $v = $(v);\r\n\r\n                if (($v as any).tagName === \"SELECT\") {\r\n                    vals.push($v.find(\":selected\").val());\r\n                }\r\n                else if ($v.attr(\"type\") === \"checkbox\") {\r\n                    vals.push($v.prop(\"checked\"));\r\n                }\r\n                else if ($v.attr(\"type\") === \"file\") {\r\n                    vals.push(($v.get(0) as any).files);\r\n                }\r\n                else if ($v.attr(\"type\") === \"number\") {\r\n                    vals.push(parseFloat($v.val() as string));\r\n                }\r\n                else {\r\n                    vals.push($v.val());\r\n                }\r\n\r\n                if ($v.trigger(\"validate\").hasClass(\"is-invalid\")) {\r\n                    hasErrors = true;\r\n                }\r\n\r\n            });\r\n\r\n            if (!hasErrors && typeof successCb === \"function\") {\r\n                successCb($modal, vals);\r\n            }\r\n        }).on(\"hidden.bs.modal\", () => {\r\n            $modal.remove();\r\n        }).modal(\"show\");\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport help from './genericHelpers';\r\nimport randomColor from 'randomcolor';\r\nimport GraphState, {AddNodeI, GraphStateHistory} from './graphState';\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\nimport {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\n\r\nexport interface MainI {\r\n    graphState: typeof GraphState;\r\n    container: HTMLElement;\r\n    visWeightEdgeEdit: (data: VisEditEdgeInternal, callback: Function) => void;\r\n    visOptions: {\r\n        interaction: { hover: boolean };\r\n        manipulation: {\r\n            addNode: (data: AddNodeI, callback: Function) => void;\r\n            editNode: (data: AddNodeI, callback: Function) => void;\r\n            addEdge: (data: VisEdgeInternal, callback?: Function) => void;\r\n            editEdge: (data: VisEdgeInternal, callback: Function) => void;\r\n            deleteEdge: (data: { edges: string[] }, callback?: Function) => void;\r\n            deleteNode: (data: { nodes: string[] }, callback: Function) => void\r\n        }\r\n    };\r\n    cancelEdit: (callback: Function) => void;\r\n    saveData: (data: any, callback: Function, operation: string, label: string) => void;\r\n    nodeLabelIDValidator: (v: string) => (boolean | string);\r\n    applyColors: () => Promise<void>;\r\n    setData: (data: GraphPlain, recalcProps?: boolean, graphChanged?: boolean, rearrangeGraph?: boolean) => void;\r\n    saveState: () => void;\r\n    getStateForSaving: () => GraphStateHistory;\r\n    undo: () => void;\r\n    redo: () => void;\r\n    applyState: (undo?: boolean, newState?: any) => void;\r\n    saveStateLocalStorage: () => void;\r\n    shuffleNetworkLayout: () => void;\r\n    randomizeNetworkLayoutSeed: (network: VisNetworkInternals) => void;\r\n    addNetworkListeners: (network: vis.Network) => void\r\n}\r\n\r\ninterface VisNetworkEvent {\r\n    edges: vis.DataSet<vis.Edge>;\r\n    nodes: vis.DataSet<vis.Node>;\r\n}\r\n\r\ninterface VisNetworkInternals extends vis.Network {\r\n    layoutEngine: {\r\n        randomSeed: number,\r\n        initialRandomSeed: number\r\n    }\r\n}\r\n\r\ninterface VisEditEdgeInternal {\r\n    from: { id: string | number };\r\n    to: { id: string | number };\r\n    label?: string\r\n}\r\n\r\ninterface VisEdgeInternal {\r\n    from: string | number;\r\n    to: string | number;\r\n    id: string;\r\n    label?: string\r\n}\r\n\r\nconst self: MainI = {\r\n    graphState: GraphState,\r\n    container: document.getElementById('network'),\r\n    // Function used to overwrite the edge edit functionality when weights are active\r\n    visWeightEdgeEdit: (data: VisEditEdgeInternal, callback) => {\r\n        help.showFormModal(($modal, vals) => {\r\n            callback(null);\r\n            $modal.modal(\"hide\");\r\n            const value = parseFloat(vals[0]);\r\n            GraphState.editEdge(data.from.id, data.to.id, value, parseFloat(data.label));\r\n        }, \"Edit Edge\", \"Save\", [\r\n            {\r\n                type: \"numeric\",\r\n                label: \"Weight/Capacity\",\r\n                initialValue: parseFloat(data.label)\r\n            }\r\n        ]);\r\n    },\r\n    visOptions: {\r\n        interaction: {hover: true},\r\n        manipulation: {\r\n            addNode: async (data, callback) => {\r\n                const $popup = help.makeFormModal(\"Add Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: `<p>Node ID: ${await GraphState.getProperty(\"vertices\")}</p>`\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: await GraphState.getProperty(\"vertices\")}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"add\", $popup.find(\"input\").first().val() as string);\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            editNode: (data, callback) => {\r\n                const $popup = help.makeFormModal(\"Edit Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: `<p>Node ID: ${data.id}</p>`\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: data.label}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"editNode\", $popup.find(\"input\").first().val() as string);\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            addEdge: (data, callback) => {\r\n                const apply = () => {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(null);\r\n                    }\r\n                    GraphState.addEdge(data.from, data.to);\r\n                };\r\n                if (data.from === data.to) {\r\n                    if (confirm(\"Do you want to connect the node to itself?\")) {\r\n                        apply();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                apply();\r\n            },\r\n            editEdge: (data, callback) => {\r\n                callback(null);\r\n                self.visOptions.manipulation.deleteEdge({edges: [data.id]});\r\n                self.visOptions.manipulation.addEdge(data);\r\n            },\r\n            deleteEdge: (data, callback) => {\r\n                if (typeof callback === \"function\") {\r\n                    callback(null);\r\n                }\r\n                data.edges.forEach((v: any) => {\r\n                    let weight = null;\r\n                    if (typeof (window.network as any).body.data.edges._data[v].label !== \"undefined\") {\r\n                        weight = parseFloat((window.network as any).body.data.edges._data[v].label);\r\n                    }\r\n\r\n                    GraphState.deleteEdge((window.network as any).body.edges[v].fromId,\r\n                        (window.network as any).body.edges[v].toId, weight);\r\n                });\r\n            },\r\n            deleteNode: (data, callback) => {\r\n                callback(null);\r\n                data.nodes.forEach((v: string) => {\r\n                    GraphState.deleteNode(v);\r\n                });\r\n            },\r\n        },\r\n    },\r\n\r\n    cancelEdit: (callback) => {\r\n        if (typeof callback === \"function\") {\r\n            callback(null);\r\n        }\r\n    },\r\n\r\n    saveData: (data, callback, operation, label) => {\r\n        callback(null);\r\n\r\n        data.label = label;\r\n        if (operation === \"add\") {\r\n            GraphState.addNode(data);\r\n        }\r\n        else if (operation === \"editNode\") {\r\n            GraphState.editNode(data.id, data.label);\r\n        }\r\n    },\r\n\r\n    nodeLabelIDValidator: (v) => {\r\n        if (GraphState.nodeLabelToID(v) > -1) {\r\n            return true;\r\n        }\r\n        return \"Invalid Label or ID\";\r\n    },\r\n\r\n    applyColors: async () => {\r\n        if (window.settings.getOption(\"direction\")) {\r\n            return;\r\n        }\r\n        const graphColors = await GraphState.getProperty(\"graphColoring\", true);\r\n        const chromaticNumber = await GraphState.getProperty(\"Chromatic Number\", true);\r\n\r\n        const colors = randomColor({count: chromaticNumber, luminosity: \"light\"});\r\n        let G = GraphState.graph;\r\n        (G.getAllNodes() as NodeImmutPlain[]).forEach((v) => {\r\n            G = G.editNode(v.id, {color: colors[graphColors[v.id]]});\r\n        });\r\n        self.setData(GraphState.getGraphData(G), false, false);\r\n    },\r\n\r\n    setData: (data, recalcProps = false, graphChanged = true, rearrangeGraph = false) => {\r\n        // Store existing positions in the data if we're supposed to keep the layout\r\n        if (rearrangeGraph) {\r\n            data.nodes.forEach((v) => {\r\n                delete v.x;\r\n                delete v.y;\r\n            });\r\n        }\r\n\r\n        if (graphChanged) {\r\n            self.saveState();\r\n        }\r\n\r\n        if (\"directed\" in data) {\r\n            window.settings.changeOption(\"direction\", data.directed);\r\n        }\r\n        if (\"weighted\" in data) {\r\n            window.settings.changeOption(\"weights\", data.weighted);\r\n        }\r\n        const directional = window.settings.getOption(\"direction\") as boolean;\r\n        const weighted = window.settings.getOption(\"weights\") as boolean;\r\n\r\n        const g = new GraphImmut(data.nodes, data.edges, directional, weighted);\r\n        GraphState.graph = g;\r\n\r\n        // Set a new random seed so that the layout will be different\r\n        self.randomizeNetworkLayoutSeed(window.network as VisNetworkInternals);\r\n        window.network.setData(GraphState.getGraphAsDataSet(g));\r\n        GraphState.graph = GraphState.setLocations(window.network.getPositions());\r\n\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        if (graphChanged) {\r\n            window.ui.stopLoadingAnimation();\r\n            window.ui.isRunning = {};\r\n            window.ui.terminateAllWebWorkers();\r\n            window.ui.printGraphAlgorithms();\r\n            help.printout(\"\");\r\n            GraphState.setUpToDate();\r\n            GraphState.makeAndPrintProperties(recalcProps);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveState: () => {\r\n        if (GraphState.graph === null) {\r\n            return;\r\n        }\r\n\r\n        if (GraphState.backHistory.length >= GraphState.maxHistory) {\r\n            GraphState.backHistory.shift();\r\n        }\r\n\r\n        GraphState.backHistory.push(self.getStateForSaving());\r\n        GraphState.forwardHistory = [];\r\n        document.getElementsByClassName(\"icon-undo\").item(0).parentElement.parentElement.classList.add(\"active\");\r\n    },\r\n\r\n    getStateForSaving: () => {\r\n        const state: any = {};\r\n        Object.keys(GraphState).forEach((k: string) => {\r\n            const v: any = (GraphState as any)[k];\r\n            if (typeof v !== \"function\") {\r\n                if (typeof v !== \"object\") {\r\n                    state[k] = v;\r\n                }\r\n                else {\r\n                    if (k === \"graph\" && v !== null) {\r\n                        state[k] = v;\r\n                    }\r\n                    if (!k.toLowerCase().includes(\"history\")) {\r\n                        state[k] = help.deepCopy(true, Array.isArray(v) ? [] : {}, v);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return state as GraphStateHistory;\r\n    },\r\n\r\n    undo: () => {\r\n        if (GraphState.backHistory.length > 0) {\r\n            self.applyState(true);\r\n        }\r\n    },\r\n\r\n    redo: () => {\r\n        if (GraphState.forwardHistory.length > 0) {\r\n            self.applyState(false);\r\n        }\r\n    },\r\n\r\n    applyState: (undo = true, newState: GraphStateHistory = null) => {\r\n        const firstLoad = newState !== null;\r\n        const currentState = self.getStateForSaving();\r\n\r\n        if (!firstLoad) {\r\n            if (undo) {\r\n                newState = GraphState.backHistory.pop();\r\n            }\r\n            else {\r\n                newState = GraphState.forwardHistory.pop();\r\n            }\r\n        }\r\n\r\n        //@ts-ignore Ignore accessing private props. I do this because saving the state lost the type of the data\r\n        newState.graph = new GraphImmut(newState.graph.nodes, newState.graph.edges, newState.graph.directed, newState.graph.weighted);\r\n\r\n        window.settings.changeOption(\"direction\", newState.graph.isDirected());\r\n        window.settings.changeOption(\"weights\", newState.graph.isWeighted());\r\n\r\n        GraphState.graph = newState.graph;\r\n\r\n        window.network.setData(GraphState.getGraphAsDataSet(GraphState.graph));\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        window.ui.printGraphAlgorithms();\r\n        help.printout(\"\");\r\n\r\n        Object.keys(newState).forEach((k: string) => {\r\n            const v = newState[k];\r\n            if (typeof v !== \"object\") {\r\n                (GraphState as any)[k] = v;\r\n            }\r\n            else if (!k.toLowerCase().includes(\"history\") && k.toLowerCase() !== \"graph\") {\r\n                if (k.toLowerCase() === \"uptodate\") {\r\n                    Object.keys((GraphState as any)[k]).forEach((oldKey) => {\r\n                        (GraphState as any)[k][oldKey].upToDate = (v as any)[oldKey].upToDate;\r\n                    });\r\n                }\r\n                else {\r\n                    (GraphState as any)[k] = help.deepCopy(true, (GraphState as any)[k], v);\r\n                }\r\n            }\r\n        });\r\n\r\n        GraphState.makeAndPrintProperties().then(() => {\r\n            if (undo && !firstLoad) {\r\n                document.getElementsByClassName(\"icon-redo\").item(0).parentElement.parentElement.classList.add(\"active\");\r\n                if (GraphState.backHistory.length === 0) {\r\n                    document.getElementsByClassName(\"icon-undo\").item(0).parentElement.parentElement.classList.remove(\"active\");\r\n                }\r\n                GraphState.forwardHistory.push(currentState);\r\n            }\r\n            else if (!undo && !firstLoad) {\r\n                document.getElementsByClassName(\"icon-undo\").item(0).parentElement.parentElement.classList.add(\"active\");\r\n                if (GraphState.forwardHistory.length === 0) {\r\n                    document.getElementsByClassName(\"icon-redo\").item(0).parentElement.parentElement.classList.remove(\"active\");\r\n                }\r\n                GraphState.backHistory.push(currentState);\r\n            }\r\n\r\n            self.saveStateLocalStorage();\r\n        });\r\n    },\r\n\r\n    saveStateLocalStorage: () => {\r\n        if (window.settings.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.lastState\", JSON.stringify(self.getStateForSaving()));\r\n        }\r\n    },\r\n\r\n    shuffleNetworkLayout: () => {\r\n        self.setData({\r\n            nodes: GraphState.graph.getAllNodes() as NodeImmutPlain[],\r\n            edges: GraphState.graph.getAllEdges() as EdgeImmutPlain[]\r\n        }, false, false, true);\r\n    },\r\n\r\n    randomizeNetworkLayoutSeed: (network) => {\r\n        const r = Math.round(Math.random() * 1000000);\r\n        network.layoutEngine.randomSeed = r;\r\n        network.layoutEngine.initialRandomSeed = r;\r\n    },\r\n\r\n    addNetworkListeners: (network) => {\r\n        // Enable edit node/edge when double clicking\r\n        network.on(\"doubleClick\", (p: VisNetworkEvent) => {\r\n            if (window.settings.getOption(\"weights\") && \"edges\" in p && p.edges.length === 1) {\r\n                network.editEdgeMode();\r\n            }\r\n            if (\"nodes\" in p && p.nodes.length === 1) {\r\n                network.editNode();\r\n            }\r\n        });\r\n\r\n        // Save locations of nodes after dragging\r\n        network.on(\"dragEnd\", () => {\r\n            GraphState.graph = GraphState.setLocations(network.getPositions());\r\n            self.saveStateLocalStorage(); // Save the new locations as part of the state\r\n        });\r\n\r\n        // Delete nodes/edges when hit \"Delete\"\r\n        let lastNetworkClickEvent: Event = null;\r\n        network.on('click', (event) => {\r\n            lastNetworkClickEvent = event;\r\n        });\r\n\r\n        // Delete key to delete node or edge\r\n        document.addEventListener('keyup', (key) => {\r\n            if (key.key === \"Delete\" && lastNetworkClickEvent !== null) {\r\n                if (self.container.contains((lastNetworkClickEvent as any).event.target)) {\r\n                    if ((\"edges\" in lastNetworkClickEvent && (lastNetworkClickEvent as any).edges.length === 1)\r\n                        || (\"nodes\" in lastNetworkClickEvent && (lastNetworkClickEvent as any).nodes.length === 1)) {\r\n                        network.deleteSelected();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Undo/Redo keyboard commands\r\n        document.addEventListener(\"keydown\", (e) => {\r\n            if ((e.key.toLowerCase() === 'y' && e.ctrlKey) || (e.key.toLowerCase() === 'z' && e.ctrlKey && e.shiftKey)) {\r\n                self.redo();\r\n            }\r\n            else if (e.key.toLowerCase() === 'z' && e.ctrlKey) {\r\n                self.undo();\r\n            }\r\n        });\r\n\r\n        // When clicking off of the network, remove the Delete functionality\r\n        document.addEventListener(\"click\", (e) => {\r\n            if (self.container !== e.target && !self.container.contains(e.target as Node)) {\r\n                lastNetworkClickEvent = null;\r\n            }\r\n        });\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\nimport GraphState from './graphState';\r\n\r\ninterface SettingsList {\r\n    nodePhysics: boolean;\r\n    direction: boolean;\r\n    weights: boolean;\r\n\r\n    [index: string]: boolean\r\n}\r\n\r\nexport default class Settings {\r\n    private static readonly defaults: SettingsList = {\r\n        nodePhysics: true,\r\n        direction: false,\r\n        weights: false\r\n    };\r\n    private static current: any = {};\r\n\r\n    public static checkForLocalStorage() {\r\n        try {\r\n            const x = '__storage_test__';\r\n            localStorage.setItem(x, x);\r\n            localStorage.removeItem(x);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static saveSettings() {\r\n        if (Settings.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.settings\", JSON.stringify(Settings.current));\r\n        }\r\n    }\r\n\r\n    public static loadSettings() {\r\n        if (Settings.checkForLocalStorage()) {\r\n            Settings.current = JSON.parse(localStorage.getItem(\"graphPlayground.settings\"));\r\n        }\r\n        if (Settings.current === null) {\r\n            Settings.current = {};\r\n        }\r\n        Settings.setAll();\r\n    }\r\n\r\n    public static setAll() {\r\n        window.network.setOptions({nodes: {physics: Settings.getOption(\"nodePhysics\") as boolean}});\r\n        window.network.setOptions({edges: {arrows: {to: Settings.getOption(\"direction\") as boolean}}});\r\n        if (Settings.getOption(\"weights\")) {\r\n            window.network.setOptions({\r\n                manipulation: {\r\n                    editEdge: {\r\n                        editWithoutDrag: window.main.visWeightEdgeEdit\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            window.network.setOptions({manipulation: {editEdge: window.main.visOptions.manipulation.editEdge}});\r\n        }\r\n    }\r\n\r\n    public static changeOption(option: string, value: string | boolean): void {\r\n        Settings.current[option] = value;\r\n        Settings.saveSettings();\r\n        Settings.setAll();\r\n    }\r\n\r\n    public static getOption(option: string): string | boolean {\r\n        if (option in Settings.current) {\r\n            return Settings.current[option];\r\n        }\r\n        return Settings.defaults[option];\r\n    }\r\n\r\n    public static resetToDefault(): void {\r\n        Settings.current = {};\r\n        Settings.saveSettings();\r\n        Settings.setAll();\r\n\r\n        // Reset graph to just a plain graph. Not sure if this should actually happen or not.\r\n        const G = GraphState.graph.asChangedDirectedWeighted(Settings.defaults.direction, Settings.defaults.weights);\r\n        window.main.setData(GraphState.getGraphData(G));\r\n    }\r\n}\r\n","import gHelp from \"./graphHelpers\";\nimport help from \"./genericHelpers\";\nimport GraphState from './graphState';\nimport {FlowResult, MSTResult, ShortestPathResult} from \"./GraphAlgorithms\";\n//@ts-ignore\nimport Worker from 'worker-loader!./GraphAlgorithmWorker';\nimport NodeImmut from \"./GraphImmut/NodeImmut\";\nimport EdgeImmut from \"./GraphImmut/EdgeImmut\";\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\n\ninterface AlgorithmI {\n    name: string;\n    directional?: boolean;\n    weighted?: boolean;\n    applyFunc: () => any;\n    display: boolean\n}\n\nconst makeAndPrintShortestPath = (title: string,\n                                  fn: string,\n                                  weighted: boolean): void => {\n    const myName = \"Shortest Path\";\n    if(UIInteractions.isRunning[myName]){\n        UIInteractions.printAlreadyRunning(myName);\n        return;\n    }\n    UIInteractions.isRunning[myName] = true;\n\n    help.showFormModal(($modal, values) => {\n            $modal.modal(\"hide\");\n\n            const source = GraphState.nodeLabelToID(values[0]);\n            const sink = GraphState.nodeLabelToID(values[1]);\n\n            const iStartedProgress = UIInteractions.startLoadingAnimation();\n            const w = UIInteractions.getWorkerIfPossible((e) => {\n                let a = e.data;\n                w.cleanup();\n                if(iStartedProgress){\n                    UIInteractions.stopLoadingAnimation();\n                }\n                UIInteractions.isRunning[myName] = false;\n\n                if (a === false) {\n                    if (title.includes(\"Dijkstra\")) {\n                        help.showSimpleModal(\"Dijkstra Error\", \"<p>The Dijkstra algorithm only works on graphs\" +\n                            \" with totally non-negative edge weights. Please fix the graph so that there are no\" +\n                            \" negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves\" +\n                            \" exactly this problem.</p>\");\n                    }\n                    else if (title.includes(\"Bellman\")) {\n                        help.showSimpleModal(\"Bellman-Ford Error\", \"<p>The Bellman-Ford algorithm only works on graphs\" +\n                            \" with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>\");\n                    }\n                    return;\n                }\n\n                a = a as ShortestPathResult;\n\n                let p = `<h3>${title}</h3><hr>No path exists from ${help.htmlEncode(source.toString())} to ${help.htmlEncode(sink.toString())}`;\n\n                if (a.pathExists) {\n                    p = `${title} From ${GraphState.nodeIDToLabel(source)} to `;\n                    p += `${GraphState.nodeIDToLabel(sink)}: ${a.distance}`;\n                    if (weighted) {\n                        p += `\\nWith weighted cost: ${a.cost}`;\n                    }\n                    p += \"\\n\\nUsing Path: \";\n\n                    p = help.htmlEncode(p);\n                    let graph = GraphState.getGraphData(GraphState.graph, false, true);\n                    let G = new GraphImmut(graph.nodes, graph.edges, graph.directed, graph.weighted);\n                    a.path.forEach((v: number, i: number) => {\n                        p += `${help.htmlEncode(GraphState.nodeIDToLabel(v))} &rarr; `;\n                        if(i > 0) {\n                            G = G.editEdge(a.path[i - 1], v, null, null, '#FF0000') as GraphImmut;\n                        }\n                    });\n                    GraphState.graph = G;\n                    window.main.setData(GraphState.getGraphData(G),\n                        false, false, false);\n                    p = p.slice(0, -8);\n                    p = `<h3>${title}</h3><hr>${p}`;\n                }\n\n                help.printout(p);\n            });\n            w.send({\n                type: fn,\n                args: [source, sink],\n                convertToGraphImmut: true,\n                graph: window.main.graphState.getGraphData()\n            });\n        },\n        title, \"Go\", [\n            {label: \"Start Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n            {label: \"End Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n        ]);\n};\n\nconst makeAndPrintComponents = async (stronglyConnected: boolean): Promise<void> => {\n    let a = null;\n    let cc = \"Connected Components\";\n    let componentKey = \"connectedComponents\";\n\n    if (stronglyConnected) {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        cc = \"Strongly \" + cc;\n        componentKey = \"stronglyConnectedComponents\";\n    }\n    else {\n        if (window.settings.getOption(\"direction\")) {\n            return;\n        }\n    }\n\n    if(UIInteractions.isRunning[cc]){\n        UIInteractions.printAlreadyRunning(cc);\n        return Promise.reject(\"Already Running\");\n    }\n    UIInteractions.isRunning[cc] = true;\n\n    const iStartedProgress = UIInteractions.startLoadingAnimation();\n    const w = UIInteractions.getWorkerIfPossible((e) => {\n        a = e.data;\n        w.cleanup();\n\n        GraphState.graphProperties[cc] = a.count;\n        GraphState.setUpToDate(true, [cc, componentKey]);\n        GraphState.state[componentKey] = a.components;\n\n        const components = help.flatten(a.components);\n        let p = `Number of ${cc}: ${a.count}`;\n        p += \"\\n\\n\";\n\n        components.forEach((v, i) => {\n            p += `Vertex ${GraphState.nodeIDToLabel(i)} is in connected component #${v}\\n`;\n        });\n\n        p += `\\n${JSON.stringify(help.rotate(a.components), null, 4)}\\n\\n`;\n        p = `<h3>${cc}</h3><hr>${help.htmlEncode(p)}`;\n\n        if(iStartedProgress){\n            UIInteractions.stopLoadingAnimation();\n        }\n        UIInteractions.isRunning[cc] = false;\n\n        help.printout(p);\n    });\n    w.send({\n        type: componentKey,\n        args: [],\n        graph: window.main.graphState.getGraphData(),\n        convertToGraphImmut: true\n    });\n};\n\nclass WorkerProxy {\n    private readonly worker: Worker;\n    private readonly id: number;\n    private readonly listener: (e: { data: any }) => any;\n\n    constructor(id: number, w: Worker, listener: ((e: { data: any }) => any)) {\n        this.id = id;\n        this.worker = w;\n        this.listener = listener;\n        w.postMessage({type: \"id\", id});\n        w.onmessage = (e: MessageEvent) => {\n            this.listener({data: e.data.data});\n        };\n    }\n\n    public send(data: any) {\n        this.worker.postMessage(data);\n    }\n\n    public cleanup() {\n        this.worker.terminate();\n        GraphState.workerPool[this.id] = null;\n    }\n}\n\nexport default class UIInteractions {\n    public static isRunning: {[index: string]: boolean} = {};\n    static getAlgorithms(): AlgorithmI[] {\n        return [\n            {\n                name: \"Graph Coloring\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintGraphColoring,\n                display: true\n            },\n            {\n                name: \"Connected Components\",\n                directional: false,\n                applyFunc: () => {\n                    makeAndPrintComponents(false);\n                },\n                display: true\n            },\n            {\n                name: \"Strongly Connected Components\",\n                directional: true,\n                display: true,\n                applyFunc: () => {\n                    makeAndPrintComponents(true);\n                }\n            },\n            {\n                name: \"Breadth-First Shortest Path\",\n                directional: false,\n                applyFunc: () => {\n                    makeAndPrintShortestPath(\"Breadth-First Shortest Path\", \"breadthFirstSearch\", false);\n                },\n                display: true\n            },\n            {\n                name: \"Dijkstra Shortest Path\",\n                applyFunc: () => {\n                    makeAndPrintShortestPath(\"Dijkstra Shortest Path\", \"dijkstraSearch\", true);\n                },\n                display: true\n            },\n            {\n                name: \"Bellman-Ford Shortest Path\",\n                weighted: true,\n                directional: true,\n                applyFunc: () => {\n                    makeAndPrintShortestPath(\"Bellman-Ford Shortest Path\", \"bellmanFord\", true);\n                },\n                display: true\n            },\n            {\n                name: \"Ford-Fulkerson\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintFFMCMF,\n                display: true\n            },\n            {\n                name: \"Kruskal Minimum Spanning Tree\",\n                weighted: true,\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintKruskal,\n                display: true\n            },\n            {\n                name: \"Cyclic\",\n                applyFunc: UIInteractions.makeAndPrintIsCyclic,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Topological Sort\",\n                applyFunc: UIInteractions.makeAndPrintTopologicalSort,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Eulerian\",\n                directional: false,\n                display: false,\n                applyFunc: null\n            },\n            {\n                name: \"Eulerian\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintDirectionalEulerian\n            }\n        ] as AlgorithmI[];\n    }\n\n    static registerListeners(): void {\n        const makeSimpleClickListener = (selector: string, fn: () => any) => {\n            document.querySelector(selector).addEventListener(\"click\", (e) => {\n                e.preventDefault();\n                fn();\n            });\n        };\n\n        makeSimpleClickListener(\"#print-help-link\", UIInteractions.printHelp);\n        makeSimpleClickListener(\"#graph-options-link\", UIInteractions.printOptions);\n        makeSimpleClickListener(\"#load-petersen-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            window.main.setData(predefined.Petersen(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-konigsberg-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            window.main.setData(predefined.Konigsberg(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-complete-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Complete();\n        });\n        makeSimpleClickListener(\"#load-hypercube-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Hypercube();\n        });\n        makeSimpleClickListener(\"#load-custom-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Custom();\n        });\n        makeSimpleClickListener(\"#undo-link\", window.main.undo);\n        makeSimpleClickListener(\"#redo-link\", window.main.redo);\n        makeSimpleClickListener(\"#calculate-all-properties-link\", async () => {\n            return GraphState.makeAndPrintProperties(true);\n        });\n        makeSimpleClickListener(\"#new-graph-layout-link\", window.main.shuffleNetworkLayout);\n        makeSimpleClickListener(\"#import-file-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeImportFileModal();\n        });\n        makeSimpleClickListener(\"#import-text-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeImportTextModal();\n        });\n        makeSimpleClickListener(\"#export-file-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeExportFileModal();\n        });\n        makeSimpleClickListener(\"#export-text-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeExportTextModal();\n        });\n    }\n\n    static printHelp(): void {\n        help.showSimpleModal(\"Help\", \"<h4>For support see the <a href='https://github.com/MikeDombo/graphPlayground' \" +\n            \"target='_blank'>GitHub repository</a> for guides</h4> <h4>See \" +\n            \"<a href='https://github.com/MikeDombo/graphPlayground/issues' target='_blank'>GitHub issues</a>\" +\n            \" to submit bugs or feature requests.</h4>\");\n    }\n\n    static printOptions(): void {\n        help.showFormModal(\n            ($modal, vals) => {\n                $modal.modal(\"hide\");\n                if (window.settings.getOption(\"nodePhysics\") !== vals[0]) {\n                    window.settings.changeOption(\"nodePhysics\", vals[0]); // Physics\n                }\n                if (window.settings.getOption(\"direction\") !== vals[1]) {\n                    window.settings.changeOption(\"direction\", vals[1]);\n                    let G = GraphState.graph;\n                    G = vals[1] ? G.asDirected(true) : G.asUndirected();\n                    // Clear node coloring because graph color doesn't apply to directed graphs\n                    window.main.setData(GraphState.getGraphData(G, true));\n                }\n                if (window.settings.getOption(\"weights\") !== vals[2]) {\n                    window.settings.changeOption(\"weights\", vals[2]);\n                    let G = GraphState.graph;\n                    G = vals[2] ? G.asWeighted() : G.asUnweighted();\n                    window.main.setData(GraphState.getGraphData(G));\n                }\n            },\n            \"Options\", \"Save\", [\n                {label: \"Graph Physics\", initialValue: window.settings.getOption(\"nodePhysics\"), type: \"checkbox\"},\n                {label: \"Directed Graph\", initialValue: window.settings.getOption(\"direction\"), type: \"checkbox\"},\n                {label: \"Weighted Graph\", initialValue: window.settings.getOption(\"weights\"), type: \"checkbox\"}\n            ], null);\n    }\n\n    static terminateAllWebWorkers(): void {\n        for(const v of GraphState.workerPool){\n            if (v instanceof window.Worker) {\n                v.terminate();\n            }\n        }\n        GraphState.workerPool = [];\n    }\n\n    static getWorkerIfPossible(onmessage: (d: { data: any }) => any): WorkerProxy {\n        let nextIndex = GraphState.workerPool.findIndex((v) => {\n            return v === null || typeof v === 'undefined';\n        });\n        if(nextIndex === -1){\n            nextIndex = GraphState.workerPool.length;\n        }\n\n        const w = new Worker();\n        GraphState.workerPool[nextIndex] = w;\n        return new WorkerProxy(nextIndex, w, onmessage);\n    }\n\n    static startLoadingAnimation() {\n        const prog = document.getElementById(\"task-spinner\");\n        if(prog.style.display !== \"flex\"){\n            prog.style.display =  \"flex\";\n            return true;\n        }\n        return false;\n    }\n\n    static stopLoadingAnimation() {\n        const prog = document.getElementById(\"task-spinner\");\n        if(prog.style.display !== \"none\"){\n            prog.style.display =  \"none\";\n        }\n    }\n\n    static printAlreadyRunning(name?: string){\n        let n = \"This task\";\n        if(name){\n            n = name;\n        }\n        help.showSimpleModal(\"Task Already Running\", \"<p>\" + n + \" is already running, please wait for it to finish\" +\n            \" first.</p>\");\n    }\n\n    static makeAndPrintGraphColoring(): Promise<void> {\n        const myName = \"Graph Coloring\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return Promise.reject(\"Already Running\");\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        return new Promise<void>(async (resolve) => {\n            if (window.settings.getOption(\"direction\")) {\n                UIInteractions.isRunning[myName] = false;\n                return resolve();\n            }\n\n            // Use cached responses when able\n            let a = {\n                chromaticNumber: (await GraphState.getProperty(\"Chromatic Number\")) as number,\n                colors: GraphState.state.graphColoring as {}\n            };\n\n            const printGC = () => {\n                GraphState.graphProperties[\"Chromatic Number\"] = a.chromaticNumber;\n                GraphState.setUpToDate(true, [\"Chromatic Number\", \"graphColoring\"]);\n                (GraphState.state.graphColoring as {}) = a.colors;\n\n                const colors = help.flatten(a.colors);\n                let p = `Number of Vertices: ${colors.length}`;\n                p += `\\nChromatic Number: ${a.chromaticNumber}`;\n                p += \"\\n\\n\";\n\n                colors.forEach((v, i) => {\n                    p += `Vertex ${GraphState.nodeIDToLabel(i)} gets color ${v}\\n`;\n                });\n\n                p += `\\n${JSON.stringify(help.rotate(a.colors), null, 4)}\\n\\n`;\n\n                p = `<h3>Graph Coloring Using Welsh-Powell Algorithm</h3><hr>${help.htmlEncode(p)}`;\n                p += \"<br/><button class='btn btn-primary' onclick='main.applyColors()'>Apply New Colors To Graph</button>\";\n\n                help.printout(p);\n                window.main.applyColors();\n            };\n\n            const iStartedProgress = UIInteractions.startLoadingAnimation();\n\n            if (!(a.chromaticNumber !== null && (await GraphState.getProperty(\"graphColoring\")) !== null)) {\n                const w = UIInteractions.getWorkerIfPossible((e) => {\n                    a = e.data;\n                    printGC();\n                    w.cleanup();\n                    if(iStartedProgress) {\n                        UIInteractions.stopLoadingAnimation();\n                    }\n                    UIInteractions.isRunning[myName] = false;\n                    resolve(e.data);\n                });\n                w.send({\n                    type: \"colorNetwork\",\n                    args: [],\n                    graph: window.main.graphState.getGraphData(),\n                    convertToGraphImmut: true\n                });\n            }\n            else {\n                printGC();\n                if(iStartedProgress) {\n                    UIInteractions.stopLoadingAnimation();\n                }\n            }\n        });\n    }\n\n    static makeAndPrintDirectionalEulerian(): Promise<void> {\n        const myName = \"Eulerian\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return Promise.reject(\"Already Running\");\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        return new Promise<void>(async (resolve) => {\n            if (!window.settings.getOption(\"direction\")) {\n                UIInteractions.isRunning[myName] = false;\n                return resolve();\n            }\n\n            const iStartedProgress = UIInteractions.startLoadingAnimation();\n            const w = UIInteractions.getWorkerIfPossible((e) => {\n                GraphState.graphProperties.eulerian = e.data;\n                GraphState.setUpToDate(true, [\"eulerian\"]);\n                w.cleanup();\n                if(iStartedProgress) {\n                    UIInteractions.stopLoadingAnimation();\n                }\n                UIInteractions.isRunning[myName] = false;\n                resolve(e.data);\n            });\n\n            const scc = await GraphState.getProperty(\"stronglyConnectedComponents\", true);\n\n            w.send({\n                type: \"directionalEulerian\",\n                args: [gHelp.findVertexDegreesDirectional(GraphState.graph.getFullAdjacency()), scc]\n            });\n        });\n    }\n\n    static makeAndPrintEulerian(ignoreDuplicate = false): Promise<void> {\n        const myName = \"Eulerian\";\n        if(UIInteractions.isRunning[myName]){\n            if(ignoreDuplicate){\n                return;\n            }\n            UIInteractions.printAlreadyRunning(myName);\n            return Promise.reject(\"Already Running\");\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        return new Promise<void>(async (resolve) => {\n            if (window.settings.getOption(\"direction\")) {\n                UIInteractions.isRunning[myName] = false;\n                return resolve(UIInteractions.makeAndPrintDirectionalEulerian());\n            }\n\n            const iStartedProgress = UIInteractions.startLoadingAnimation();\n            const cc = await GraphState.getProperty(\"connectedComponents\", true);\n\n            const w = UIInteractions.getWorkerIfPossible((e) => {\n                GraphState.graphProperties.eulerian = e.data;\n                GraphState.setUpToDate(true, [\"eulerian\"]);\n                if(iStartedProgress){\n                    UIInteractions.stopLoadingAnimation();\n                }\n                UIInteractions.isRunning[myName] = false;\n                w.cleanup();\n                resolve(e.data);\n            });\n            w.send({type: \"hasEulerianCircuit\", args: [GraphState.graph.getAllOutDegrees(), cc]});\n        });\n    }\n\n    static makeAndPrintFFMCMF(): void {\n        if (!window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n        const myName = \"Ford-Fulkerson\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return;\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        help.showFormModal(async ($modal, values) => {\n                $modal.modal(\"hide\");\n\n                const source = GraphState.nodeLabelToID(values[0]);\n                const sink = GraphState.nodeLabelToID(values[1]);\n\n                let a: (boolean | FlowResult) = null;\n\n                const cb = () => {\n                    let p = `<h3>Ford-Fulkerson</h3><hr>No path exists from `;\n                    p += `${help.htmlEncode(GraphState.nodeIDToLabel(source))} to ${help.htmlEncode(GraphState.nodeIDToLabel(sink))}`;\n\n                    if (a === false) {\n                        help.printout(p);\n                        return;\n                    }\n                    a = a as { maxFlow: number; flowPath: any[] };\n\n                    p = `Ford-Fulkerson MaxFlow-MinCut Max Flow From ${GraphState.nodeIDToLabel(source)} `;\n                    p += `to ${GraphState.nodeIDToLabel(sink)}: ${a.maxFlow}`;\n                    p += \"\\n\\nUsing Capacities:\\n\\n\";\n                    p = help.htmlEncode(p);\n                    a.flowPath.forEach((v) => {\n                        p += `${GraphState.nodeIDToLabel(v.from)}&rarr;${GraphState.nodeIDToLabel(v.to)} using ${v.flow} of ${v.capacity}\\n`;\n                    });\n                    p = p.trim();\n                    p = \"<h3>Ford-Fulkerson MaxFlow-MinCut</h3><hr>\" + p;\n\n                    help.printout(p);\n                };\n\n                const iStartedProgress = UIInteractions.startLoadingAnimation();\n                const w = UIInteractions.getWorkerIfPossible((e) => {\n                    a = e.data;\n                    UIInteractions.isRunning[myName] = false;\n                    cb();\n                    if(iStartedProgress){\n                        UIInteractions.stopLoadingAnimation();\n                    }\n                    w.cleanup();\n                });\n                w.send({\n                    type: \"fordFulkerson\",\n                    args: [source, sink],\n                    convertToGraphImmut: true,\n                    graph: window.main.graphState.getGraphData()\n                });\n            },\n            \"Ford-Fulkerson MaxFlow-MinCut\", \"Go\", [\n                {label: \"Source Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n                {label: \"Sink Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n            ]);\n    }\n\n    static makeAndPrintKruskal(): void {\n        if (window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n\n        const myName = \"Kruskal\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return;\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        const iStartedProgress = UIInteractions.startLoadingAnimation();\n        const w = UIInteractions.getWorkerIfPossible((e) => {\n            const a: MSTResult = e.data;\n            w.cleanup();\n\n            let p = `Kruskal's Minimum Spanning Tree Total Weight: ${a.totalWeight}`;\n            p += \"\\n\\nUsing Edges:\\n\\n\";\n            p = help.htmlEncode(p);\n            a.mst.forEach((v) => {\n                //@ts-ignore\n                p += `${GraphState.nodeIDToLabel((new EdgeImmut(v)).getFrom())}&rarr;`;\n                //@ts-ignore\n                p += `${GraphState.nodeIDToLabel((new EdgeImmut(v)).getTo())}\\n`;\n            });\n            p = p.trim();\n            p = `<h3>Kruskal Minimum Spanning Tree</h3><hr>${p}`;\n\n            if(iStartedProgress){\n                UIInteractions.stopLoadingAnimation();\n            }\n            UIInteractions.isRunning[myName] = false;\n\n            help.printout(p);\n        });\n        w.send({\n            type: \"kruskal\",\n            args: [],\n            convertToGraphImmut: true,\n            graph: window.main.graphState.getGraphData()\n        });\n    }\n\n    static makeAndPrintIsCyclic(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n\n        const myName = \"Cyclic\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return Promise.reject(\"Already Running\");\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        return new Promise<void>((resolve) => {\n            const iStartedProgress = UIInteractions.startLoadingAnimation();\n            const w = UIInteractions.getWorkerIfPossible((e) => {\n                GraphState.graphProperties.cyclic = e.data;\n                GraphState.setUpToDate(true, [\"cyclic\"]);\n                w.cleanup();\n                if(iStartedProgress){\n                    UIInteractions.stopLoadingAnimation();\n                }\n                UIInteractions.isRunning[myName] = false;\n                resolve();\n            });\n            w.send({\n                type: \"isGraphCyclic\",\n                args: [],\n                convertToGraphImmut: true,\n                graph: window.main.graphState.getGraphData()\n            });\n        });\n    }\n\n    static makeAndPrintTopologicalSort(): void {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n\n        const myName = \"Topological Sort\";\n        if(UIInteractions.isRunning[myName]){\n            UIInteractions.printAlreadyRunning(myName);\n            return;\n        }\n        UIInteractions.isRunning[myName] = true;\n\n        const iStartedProgress = UIInteractions.startLoadingAnimation();\n        const w = UIInteractions.getWorkerIfPossible((e) => {\n            const a: boolean | NodeImmut[] = e.data;\n            w.cleanup();\n\n            if(iStartedProgress){\n                UIInteractions.stopLoadingAnimation();\n            }\n            UIInteractions.isRunning[myName] = false;\n\n            if (a === true) {\n                GraphState.graphProperties.cyclic = true;\n                GraphState.setUpToDate(true, [\"cyclic\"]);\n                help.printout(\"<h3>Topological Sorting Failed</h3><hr>Topological sorting failed because the graph contains a cycle\");\n\n                return;\n            }\n\n            let p = \"Topological Sorting:\\n\\n\";\n            p = help.htmlEncode(p);\n            (a as any[]).forEach((v) => {\n                p += `${GraphState.nodeIDToLabel(v.id)}, `;\n            });\n            p = p.slice(0, -2);\n            p = `<h3>Topological Sorting</h3><hr>${p}`;\n\n            help.printout(p);\n        });\n        w.send({\n            type: \"topologicalSort\",\n            args: [],\n            convertToGraphImmut: true,\n            graph: window.main.graphState.getGraphData()\n        });\n    }\n\n    static printGraphAlgorithms(): void {\n        const $div = document.getElementById(\"algorithms-pane\");\n        $div.innerHTML = \"\";\n        const directional = window.settings.getOption(\"direction\");\n        const weighted = window.settings.getOption(\"weights\");\n\n        const addAlgoToPane = (alg: AlgorithmI) => {\n            const navlink = document.createElement('a');\n            navlink.classList.add(\"nav-link\");\n            navlink.setAttribute(\"href\", \"#\");\n            navlink.innerText = alg.name;\n            navlink.addEventListener(\"click\", (e) => {\n                e.preventDefault();\n                alg.applyFunc();\n            });\n\n            $div.appendChild(navlink);\n        };\n\n        const a = UIInteractions.getAlgorithms();\n        a.forEach((alg) => {\n            if (!alg.display) {\n                return;\n            }\n            if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n            else if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n        });\n    }\n}\n","\"use strict\";\r\n\r\nimport 'bootstrap';\r\nimport * as Raven from 'raven-js';\r\nimport {Network} from 'vis/index-network';\r\nimport {default as main, MainI} from './main';\r\nimport Settings from './settings';\r\nimport UI from './UIInteractions';\r\n\r\ndeclare global {\r\n    interface Window {\r\n        main: MainI;\r\n        network: Network;\r\n        settings: typeof Settings;\r\n        ui: typeof UI,\r\n        Raven: Raven.RavenStatic,\r\n        Worker: Function\r\n    }\r\n}\r\n\r\nwindow.main = main;\r\nwindow.network = new Network(main.container, {}, main.visOptions);\r\nwindow.settings = Settings;\r\nwindow.ui = UI;\r\n\r\n// Initialize Sentry.io error logging\r\nRaven.config('https://92aaeee7e2fb4ef4837a2261a029e8ed@sentry.home.mikedombrowski.com/2').install();\r\nwindow.Raven = Raven;\r\n\r\nmain.addNetworkListeners(window.network);\r\n\r\nSettings.loadSettings();\r\n\r\nlet loadDefault = true;\r\nif (Settings.checkForLocalStorage()) {\r\n    const s: string = localStorage.getItem(\"graphPlayground.lastState\");\r\n    if (s !== null) {\r\n        const jsonGraph: any = JSON.parse(s);\r\n        if (\"graph\" in jsonGraph && \"nodes\" in jsonGraph.graph) {\r\n            loadDefault = false;\r\n            main.applyState(false, jsonGraph as {graph: GraphPlain});\r\n        }\r\n    }\r\n}\r\nif (loadDefault) {\r\n    (async () => {\r\n        const predefined = (await import(\"./predefinedGraphs\")).default;\r\n        main.setData(predefined.Petersen(), false, true, true);\r\n    })();\r\n}\r\n\r\nwindow.ui.registerListeners();\r\n","\"use strict\";\r\n\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\nimport {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\n\r\ninterface Degree {\r\n    in: number;\r\n    out: number;\r\n}\r\n\r\nexport default {\r\n    findVertexDegreesDirectional: (adjacencyMatrix: Array<Array<number>>): Degree[] => {\r\n        // Adjacency stores IDs of edges TO\r\n        const degrees: Degree[] = [];\r\n        adjacencyMatrix.forEach((v, i) => {\r\n            if (i in degrees) {\r\n                degrees[i].out += v.length;\r\n            }\r\n            else {\r\n                degrees[i] = {out: v.length, in: 0};\r\n            }\r\n            v.forEach((outV) => {\r\n                if (outV in degrees) {\r\n                    degrees[outV].in += 1;\r\n                }\r\n                else {\r\n                    degrees[outV] = {in: 1, out: 0};\r\n                }\r\n            });\r\n        });\r\n\r\n        return degrees;\r\n    },\r\n\r\n    interpolateNodesFromEdges: (edges: EdgeImmutPlain[]): NodeImmutPlain[] => {\r\n        const nodes: NodeImmutPlain[] = [];\r\n        edges.forEach((v) => {\r\n            nodes[v.from] = {id: v.from, label: v.from.toString()};\r\n            nodes[v.to] = {id: v.to, label: v.to.toString()};\r\n        });\r\n\r\n        return nodes;\r\n    },\r\n};\r\n","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"48beb18c6361c90c0b89.worker.js\");\n};","\"use strict\";\n\nexport interface EdgeImmutPlain {\n    label?: string;\n    from: number;\n    to: number;\n    weight: number\n\n    [key: string]: any;\n\n    [key: number]: any\n}\n\nexport default class EdgeImmut {\n    private readonly from: Readonly<number>;\n    private readonly to: Readonly<number>;\n    private readonly weight: Readonly<number>;\n    private readonly attributes: any;\n\n    constructor(from: number | EdgeImmutPlain, to?: number, weight: any = 1, extraAttrs: any = null) {\n        if (typeof from === \"object\") {\n            extraAttrs = Object.keys(from)\n                .filter((key) => !['from', 'to', 'weight'].includes(key))\n                .reduce((obj: any, key: string) => {\n                    obj[key] = (<EdgeImmutPlain> from)[key];\n                    return obj;\n                }, {});\n\n            to = from.to;\n            weight = from.weight;\n            from = from.from;\n        }\n\n        this.attributes = {};\n        if (extraAttrs !== null && typeof extraAttrs === \"object\") {\n            Object.keys(extraAttrs).forEach((key) => {\n                this.attributes[key] = Object.freeze(extraAttrs[key]);\n            });\n        }\n\n        this.attributes = Object.freeze(this.attributes);\n        this.from = Object.freeze(from);\n        this.to = Object.freeze(to);\n        this.weight = Object.freeze(parseFloat(weight));\n\n        if (new.target === EdgeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    getFrom(): Readonly<number> {\n        return this.from;\n    }\n\n    getTo(): Readonly<number> {\n        return this.to;\n    }\n\n    getWeight(): Readonly<number> {\n        return this.weight;\n    }\n\n    getAttribute(attribute: string | number): any {\n        if (attribute in this.attributes) {\n            return this.attributes[attribute];\n        }\n\n        return null;\n    }\n\n    getAllAttributes(): { [key: string]: any; [key: number]: any } {\n        return this.attributes;\n    }\n\n    toPlain(): EdgeImmutPlain {\n        const toReturn: EdgeImmutPlain = {from: this.from, to: this.to, weight: this.weight};\n        Object.keys(this.attributes).forEach((key) => {\n            if (!(key in toReturn)) {\n                toReturn[key] = this.attributes[key];\n            }\n        });\n\n        return toReturn;\n    }\n\n    editEdge(newWeight: number, extraAttrs: any = {}): EdgeImmut {\n        // Merge existing and new attributes favoring the new\n        const attributes = Object.assign({}, this.attributes);\n        Object.keys(extraAttrs).forEach((key) => {\n            attributes[key] = extraAttrs[key];\n        });\n\n        return new EdgeImmut(this.getFrom(), this.getTo(),\n            newWeight === null ? this.getWeight() : newWeight, attributes);\n    }\n}\n","\"use strict\";\n\nimport {List} from 'immutable';\nimport {default as NodeImmut, NodeImmutPlain} from './NodeImmut';\nimport {default as EdgeImmut, EdgeImmutPlain} from './EdgeImmut';\n\ninterface NodeMapping {\n    [key: number]: number\n}\n\nconst filterExtraAttr = (data: any, labels: any) => {\n    return Object.keys(data)\n        .filter((key) => !(labels).includes(key))\n        .reduce((obj: any, key) => {\n            obj[key] = data[key];\n            return obj;\n        }, {});\n};\n\nconst filterNodeExtraAttr = (data: any) => {\n    return filterExtraAttr(data, [\"label\", \"id\"]);\n};\n\nconst filterEdgeExtraAttr = (data: any) => {\n    return filterExtraAttr(data, [\"from\", \"to\", \"weight\"]);\n};\n\nconst genericEdgesToImmutEdges = (edges: any, nodeMap: NodeMapping = {}): boolean | List<EdgeImmut> => {\n    if (edges === null) {\n        return false;\n    }\n\n    let newEdges: List<EdgeImmut> = List();\n\n    if (typeof edges === 'object') {\n        edges.forEach((edge: any) => {\n            let weight = 0;\n            let from = 0;\n            let to = 0;\n            let extraAttrs = {};\n\n            if (\"weight\" in edge) {\n                weight = parseFloat(edge.weight);\n            }\n            if (\"from\" in edge) {\n                from = nodeMap[edge.from];\n            }\n            if (\"to\" in edge) {\n                to = nodeMap[edge.to];\n            }\n            if (\"attributes\" in edge) {\n                extraAttrs = filterEdgeExtraAttr(edge.attributes);\n            }\n            else {\n                extraAttrs = filterEdgeExtraAttr(edge);\n            }\n\n            newEdges = newEdges.push(new EdgeImmut(from, to, weight, extraAttrs));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return newEdges;\n};\n\nconst genericNodesToImmutNodes = (nodes: any): boolean | { nodes: Readonly<List<NodeImmut>>; map: { [key: number]: number } } => {\n    if (nodes === null) {\n        return false;\n    }\n\n    let newNodes: List<NodeImmut> = List();\n    const nodeMap: NodeMapping = {};\n\n    if (typeof nodes === \"number\") {\n        // Create the nodes\n        for (let i = 0; i < Math.floor(nodes); i++) {\n            newNodes = newNodes.set(i, new NodeImmut(i));\n            nodeMap[i] = i;\n        }\n    }\n    else if (typeof nodes === 'object') {\n        let nodeNum = 0;\n        nodes.forEach((n: any) => {\n            const id = nodeNum++;\n            let label = null;\n            let extraAttrs = null;\n\n            if (\"label\" in n) {\n                label = n.label;\n            }\n            if (\"id\" in n) {\n                nodeMap[n.id] = id;\n                if (\"label\" in n && n.label === n.id.toString()) {\n                    label = id.toString();\n                }\n            }\n            else {\n                nodeMap[id] = id;\n            }\n            if (\"attributes\" in n) {\n                extraAttrs = filterNodeExtraAttr(n.attributes);\n            }\n            else {\n                extraAttrs = filterNodeExtraAttr(n);\n            }\n\n            newNodes = newNodes.set(id, new NodeImmut(id, label, extraAttrs));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return {nodes: Object.freeze(newNodes), map: nodeMap};\n};\n\nexport default class GraphImmut {\n    private readonly directed: Readonly<boolean>;\n    private readonly weighted: Readonly<boolean>;\n    private readonly nodes: Readonly<List<NodeImmut>>;\n    private readonly numNodes: Readonly<number>;\n    private readonly edges: Readonly<List<EdgeImmut>>;\n    private readonly numEdges: Readonly<number>;\n\n    constructor(nodes: number | List<NodeImmut> | NodeImmutPlain[],\n                edges: null | List<EdgeImmut> | EdgeImmutPlain[] = null,\n                directed = false, weighted = false) {\n        this.directed = Object.freeze(directed);\n        this.weighted = Object.freeze(weighted);\n        let nodeMap = {};\n\n        // Make Nodes\n        if (typeof nodes === \"number\" || (typeof nodes === \"object\" && !(nodes instanceof List))) {\n            const n = genericNodesToImmutNodes(nodes);\n            if (typeof n !== \"object\") {\n                throw new Error(\"Unable to parse node input!\");\n            }\n            this.nodes = n.nodes;\n            nodeMap = n.map;\n        }\n        else if (nodes instanceof List) {\n            this.nodes = nodes as List<NodeImmut>;\n        }\n        else {\n            throw new Error(\"Illegal type of 'node' input to GraphImmut constructor\");\n        }\n        this.nodes = Object.freeze(this.nodes);\n        this.numNodes = Object.freeze(this.nodes.size);\n\n        // If we are given edges, add them to the graph\n        if (edges !== null && typeof edges === \"object\" && !(edges instanceof List)) {\n            const e = genericEdgesToImmutEdges(edges, nodeMap);\n            if (typeof e !== \"object\") {\n                throw new Error(\"Unable to parse Edge input\");\n            }\n            this.edges = e;\n        }\n        else if (edges instanceof List) {\n            this.edges = edges as List<EdgeImmut>;\n        }\n        else {\n            this.edges = List();\n        }\n        this.edges = Object.freeze(this.edges);\n        this.numEdges = Object.freeze(this.edges.size);\n\n        if (new.target === GraphImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    getNode(id: number, rich = false): NodeImmut | NodeImmutPlain | boolean {\n        if (id >= this.numNodes) {\n            return false;\n        }\n        if (rich) {\n            return this.nodes.get(id);\n        }\n        return this.nodes.get(id).toPlain();\n    }\n\n    addNode(data: any = null): GraphImmut {\n        if (data === null) {\n            data = {};\n        }\n\n        const id = this.numNodes;\n        if (!(\"label\" in data)) {\n            data.label = id.toString();\n        }\n\n        const extraAttrs = filterNodeExtraAttr(data);\n\n        return new GraphImmut(this.nodes.set(id, new NodeImmut(id, data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    editNode(id: number, data: any): any {\n        if (!this.nodes.has(id)) {\n            return false;\n        }\n\n        const extraAttrs = filterNodeExtraAttr(data);\n        if (!(\"label\" in data)) {\n            data.label = (this.getNode(id, true) as NodeImmut).getLabel();\n        }\n        return new GraphImmut(this.nodes.set(id, (this.getNode(id, true) as NodeImmut).editNode(data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    deleteNode(id: number): GraphImmut | boolean {\n        // Make sure the ID exists\n        if (!(id >= 0 && id < this.numNodes)) {\n            return false;\n        }\n\n        const nodeMap: NodeMapping = {}; // Map for old IDs to new ones since we're deleting an entry\n\n        // Remove it from the node list\n        let nodeCount = 0;\n        const newNodes: List<NodeImmut> = this.nodes\n            .filter((n) => {\n                if (n.getID() === id) {\n                    nodeMap[n.getID()] = -1;\n                }\n                else {\n                    nodeMap[n.getID()] = nodeCount++;\n                }\n\n                return n.getID() !== id;\n            })\n            .map((node) => {\n                let label = node.getLabel();\n                if (node.getID().toString() === label) {\n                    label = nodeMap[node.getID()].toString();\n                }\n\n                return new NodeImmut(nodeMap[node.getID()], label, node.getAllAttributes());\n            }) as List<NodeImmut>;\n\n        // Remap edges\n        const newEdges: List<EdgeImmut> = this.edges\n            .filter((edge) => {\n                return !(edge.getFrom() === id || edge.getTo() === id);\n            })\n            .map((edge) => {\n                return new EdgeImmut(nodeMap[edge.getFrom()], nodeMap[edge.getTo()], edge.getWeight(), edge.getAllAttributes());\n            }) as List<EdgeImmut>;\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    addEdge(from: number, to: number, weight: any = 1): GraphImmut {\n        if (!this.weighted) {\n            weight = 1; // Ensure that edge weights are 1 if this is an unweighted graph\n        }\n\n        const newEdges = this.edges.push(new EdgeImmut(from, to, parseFloat(weight)));\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    deleteEdge(from: number, to: number, weight: any = null, deleteAll = true): GraphImmut {\n        if (weight !== null) {\n            weight = parseFloat(weight);\n        }\n\n        let foundOneEdge = false;\n        const newEdges: List<EdgeImmut> = this.edges.filter((edge) => {\n            // If we're not deleting everything and we have found one edge, then do not filter anymore\n            if (foundOneEdge && !deleteAll) {\n                return true;\n            }\n\n            // If we have an exact match\n            if (edge.getFrom() === from && edge.getTo() === to && (weight === null || edge.getWeight() === weight)) {\n                foundOneEdge = true;\n                return false; // Remove this edge\n            }\n\n            // If we are undirected, check for opposing matches\n            if (!this.directed) {\n                if (edge.getFrom() === to && edge.getTo() === from && (weight === null || edge.getWeight() === weight)) {\n                    foundOneEdge = true;\n                    return false; // Remove this edge\n                }\n            }\n\n            return true;\n        }) as List<EdgeImmut>;\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    editEdge(from: number, to: number, newWeight: any, oldWeight: any = null, color: string | null = null): GraphImmut | boolean {\n        let foundFirst = false;\n\n        if (oldWeight !== null) {\n            oldWeight = parseFloat(oldWeight);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge, index) => {\n            if (foundFirst) {\n                return;\n            }\n\n            if (((edge.getFrom() === from && edge.getTo() === to)\n                || (!this.isDirected() && edge.getFrom() === to && edge.getTo() === from))\n                && (oldWeight === null || edge.getWeight() === oldWeight)) {\n\n                if (color !== null) {\n                    newEdges = newEdges.set(index,\n                        edge.editEdge(newWeight === null ? null : parseFloat(newWeight),\n                            {color: color}));\n                }\n                else {\n                    newEdges = newEdges.set(index, edge.editEdge(newWeight === null ? null : parseFloat(newWeight)));\n                }\n                foundFirst = true;\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    getAllNodes(rich = false): NodeImmut[] | NodeImmutPlain[] {\n        if (rich) {\n            return this.nodes.toArray();\n        }\n        return this.nodes.map((node) => {\n            return node.toPlain();\n        }).toArray();\n    }\n\n    getAllNodesAsImmutableList(): List<NodeImmut> {\n        return this.nodes;\n    }\n\n    getAllEdgesAsImmutableList(): List<EdgeImmut> {\n        return this.edges;\n    }\n\n    getAllEdges(rich = false): EdgeImmut[] | EdgeImmutPlain[] {\n        if (rich) {\n            return this.edges.toArray();\n        }\n        return this.edges.map((edge) => {\n            return edge.toPlain();\n        }).toArray();\n    }\n\n    getNumberOfNodes(): number {\n        return this.numNodes;\n    }\n\n    getNumberOfEdges(): number {\n        return this.numEdges;\n    }\n\n    getAllOutDegrees(): number[] {\n        const degrees: number[] = [];\n        this.nodes.forEach((_, i) => {\n            degrees[i] = 0;\n        });\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() in degrees) {\n                degrees[edge.getFrom()]++;\n            }\n            else {\n                degrees[edge.getFrom()] = 1;\n            }\n        });\n\n        return degrees;\n    }\n\n    asWeighted(): GraphImmut {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }) as List<EdgeImmut>, this.directed, true);\n    }\n\n    asUnweighted(): GraphImmut {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }) as List<EdgeImmut>, this.directed, false);\n    }\n\n    asDirected(doubleEdges = false): GraphImmut {\n        if (!doubleEdges) {\n            return new GraphImmut(this.nodes, this.edges, true, this.weighted);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.getTo(), edge.getFrom(), edge.getWeight(), edge.getAllAttributes()));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, true, this.weighted);\n    }\n\n    asUndirected(): GraphImmut {\n        let newEdges: List<EdgeImmut> = List();\n        const addedEdges: { [key: string]: null } = {};\n\n        this.edges.forEach((edge) => {\n            let from = edge.getFrom();\n            let to = edge.getTo();\n            if (to < from) {\n                from = to;\n                to = edge.getFrom();\n            }\n            if (!(`${from}_${to}` in addedEdges)) {\n                addedEdges[`${from}_${to}`] = null;\n                newEdges = newEdges.push(new EdgeImmut(from, to, edge.getWeight(), edge.getAllAttributes()));\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, false, this.weighted);\n    }\n\n    asChangedDirectedWeighted(directed: boolean, weighted: boolean): GraphImmut {\n        let G: GraphImmut = this;\n        if (directed && !this.directed) {\n            G = G.asDirected();\n        }\n        else if (!directed && this.directed) {\n            G = G.asUndirected();\n        }\n\n        if (weighted && !this.weighted) {\n            G = G.asWeighted();\n        }\n        else if (!weighted && this.weighted) {\n            G = G.asUnweighted();\n        }\n\n        return G;\n    }\n\n    getNodeAdjacency(id: number): number[] {\n        const adj: number[] = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() === id) {\n                adj.push(edge.getTo());\n            }\n            else if (!this.directed && edge.getTo() === id) {\n                adj.push(edge.getFrom());\n            }\n        });\n\n        return adj;\n    }\n\n    getFullAdjacency(): number[][] {\n        const adj: number[][] = [];\n        this.nodes.forEach((n) => {\n            adj[n.getID()] = this.getNodeAdjacency(n.getID());\n        });\n\n        return adj;\n    }\n\n    areAdjacent(id1: number, id2: number): boolean {\n        return this.getNodeAdjacency(id1).includes(id2);\n    }\n\n    getEdgesBetween(id1: number, id2: number): EdgeImmut[] {\n        const edgeList: EdgeImmut[] = [];\n        if (id1 >= this.numNodes || id2 >= this.numNodes) {\n            return edgeList;\n        }\n\n        this.edges.forEach((edge) => {\n            if (!this.directed && edge.getFrom() === id2 && edge.getTo() === id1) {\n                edgeList.push(edge);\n            }\n\n            if (edge.getFrom() === id1 && edge.getTo() === id2) {\n                edgeList.push(edge);\n            }\n        });\n\n        return edgeList;\n    }\n\n    getMinWeightEdgeBetween(id1: number, id2: number): number {\n        let minWeight = Infinity;\n        this.getEdgesBetween(id1, id2).forEach((edge) => {\n            if (edge.getWeight() < minWeight) {\n                minWeight = edge.getWeight();\n            }\n        });\n\n        return minWeight;\n    }\n\n    // Take a multigraph and reduce all multiple edges to a single edge, weighted using the reducer\n    reduceMultiGraph(reducer: (a: number, b: number) => number = Math.min, initialValue: any = Infinity): GraphImmut {\n        const multiEdges: EdgeImmutPlain[] = [];\n        this.nodes.forEach((node) => {\n            // If we have duplicates\n            const adj = this.getNodeAdjacency(node.getID());\n            const uniques = new Set(adj);\n            if (uniques.size < adj.length) {\n                uniques.forEach((to) => {\n                    const newWeight = this.getEdgesBetween(node.getID(), to).reduce((acc, edge) => {\n                        return reducer(acc, edge.getWeight());\n                    }, initialValue);\n\n                    multiEdges.push({from: node.getID(), to, weight: parseFloat(newWeight)});\n                });\n            }\n        });\n\n        // Remove all multigraph edges and replace them with single new edges\n        let newEdges = this.edges.filter((edge) => {\n            let keep = true;\n            multiEdges.forEach((duplicateEdge) => {\n                if (edge.getFrom() === duplicateEdge.from && edge.getTo() === duplicateEdge.to) {\n                    keep = false;\n                }\n            });\n\n            return keep;\n        }) as List<EdgeImmut>;\n        multiEdges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.from, edge.to, edge.weight));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    isWeighted() {\n        return this.weighted;\n    }\n\n    isDirected() {\n        return this.directed;\n    }\n}\n","\"use strict\";\n\nexport interface NodeImmutPlain {\n    id: Readonly<number>;\n    label: string;\n\n    [key: string]: any;\n\n    [key: number]: any\n}\n\nexport default class NodeImmut {\n    private readonly id: Readonly<number>;\n    private readonly label: Readonly<string>;\n    private readonly attributes: any;\n\n    constructor(id: any, label: null | string = null, extraAttrs: null | any = null) {\n        if (label === null) {\n            this.label = id.toString();\n        }\n        else {\n            this.label = label;\n        }\n\n        this.attributes = {};\n        if (extraAttrs !== null && typeof extraAttrs === \"object\") {\n            Object.keys(extraAttrs).forEach((key) => {\n                this.attributes[key] = Object.freeze(extraAttrs[key]);\n            });\n        }\n\n        this.attributes = Object.freeze(this.attributes);\n        this.label = Object.freeze(this.label);\n        this.id = Object.freeze(id);\n\n        if (new.target === NodeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    toPlain(): NodeImmutPlain {\n        const toReturn: NodeImmutPlain = {id: this.id, label: this.label};\n        Object.keys(this.attributes).forEach((key) => {\n            if (!(key in toReturn)) {\n                toReturn[key] = this.attributes[key];\n            }\n        });\n\n        return toReturn;\n    }\n\n    getID(): Readonly<number> {\n        return this.id;\n    }\n\n    getLabel(): Readonly<string> {\n        return this.label;\n    }\n\n    getAttribute(attribute: string | number): any {\n        if (attribute in this.attributes) {\n            return this.attributes[attribute];\n        }\n\n        return null;\n    }\n\n    getAllAttributes(): { [key: string]: any; [key: number]: any } {\n        return this.attributes;\n    }\n\n    editNode(label: any = null, extraAttrs: any = null): NodeImmut {\n        if (label === null) {\n            label = this.getLabel();\n        }\n\n        // Merge existing and new attributes favoring the new\n        const attributes = Object.assign({}, this.attributes);\n        if(extraAttrs !== null) {\n            Object.keys(extraAttrs).forEach((key) => {\n                attributes[key] = extraAttrs[key];\n            });\n        }\n\n        return new NodeImmut(this.getID(), label, attributes);\n    }\n}\n"],"sourceRoot":""}