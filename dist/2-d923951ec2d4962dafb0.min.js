(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{105:function(t,e,r){"use strict";r.r(e);var n=r(2),o=r(28),i=function(){function t(t){this.id=[];for(var e=0;e<t;e++)this.id.push(e)}return t.prototype.union=function(t,e){var r=this.root(t),n=this.root(e);n!==r&&(this.id[n]=r)},t.prototype.root=function(t){for(;this.id[t]!==t;)t=this.id[t];return t},t.prototype.connected=function(t,e){return this.root(t)===this.root(e)},t}(),a=r(0),u=function(t,e,r,n){return new(r||(r=Promise))(function(o,i){function a(t){try{s(n.next(t))}catch(t){i(t)}}function u(t){try{s(n.throw(t))}catch(t){i(t)}}function s(t){t.done?o(t.value):new r(function(e){e(t.value)}).then(a,u)}s((n=n.apply(t,e||[])).next())})},s=function(t,e){var r,n,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(o=n[2&i[0]?"return":i[0]?"throw":"next"])&&!(o=o.call(n,i[1])).done)return o;switch(n=0,o&&(i=[0,o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,n=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=(o=a.trys).length>0&&o[o.length-1])&&(6===i[0]||2===i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a)}catch(t){i=[6,t],n=0}finally{r=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}},c=function(){return function(){var t=this;this.colorNetwork=function(t){void 0===t&&(t=a.a.graph);for(var e=n.a.datasetToArray(t.getAllNodes(),"id"),r=t.getAllOutDegrees(),o=n.a.sort(e,function(t,e){return r[t]<r[e]?1:r[t]===r[e]?0:-1}),i={},u=0;o.length>0;){var s=o.shift();i[s]=u;var c=[];c.push(s);for(var h=0;h<o.length;){for(var f=o[h],l=!1,g=0;g<c.length;g++)if(t.areAdjacent(f,c[g])){h++,l=!0;break}l||(i[f]=u,c.push(f),o.splice(h,1))}u++}return{colors:i,chromaticNumber:n.a.max(n.a.flatten(i))+1}},this.connectedComponents=function(e){void 0===e&&(e=a.a.graph);for(var r={},n=0,o=function(t){r[t]=n},i=0;i<e.getNumberOfNodes();i++)i in r||(t.depthFirstSearch(e,i).forEach(o),n++);return Promise.resolve({components:r,count:n})},this.depthFirstSearch=function(t,e){void 0===t&&(t=a.a.graph);var r=[],n=[];for(n.push(e);n.length>0;){var o=n.pop();r.includes(o)||(r.push(o),t.getNodeAdjacency(o).forEach(function(t){n.push(t)}))}return r},this.stronglyConnectedComponents=function(t){void 0===t&&(t=a.a.graph);for(var e=0,r={},n={},o=[],i={},u=0,s=function(a){if(r[a]=e,n[a]=e++,o.push(a),t.getNodeAdjacency(a).forEach(function(t){t in r?o.includes(t)&&(n[a]=Math.min(n[a],r[t])):(s(t),n[a]=Math.min(n[a],n[t]))}),n[a]===r[a]){var c=-1;if(o.length>0){do{c=o.pop(),i[c]=u}while(c!==a);u++}}},c=0;c<t.getNumberOfNodes();c++)c in r||s(c);return Promise.resolve({components:i,count:u})},this.breadthFirstSearch=function(t,e,r){void 0===r&&(r=a.a.graph);var n=[],o=[],i={};o.push(t);for(var u=function(){var t=o.shift();n.includes(t)||(n.push(t),r.getNodeAdjacency(t).forEach(function(e){n.includes(e)||(i[e]=t,o.push(e))}))};o.length>0;)u();if(n.includes(e)){for(var s=[],c=e;c!==t;c=i[c])s.push(c);s.push(t),s.reverse();for(var h=0,f=0;f<s.length-1;f++)h+=r.getMinWeightEdgeBetween(s[f],s[f+1]);return{pathExists:!0,path:s,distance:s.length,weight:h}}return{pathExists:!1,path:[],distance:-1,weight:-1}},this.dijkstraSearch=function(t,e,r){if(void 0===r&&(r=a.a.graph),r.isDirected()||(r=r.asDirected(!0)),r.isWeighted()||(r=r.asWeighted()),void 0!==r.getAllEdges(!0).find(function(t){return t.getWeight()<0}))return n.a.showSimpleModal("Dijkstra Error","<p>The Dijkstra algorithm only works on graphs with totally non-negative edge weights. Please fix the graph so that there are no negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves exactly this problem.</p>"),!1;var o=new(function(){function t(){this._nodes=[]}return t.prototype.enqueue=function(t,e){this._nodes.push({key:e,priority:t}),this.sort()},t.prototype.dequeue=function(){return this._nodes.shift().key},t.prototype.sort=function(){this._nodes.sort(function(t,e){return t.priority-e.priority})},t.prototype.isEmpty=function(){return!this._nodes.length},t}()),i={},u={},s=[];r.getAllNodes(!0).forEach(function(e){var r=1/0;e.getID()===t&&(r=0),i[e.getID()]=r,o.enqueue(r,e.getID()),u[e.getID()]=null});for(var c=function(){var t=o.dequeue();if(t===e){for(s=[];null!==u[t];)s.push(t),t=u[t];return"break"}if(i[t]===1/0)return"continue";r.getNodeAdjacency(t).forEach(function(e){var n=i[t]+r.getMinWeightEdgeBetween(t,e);n<i[e]&&(i[e]=n,u[e]=t,o.enqueue(n,e))})};!o.isEmpty()&&"break"!==c(););return s.push(t),s.reverse(),i[e]!==1/0?{pathExists:!0,path:s,distance:s.length,cost:i[e]}:{pathExists:!1,path:[],distance:-1,cost:0}},this.bellmanFord=function(t,e,r){void 0===r&&(r=a.a.graph);var o=[],i=[];r.getAllNodes(!0).forEach(function(t){o[t.getID()]=1/0,i[t.getID()]=null}),o[t]=0;for(var u=0;u<r.getNumberOfNodes()-1;u++)r.getAllEdges(!0).forEach(function(t){o[t.getFrom()]+t.getWeight()<o[t.getTo()]&&(o[t.getTo()]=o[t.getFrom()]+t.getWeight(),i[t.getTo()]=t.getFrom())});var s=!1;if(r.getAllEdges(!0).forEach(function(t){o[t.getFrom()]+t.getWeight()<o[t.getTo()]&&(s=!0)}),o[e]!==1/0){for(var c=[e];!c.includes(t);)c.push(i[c.slice().pop()]);return c.reverse(),{pathExists:!0,path:c,distance:c.length,cost:o[e]}}return s?(n.a.showSimpleModal("Bellman-Ford Error","<p>The Bellman-Ford algorithm only works on graphs with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>"),!1):{pathExists:!1,path:[],distance:-1,cost:0}},this.fordFulkerson=function(e,r,n){if(void 0===n&&(n=a.a.graph),!n.isDirected())return!1;if(e===r)return!1;if(!t.breadthFirstSearch(e,r,n).pathExists)return!1;var o=(n=n.reduceMultiGraph(function(t,e){return t+e})).getNumberOfNodes(),i=0,u=[],s=[],c={};n.getAllEdges(!0).forEach(function(t){c[t.getFrom()+"_"+t.getTo()]={from:t.getFrom(),to:t.getTo(),capacity:t.getWeight(),flow:0}});for(var h=function(t,e){var r=t.split("_"),n=parseInt(r[0]),o=parseInt(r[1]);return e===n?o:n},f=function(t,e){var r=t.split("_");return e===parseInt(r[0])?c[t].flow:c[t].capacity-c[t].flow},l=function(t,e,r){var n=t.split("_");e===parseInt(n[0])?c[t].flow-=r:c[t].flow+=r},g=function(){u=[],s=[];for(var t=0;t<o;++t)u.push(!1),s.push(null);var i=[];for(i.push(e),u[e]=!0;i.length>0;){t=i.shift();for(var a=0,c=n.getNodeAdjacency(t);a<c.length;a++){var l=t+"_"+c[a],g=h(l,t);if(!u[g]&&f(l,g)>0){if(s[g]=l,u[g]=!0,g===r)return!0;i.push(g)}}}return!1};g();){for(var p=1/0,d=r;d!==e;d=h(s[d],d))p=Math.min(p,f(s[d],d));for(d=r;d!==e;d=h(s[d],d))l(s[d],d,p);i+=p}return{maxFlow:i,flowPath:function(){for(var t=[],e=0;e<o;e++)for(var r=0,i=n.getNodeAdjacency(e);r<i.length;r++){var a=e+"_"+i[r];c[a].flow>0&&t.push(c[a])}return t}()}},this.kruskal=function(t){void 0===t&&(t=a.a.graph),t.reduceMultiGraph(Math.min,1/0);var e=t.getAllEdges(!0);e.sort(function(t,e){return t.getWeight()-e.getWeight()});for(var r=[],n=new i(t.getNumberOfNodes());e.length>0&&r.length<t.getNumberOfNodes()-1;){var o=e.shift();n.connected(o.getFrom(),o.getTo())||(n.union(o.getFrom(),o.getTo()),r.push(o))}return{mst:r,totalWeight:r.reduce(function(t,e){return t+e.getWeight()},0)}},this.topologicalSort=function(t){void 0===t&&(t=a.a.graph);for(var e=t.getFullAdjacency(),r=o.a.findVertexDegreesDirectional(e),n=[],i=t.getAllNodes(!0).filter(function(t){return 0===r[t.getID()].in}),u=t.getAllEdges(!0),s=function(){var o=i.pop();n.push(o);var a=e[o.getID()];u=u.filter(function(t){return t.getFrom()!==o.getID()||!a.includes(t.getTo())||(r[t.getTo()].in--,e[o.getID()]=e[o.getID()].filter(function(e){return e!==t.getTo()}),!1)}),a.forEach(function(e){0===r[e].in&&i.push(t.getNode(e,!0))})};0!==i.length;)s();return u.length>0||n},this.isGraphCyclic=function(e){return void 0===e&&(e=a.a.graph),!0===t.topologicalSort(e)},this.directionalEulerian=function(e){return u(t,void 0,void 0,function(){var t,r,n;return s(this,function(o){switch(o.label){case 0:return[4,a.a.getProperty("stronglyConnectedComponents",!0)];case 1:return t=o.sent(),r=!0,n=-1,e.forEach(function(e,o){e.in!==e.out&&(r=!1),e.in>0&&(-1===n&&(n=t[o]),n!==t[o]&&(r=!1))}),[2,r]}})})},this.hasEulerianCircuit=function(e){return u(t,void 0,void 0,function(){var t,r,n;return s(this,function(o){switch(o.label){case 0:return 0!==e.filter(function(t){return t%2!=0}).length?[2,!1]:[4,a.a.getProperty("connectedComponents",!0)];case 1:return t=o.sent(),r=!0,n=-1,e.forEach(function(e,o){0!==e&&(-1===n&&(n=t[o]),n!==t[o]&&(r=!1))}),[2,r]}})})}}}();e.default=c}}]);
//# sourceMappingURL=2-d923951ec2d4962dafb0.min.js.map