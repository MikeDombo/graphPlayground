{"version":3,"sources":["webpack:///./src/js/SpanningTree.ts","webpack:///./src/js/GraphAlgorithms.ts"],"names":["SpanningTree","V","this","id","v","push","prototype","union","w","q","root","p","connected","GraphAlgorithms_GraphAlgorithms","_this","colorNetwork","G","graphState","graph","nodeArr","genericHelpers","datasetToArray","getAllNodes","degrees","getAllOutDegrees","vertexOrder","sort","a","b","colorIndex","currentColor","length","shift","myGroup","i","conflict","j","areAdjacent","splice","colors","chromaticNumber","max","flatten","connectedComponents","components","componentCount","setComponentNum","getNumberOfNodes","depthFirstSearch","forEach","Promise","resolve","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","showSimpleModal","queue","PriorityQueue","_nodes","enqueue","priority","key","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","_i","vertexAdjacency_1","bottleneckValue","maxFlow","flowPath","f","vertexAdjacency_2","getFlows","kruskal","set","js_SpanningTree","mst","totalWeight","reduce","acc","topologicalSort","adjacency","getFullAdjacency","graphHelpers","findVertexDegreesDirectional","L","filter","n","in","edges","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","GraphAlgorithms_awaiter","getProperty","scc","_a","sent","eulerian","component","deg","out","hasEulerianCircuit","cc"],"mappings":"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","file":"2-d923951ec2d4962dafb0.min.js","sourcesContent":["\"use strict\";\r\n\r\nexport default class SpanningTree {\r\n    private readonly id: number[];\r\n\r\n    constructor(V: number) {\r\n        this.id = [];\r\n        for (let v = 0; v < V; v++) {\r\n            this.id.push(v);\r\n        }\r\n    }\r\n\r\n    union(v: number, w: number) {\r\n        const q = this.root(v);\r\n        const p = this.root(w);\r\n\r\n        if (p !== q) {\r\n            this.id[p] = q;\r\n        }\r\n    }\r\n\r\n    root(q: number) {\r\n        while (this.id[q] !== q) {\r\n            q = this.id[q];\r\n        }\r\n        return q;\r\n    }\r\n\r\n    connected(v: number, w: number) {\r\n        return this.root(v) === this.root(w);\r\n    }\r\n}\r\n","\"use strict\";\r\n\r\nimport genericH from './genericHelpers';\r\nimport graphH from './graphHelpers';\r\nimport SpanningTree from './SpanningTree';\r\nimport EdgeImmut from \"./GraphImmut/EdgeImmut\";\r\nimport NodeImmut from \"./GraphImmut/NodeImmut\";\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\nimport GraphState from \"./graphState\";\r\n\r\ntype EdgeFlowProp = {from: number; to: number; capacity: number; flow: number};\r\nexport type ShortestPathResult = { pathExists: boolean; path: number[]; distance: number; cost?: number; weight?: number};\r\nexport type ConnectedComponentResult = { components: {[key: number]: number}; count: number };\r\n\r\nexport default class GraphAlgorithms {\r\n    // Welsh-Powell Algorithm\r\n    public colorNetwork = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number } => {\r\n        // Get node ID's only\r\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\r\n\r\n        // Put vertices in array in decreasing order of degree\r\n        const degrees = G.getAllOutDegrees();\r\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\r\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\r\n        });\r\n\r\n        const colorIndex: { [key: number]: number } = {};\r\n        let currentColor = 0;\r\n        while (vertexOrder.length > 0) {\r\n            const root = vertexOrder.shift();\r\n            colorIndex[root] = currentColor;\r\n\r\n            const myGroup = [];\r\n            myGroup.push(root);\r\n\r\n            for (let i = 0; i < vertexOrder.length;) {\r\n                const p = vertexOrder[i];\r\n                let conflict = false;\r\n\r\n                for (let j = 0; j < myGroup.length; j++) {\r\n                    if (G.areAdjacent(p, myGroup[j])) {\r\n                        i++;\r\n                        conflict = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (conflict) {\r\n                    continue;\r\n                }\r\n\r\n                colorIndex[p] = currentColor;\r\n                myGroup.push(p);\r\n                vertexOrder.splice(i, 1);\r\n            }\r\n\r\n            currentColor++;\r\n        }\r\n\r\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\r\n        return {colors: colorIndex, chromaticNumber};\r\n    };\r\n\r\n    public connectedComponents = (G: GraphImmut = GraphState.graph): Promise<ConnectedComponentResult> => {\r\n        const components: { [key: number]: number } = {};\r\n        let componentCount = 0;\r\n        const setComponentNum = (v: number) => {\r\n            components[v] = componentCount;\r\n        };\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in components)) {\r\n                const visited = this.depthFirstSearch(G, i);\r\n                visited.forEach(setComponentNum);\r\n                componentCount++;\r\n            }\r\n        }\r\n\r\n        return Promise.resolve({components, count: componentCount});\r\n    };\r\n\r\n    public depthFirstSearch = (G: GraphImmut = GraphState.graph, start: number): number[] => {\r\n        const visisted: number[] = [];\r\n        const Stack: number[] = [];\r\n        Stack.push(start);\r\n        while (Stack.length > 0) {\r\n            const v = Stack.pop();\r\n            if (!visisted.includes(v)) {\r\n                visisted.push(v);\r\n                G.getNodeAdjacency(v).forEach((nodeID) => {\r\n                    Stack.push(nodeID);\r\n                });\r\n            }\r\n        }\r\n\r\n        return visisted;\r\n    };\r\n\r\n    // Tarjan's algorithm\r\n    public stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): Promise<ConnectedComponentResult> => {\r\n        let index = 0;\r\n        const indices: { [key: number]: number } = {};\r\n        const lowlink: { [key: number]: number } = {};\r\n        const S: number[] = [];\r\n        const components: { [key: number]: number } = {};\r\n        let componentCount = 0;\r\n\r\n        const strongConnect = (v: number) => {\r\n            indices[v] = index;\r\n            lowlink[v] = index++;\r\n            S.push(v);\r\n\r\n            G.getNodeAdjacency(v).forEach((w) => {\r\n                if (!(w in indices)) {\r\n                    strongConnect(w);\r\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\r\n                }\r\n                else if (S.includes(w)) {\r\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\r\n                }\r\n            });\r\n\r\n            if (lowlink[v] === indices[v]) {\r\n                let w = -1;\r\n                if (S.length > 0) {\r\n                    do {\r\n                        w = S.pop();\r\n                        components[w] = componentCount;\r\n                    }\r\n                    while (w !== v);\r\n                    componentCount++;\r\n                }\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in indices)) {\r\n                strongConnect(i);\r\n            }\r\n        }\r\n\r\n        return Promise.resolve({components, count: componentCount});\r\n    };\r\n\r\n    public breadthFirstSearch = (startNodeID: number, targetNodeID: number,\r\n                                 G: GraphImmut = GraphState.graph): ShortestPathResult => {\r\n        // Perform the BFS\r\n        const visisted: number[] = [];\r\n        const Q: number[] = []; // Use Push and Shift for Queue operations\r\n        const edgeTo: { [key: number]: number } = {};\r\n\r\n        Q.push(startNodeID);\r\n        while (Q.length > 0) {\r\n            const x = Q.shift();\r\n            if (!visisted.includes(x)) {\r\n                visisted.push(x);\r\n                G.getNodeAdjacency(x).forEach((y) => {\r\n                    if (!visisted.includes(y)) {\r\n                        edgeTo[y] = x;\r\n                        Q.push(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visisted.includes(targetNodeID)) {\r\n            // Build the path\r\n            const path = [];\r\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\r\n                path.push(x);\r\n            }\r\n            path.push(startNodeID);\r\n            path.reverse();\r\n\r\n            // Get the path weight\r\n            let weight = 0;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\r\n            }\r\n\r\n            return {pathExists: true, path, distance: path.length, weight};\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, weight: -1};\r\n    };\r\n\r\n    public dijkstraSearch = (startNodeID: number, targetNodeID: number, G: GraphImmut = GraphState.graph): (ShortestPathResult | boolean) => {\r\n        if (!G.isDirected()) {\r\n            G = G.asDirected(true);\r\n        }\r\n        if (!G.isWeighted()) {\r\n            G = G.asWeighted();\r\n        }\r\n\r\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find((edge) => {\r\n            return edge.getWeight() < 0;\r\n        });\r\n        if (typeof nonNegative !== \"undefined\") {\r\n            genericH.showSimpleModal(\"Dijkstra Error\", \"<p>The Dijkstra algorithm only works on graphs\" +\r\n                \" with totally non-negative edge weights. Please fix the graph so that there are no\" +\r\n                \" negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves\" +\r\n                \" exactly this problem.</p>\");\r\n            return false;\r\n        }\r\n\r\n        // Priority Queue implementation for Dijkstra\r\n        class PriorityQueue {\r\n            private _nodes: { key: number | string; priority: number }[] = [];\r\n\r\n            enqueue(priority: number, key: number): void {\r\n                this._nodes.push({key, priority});\r\n                this.sort();\r\n            };\r\n\r\n            dequeue(): number|string {\r\n                return this._nodes.shift().key;\r\n            };\r\n\r\n            sort(): void {\r\n                this._nodes.sort((a: { priority: number }, b: { priority: number }) => {\r\n                    return a.priority - b.priority;\r\n                });\r\n            };\r\n\r\n            isEmpty(): boolean {\r\n                return !this._nodes.length;\r\n            };\r\n        }\r\n\r\n        const queue = new PriorityQueue();\r\n        const distances: { [key: number]: number } = {};\r\n        const previous: { [key: number]: number } = {};\r\n        let path = [];\r\n\r\n        // Initialize Queue and distances\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach((node) => {\r\n            let dist = Infinity;\r\n            if (node.getID() === startNodeID) {\r\n                dist = 0;\r\n            }\r\n\r\n            distances[node.getID()] = dist;\r\n            queue.enqueue(dist, node.getID());\r\n            previous[node.getID()] = null;\r\n        });\r\n\r\n        while (!queue.isEmpty()) {\r\n            let smallest = queue.dequeue() as number;\r\n\r\n            if (smallest === targetNodeID) {\r\n                path = [];\r\n                while (previous[smallest] !== null) {\r\n                    path.push(smallest);\r\n                    smallest = previous[smallest];\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (distances[smallest] === Infinity) {\r\n                continue;\r\n            }\r\n\r\n            G.getNodeAdjacency(smallest).forEach((neighbor) => {\r\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\r\n\r\n                if (alt < distances[neighbor]) {\r\n                    distances[neighbor] = alt;\r\n                    previous[neighbor] = smallest;\r\n\r\n                    queue.enqueue(alt, neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        path.push(startNodeID);\r\n        path.reverse();\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            return {pathExists: true, path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    };\r\n\r\n    public bellmanFord = (startNodeID: number, targetNodeID: number, G: GraphImmut = GraphState.graph): ( ShortestPathResult | boolean ) => {\r\n        const distances: number[] = [];\r\n        const parents: number[] = [];\r\n\r\n        // Initialize\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach((node) => {\r\n            distances[node.getID()] = Infinity;\r\n            parents[node.getID()] = null;\r\n        });\r\n\r\n        // Relax Edges\r\n        distances[startNodeID] = 0;\r\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\r\n            (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\r\n                    parents[edge.getTo()] = edge.getFrom();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for negative weight cycles\r\n        let negativeCylce = false;\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                negativeCylce = true;\r\n            }\r\n        });\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            const path: number[] = [targetNodeID];\r\n            while (!path.includes(startNodeID)) {\r\n                path.push(parents[path.slice().pop()]);\r\n            }\r\n            path.reverse();\r\n\r\n            return {pathExists: true, path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n        if (negativeCylce) {\r\n            genericH.showSimpleModal(\"Bellman-Ford Error\", \"<p>The Bellman-Ford algorithm only works on graphs\" +\r\n                \" with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>\");\r\n            return false;\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    };\r\n\r\n    public fordFulkerson = (startNodeID: number, targetNodeID: number, G: GraphImmut = GraphState.graph): (boolean | { maxFlow: number; flowPath: EdgeFlowProp[] }) => {\r\n        // Must be a directed graph\r\n        if (!G.isDirected()) {\r\n            return false;\r\n        }\r\n\r\n        // Source == sink\r\n        if (startNodeID === targetNodeID) {\r\n            return false;\r\n        }\r\n\r\n        const bfs = this.breadthFirstSearch(startNodeID, targetNodeID, G);\r\n        // No path from source to sink\r\n        if (!bfs.pathExists) {\r\n            return false;\r\n        }\r\n\r\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\r\n        G = G.reduceMultiGraph((a, b) => {\r\n            return a + b;\r\n        });\r\n\r\n        const V = G.getNumberOfNodes();\r\n        let value = 0;\r\n        let marked: boolean[] = [];\r\n        let edgeTo: string[] = [];\r\n\r\n        const edgeProperties: {[key: string]: EdgeFlowProp} = {};\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\r\n                from: edge.getFrom(),\r\n                to: edge.getTo(),\r\n                capacity: edge.getWeight(),\r\n                flow: 0\r\n            };\r\n        });\r\n\r\n        const other = (e: string, x: number) => {\r\n            const edge = e.split(\"_\");\r\n            const a = parseInt(edge[0]);\r\n            const b = parseInt(edge[1]);\r\n            return x === a ? b : a;\r\n        };\r\n\r\n        const residualCapacity = (e: string, x: number) => {\r\n            const edge = e.split(\"_\");\r\n            const a = parseInt(edge[0]);\r\n            if (x === a) {\r\n                return edgeProperties[e].flow;\r\n            }\r\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\r\n        };\r\n\r\n        const addResidualFlow = (e: string, x: number, deltaFlow: number) => {\r\n            const edge = e.split(\"_\");\r\n            const v = parseInt(edge[0]);\r\n            if (x === v) {\r\n                edgeProperties[e].flow -= deltaFlow;\r\n            }\r\n            else {\r\n                edgeProperties[e].flow += deltaFlow;\r\n            }\r\n        };\r\n\r\n        const hasAugmentedPath = () => {\r\n            marked = [];\r\n            edgeTo = [];\r\n            for (let v = 0; v < V; ++v) {\r\n                marked.push(false);\r\n                edgeTo.push(null);\r\n            }\r\n\r\n            const queue = [];\r\n            queue.push(startNodeID);\r\n\r\n            marked[startNodeID] = true;\r\n            while (queue.length > 0) {\r\n                const v = queue.shift();\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (const i of vertexAdjacency) {\r\n                    const e = `${v}_${i}`;\r\n                    const w = other(e, v);\r\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\r\n                        edgeTo[w] = e;\r\n                        marked[w] = true;\r\n                        if (w === targetNodeID) {\r\n                            return true;\r\n                        }\r\n\r\n                        queue.push(w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        while (hasAugmentedPath()) {\r\n            let bottleneckValue = Infinity;\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x], x));\r\n            }\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                addResidualFlow(edgeTo[x], x, bottleneckValue);\r\n            }\r\n            value += bottleneckValue;\r\n        }\r\n\r\n        const getFlows = (): EdgeFlowProp[] => {\r\n            const f: EdgeFlowProp[] = [];\r\n            for (let v = 0; v < V; v++) {\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (const i of vertexAdjacency) {\r\n                    const e = `${v}_${i}`;\r\n                    if (edgeProperties[e].flow > 0) {\r\n                        f.push(edgeProperties[e]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return f;\r\n        };\r\n\r\n        return {maxFlow: value, flowPath: getFlows()};\r\n    };\r\n\r\n    public kruskal = (G: GraphImmut = GraphState.graph): { mst: EdgeImmut[]; totalWeight: number } => {\r\n        // If we have a multigraph, reduce it by using the minimum edge weights\r\n        G.reduceMultiGraph(Math.min, Infinity);\r\n\r\n        const Q: EdgeImmut[] = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\r\n        Q.sort((a, b) => {\r\n            return a.getWeight() - b.getWeight();\r\n        });\r\n\r\n        const kruskal: EdgeImmut[] = [];\r\n        const set = new SpanningTree(G.getNumberOfNodes());\r\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\r\n            const e = Q.shift();\r\n            if (!set.connected(e.getFrom(), e.getTo())) {\r\n                set.union(e.getFrom(), e.getTo());\r\n                kruskal.push(e);\r\n            }\r\n        }\r\n\r\n        // Get the total cost of the MST\r\n        const weight = kruskal.reduce((acc, e) => {\r\n            return acc + e.getWeight();\r\n        }, 0);\r\n\r\n        return {mst: kruskal, totalWeight: weight};\r\n    };\r\n\r\n    public topologicalSort = (G: GraphImmut = GraphState.graph): boolean | NodeImmut[] => {\r\n        const adjacency = G.getFullAdjacency();\r\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\r\n\r\n        const L: NodeImmut[] = [];\r\n        const S: NodeImmut[] = (G.getAllNodes(true) as NodeImmut[]).filter((n) => {\r\n            return degrees[n.getID()].in === 0;\r\n        });\r\n        let edges = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        while (S.length !== 0) {\r\n            const nodeN = S.pop();\r\n            L.push(nodeN);\r\n\r\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\r\n\r\n            // Remove n to m edges for all nodes m\r\n            edges = edges.filter((edge) => {\r\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\r\n                    degrees[edge.getTo()].in--;\r\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter((v) => {\r\n                        return v !== edge.getTo();\r\n                    });\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // If m has no more incoming edges, add it to S\r\n            nodeNConnectedTo.forEach((mID) => {\r\n                if (degrees[mID].in === 0) {\r\n                    S.push(G.getNode(mID, true) as NodeImmut);\r\n                }\r\n            });\r\n        }\r\n\r\n        return edges.length > 0 || L;\r\n    };\r\n\r\n    public isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\r\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\r\n        return this.topologicalSort(G) === true;\r\n    };\r\n\r\n    public directionalEulerian = async (directionalDegrees: {in: number; out: number}[]): Promise<boolean> => {\r\n        const scc = await GraphState.getProperty(\"stronglyConnectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        directionalDegrees.forEach((deg, id) => {\r\n            if (deg.in !== deg.out) {\r\n                eulerian = false;\r\n            }\r\n            if (deg.in > 0) {\r\n                if (component === -1) {\r\n                    component = scc[id];\r\n                }\r\n                if (component !== scc[id]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n\r\n    public hasEulerianCircuit = async (degrees: number[]): Promise<boolean> => {\r\n        const oddDegree = degrees.filter((v) => {\r\n            return v % 2 !== 0;\r\n        });\r\n\r\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\r\n        if (oddDegree.length !== 0) {\r\n            return false;\r\n        }\r\n\r\n        const cc = await GraphState.getProperty(\"connectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        degrees.forEach((v, i) => {\r\n            if (v !== 0) {\r\n                if (component === -1) {\r\n                    component = cc[i];\r\n                }\r\n                if (component !== cc[i]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n}\r\n\r\n"],"sourceRoot":""}