{"version":3,"sources":["webpack:///./src/js/SpanningTree.ts","webpack:///./src/js/GraphAlgorithms.ts"],"names":["SpanningTree","V","this","id","v","push","prototype","union","w","q","root","p","connected","GraphAlgorithms_GraphAlgorithms","_this","colorNetwork","G","graphState","graph","nodeArr","genericHelpers","datasetToArray","getAllNodes","degrees","getAllOutDegrees","vertexOrder","sort","a","b","colorIndex","currentColor","length","shift","myGroup","i","conflict","j","areAdjacent","splice","colors","chromaticNumber","max","flatten","connectedComponents","components","componentCount","setComponentNum","getNumberOfNodes","depthFirstSearch","forEach","Promise","resolve","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","showSimpleModal","queue","_nodes","enqueue","priority","key","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","_i","vertexAdjacency_1","bottleneckValue","maxFlow","flowPath","f","vertexAdjacency_2","getFlows","kruskal","set","js_SpanningTree","mst","totalWeight","reduce","acc","topologicalSort","adjacency","getFullAdjacency","graphHelpers","findVertexDegreesDirectional","L","filter","n","in","edges","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","GraphAlgorithms_awaiter","getProperty","scc","_a","sent","eulerian","component","deg","out","hasEulerianCircuit","cc"],"mappings":"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","file":"2-d8000a36a4ea585bbbc8.min.js","sourcesContent":["\"use strict\";\r\n\r\nexport default class SpanningTree {\r\n    private readonly id: number[];\r\n\r\n    constructor(V: number) {\r\n        this.id = [];\r\n        for (let v = 0; v < V; v++) {\r\n            this.id.push(v);\r\n        }\r\n    }\r\n\r\n    union(v: number, w: number) {\r\n        const q = this.root(v);\r\n        const p = this.root(w);\r\n\r\n        if (p !== q) {\r\n            this.id[p] = q;\r\n        }\r\n    }\r\n\r\n    root(q: number) {\r\n        while (this.id[q] !== q) {\r\n            q = this.id[q];\r\n        }\r\n        return q;\r\n    }\r\n\r\n    connected(v: number, w: number) {\r\n        return this.root(v) === this.root(w);\r\n    }\r\n}\r\n","\"use strict\";\r\n\r\nimport genericH from './genericHelpers';\r\nimport graphH from './graphHelpers';\r\nimport SpanningTree from './SpanningTree';\r\nimport EdgeImmut from \"./GraphImmut/EdgeImmut\";\r\nimport NodeImmut from \"./GraphImmut/NodeImmut\";\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\nimport GraphState from \"./graphState\";\r\n\r\nexport default class GraphAlgorithms {\r\n    // Welsh-Powell Algorithm\r\n    public colorNetwork = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number } => {\r\n        // Get node ID's only\r\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\r\n\r\n        // Put vertices in array in decreasing order of degree\r\n        const degrees = G.getAllOutDegrees();\r\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\r\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\r\n        });\r\n\r\n        const colorIndex = {};\r\n        let currentColor = 0;\r\n        while (vertexOrder.length > 0) {\r\n            const root = vertexOrder.shift();\r\n            colorIndex[root] = currentColor;\r\n\r\n            const myGroup = [];\r\n            myGroup.push(root);\r\n\r\n            for (let i = 0; i < vertexOrder.length;) {\r\n                const p = vertexOrder[i];\r\n                let conflict = false;\r\n\r\n                for (let j = 0; j < myGroup.length; j++) {\r\n                    if (G.areAdjacent(p, myGroup[j])) {\r\n                        i++;\r\n                        conflict = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (conflict) {\r\n                    continue;\r\n                }\r\n\r\n                colorIndex[p] = currentColor;\r\n                myGroup.push(p);\r\n                vertexOrder.splice(i, 1);\r\n            }\r\n\r\n            currentColor++;\r\n        }\r\n\r\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\r\n        return {colors: colorIndex, chromaticNumber};\r\n    };\r\n\r\n    public connectedComponents = (G: GraphImmut = GraphState.graph): Promise<{ components: {}; count: number }> => {\r\n        const components = {};\r\n        let componentCount = 0;\r\n        const setComponentNum = (v) => {\r\n            components[v] = componentCount;\r\n        };\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in components)) {\r\n                const visited = this.depthFirstSearch(G, i);\r\n                visited.forEach(setComponentNum);\r\n                componentCount++;\r\n            }\r\n        }\r\n\r\n        return Promise.resolve({components, count: componentCount});\r\n    };\r\n\r\n    public depthFirstSearch = (G: GraphImmut = GraphState.graph, start): any[] => {\r\n        const visisted = [];\r\n        const Stack = [];\r\n        Stack.push(start);\r\n        while (Stack.length > 0) {\r\n            const v = Stack.pop();\r\n            if (!visisted.includes(v)) {\r\n                visisted.push(v);\r\n                G.getNodeAdjacency(v).forEach((nodeID) => {\r\n                    Stack.push(nodeID);\r\n                });\r\n            }\r\n        }\r\n\r\n        return visisted;\r\n    };\r\n\r\n    // Tarjan's algorithm\r\n    public stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): Promise<{ components: {}; count: number }> => {\r\n        let index = 0;\r\n        const indices = {};\r\n        const lowlink = {};\r\n        const S = [];\r\n        const components = {};\r\n        let componentCount = 0;\r\n\r\n        const strongConnect = (v) => {\r\n            indices[v] = index;\r\n            lowlink[v] = index++;\r\n            S.push(v);\r\n\r\n            G.getNodeAdjacency(v).forEach((w) => {\r\n                if (!(w in indices)) {\r\n                    strongConnect(w);\r\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\r\n                }\r\n                else if (S.includes(w)) {\r\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\r\n                }\r\n            });\r\n\r\n            if (lowlink[v] === indices[v]) {\r\n                let w = -1;\r\n                if (S.length > 0) {\r\n                    do {\r\n                        w = S.pop();\r\n                        components[w] = componentCount;\r\n                    }\r\n                    while (w !== v);\r\n                    componentCount++;\r\n                }\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in indices)) {\r\n                strongConnect(i);\r\n            }\r\n        }\r\n\r\n        return Promise.resolve({components, count: componentCount});\r\n    };\r\n\r\n    public breadthFirstSearch = (startNodeID, targetNodeID, G: GraphImmut = GraphState.graph): { pathExists: boolean; path: any[]; distance: number; weight: number } => {\r\n        // Perform the BFS\r\n        const visisted = [];\r\n        const Q = []; // Use Push and Shift for Queue operations\r\n        const edgeTo = {};\r\n\r\n        Q.push(startNodeID);\r\n        while (Q.length > 0) {\r\n            const x = Q.shift();\r\n            if (!visisted.includes(x)) {\r\n                visisted.push(x);\r\n                G.getNodeAdjacency(x).forEach((y) => {\r\n                    if (!visisted.includes(y)) {\r\n                        edgeTo[y] = x;\r\n                        Q.push(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visisted.includes(targetNodeID)) {\r\n            // Build the path\r\n            const path = [];\r\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\r\n                path.push(x);\r\n            }\r\n            path.push(startNodeID);\r\n            path.reverse();\r\n\r\n            // Get the path weight\r\n            let weight = 0;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\r\n            }\r\n\r\n            return {pathExists: true, path, distance: path.length, weight};\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, weight: -1};\r\n    };\r\n\r\n    public dijkstraSearch = (startNodeID, targetNodeID, G: GraphImmut = GraphState.graph): any => {\r\n        if (!G.isDirected()) {\r\n            G = G.asDirected(true);\r\n        }\r\n        if (!G.isWeighted()) {\r\n            G = G.asWeighted();\r\n        }\r\n\r\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find((edge) => {\r\n            return edge.getWeight() < 0;\r\n        });\r\n        if (typeof nonNegative !== \"undefined\") {\r\n            genericH.showSimpleModal(\"Dijkstra Error\", \"<p>The Dijkstra algorithm only works on graphs\" +\r\n                \" with totally non-negative edge weights. Please fix the graph so that there are no\" +\r\n                \" negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves\" +\r\n                \" exactly this problem.</p>\");\r\n            return false;\r\n        }\r\n\r\n        // Priority Queue implementation for Dijkstra\r\n        const PriorityQueue = function () {\r\n            this._nodes = [];\r\n\r\n            this.enqueue = function (priority, key) {\r\n                this._nodes.push({key, priority});\r\n                this.sort();\r\n            };\r\n            this.dequeue = function () {\r\n                return this._nodes.shift().key;\r\n            };\r\n            this.sort = function () {\r\n                this._nodes.sort(function (a, b) {\r\n                    return a.priority - b.priority;\r\n                });\r\n            };\r\n            this.isEmpty = function () {\r\n                return !this._nodes.length;\r\n            };\r\n        };\r\n\r\n        const queue = new PriorityQueue();\r\n        const distances = {};\r\n        const previous = {};\r\n        let path = [];\r\n\r\n        // Initialize Queue and distances\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach((node) => {\r\n            let dist = Infinity;\r\n            if (node.getID() === startNodeID) {\r\n                dist = 0;\r\n            }\r\n\r\n            distances[node.getID()] = dist;\r\n            queue.enqueue(dist, node.getID());\r\n            previous[node.getID()] = null;\r\n        });\r\n\r\n        while (!queue.isEmpty()) {\r\n            let smallest = queue.dequeue();\r\n\r\n            if (smallest === targetNodeID) {\r\n                path = [];\r\n                while (previous[smallest] !== null) {\r\n                    path.push(smallest);\r\n                    smallest = previous[smallest];\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (distances[smallest] === Infinity) {\r\n                continue;\r\n            }\r\n\r\n            G.getNodeAdjacency(smallest).forEach((neighbor) => {\r\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\r\n\r\n                if (alt < distances[neighbor]) {\r\n                    distances[neighbor] = alt;\r\n                    previous[neighbor] = smallest;\r\n\r\n                    queue.enqueue(alt, neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        path.push(startNodeID);\r\n        path.reverse();\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            return {pathExists: true, path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    };\r\n\r\n    public bellmanFord = (startNodeID, targetNodeID, G: GraphImmut = GraphState.graph): any => {\r\n        const distances = [];\r\n        const parents = [];\r\n\r\n        // Initialize\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach((node) => {\r\n            distances[node.getID()] = Infinity;\r\n            parents[node.getID()] = null;\r\n        });\r\n\r\n        // Relax Edges\r\n        distances[startNodeID] = 0;\r\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\r\n            (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\r\n                    parents[edge.getTo()] = edge.getFrom();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for negative weight cycles\r\n        let negativeCylce = false;\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                negativeCylce = true;\r\n            }\r\n        });\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            const path = [targetNodeID];\r\n            while (!path.includes(startNodeID)) {\r\n                path.push(parents[path.slice().pop()]);\r\n            }\r\n            path.reverse();\r\n\r\n            return {pathExists: true, path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n        if (negativeCylce) {\r\n            genericH.showSimpleModal(\"Bellman-Ford Error\", \"<p>The Bellman-Ford algorithm only works on graphs\" +\r\n                \" with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>\");\r\n            return false;\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    };\r\n\r\n    public fordFulkerson = (startNodeID, targetNodeID, G: GraphImmut = GraphState.graph): any => {\r\n        // Must be a directed graph\r\n        if (!G.isDirected()) {\r\n            return false;\r\n        }\r\n\r\n        // Source == sink\r\n        if (startNodeID === targetNodeID) {\r\n            return false;\r\n        }\r\n\r\n        const bfs = this.breadthFirstSearch(startNodeID, targetNodeID, G);\r\n        // No path from source to sink\r\n        if (!bfs.pathExists) {\r\n            return false;\r\n        }\r\n\r\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\r\n        G = G.reduceMultiGraph((a, b) => {\r\n            return a + b;\r\n        });\r\n\r\n        const V = G.getNumberOfNodes();\r\n        let value = 0;\r\n        let marked = null;\r\n        let edgeTo = null;\r\n\r\n        const edgeProperties = {};\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach((edge) => {\r\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\r\n                from: edge.getFrom(),\r\n                to: edge.getTo(),\r\n                capacity: edge.getWeight(),\r\n                flow: 0\r\n            };\r\n        });\r\n\r\n        const other = (e, x) => {\r\n            e = e.split(\"_\");\r\n            const a = parseInt(e[0]);\r\n            const b = parseInt(e[1]);\r\n            return x === a ? b : a;\r\n        };\r\n\r\n        const residualCapacity = (e, x) => {\r\n            const edge = e.split(\"_\");\r\n            const a = parseInt(edge[0]);\r\n            if (x === a) {\r\n                return edgeProperties[e].flow;\r\n            }\r\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\r\n        };\r\n\r\n        const addResidualFlow = (e, x, deltaFlow) => {\r\n            const edge = e.split(\"_\");\r\n            const v = parseInt(edge[0]);\r\n            if (x === v) {\r\n                edgeProperties[e].flow -= deltaFlow;\r\n            }\r\n            else {\r\n                edgeProperties[e].flow += deltaFlow;\r\n            }\r\n        };\r\n\r\n        const hasAugmentedPath = () => {\r\n            marked = [];\r\n            edgeTo = [];\r\n            for (let v = 0; v < V; ++v) {\r\n                marked.push(false);\r\n                edgeTo.push(null);\r\n            }\r\n\r\n            const queue = [];\r\n            queue.push(startNodeID);\r\n\r\n            marked[startNodeID] = true;\r\n            while (queue.length > 0) {\r\n                const v = queue.shift();\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for(const i of vertexAdjacency){\r\n                    const e = `${v}_${i}`;\r\n                    const w = other(e, v);\r\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\r\n                        edgeTo[w] = e;\r\n                        marked[w] = true;\r\n                        if (w === targetNodeID) {\r\n                            return true;\r\n                        }\r\n\r\n                        queue.push(w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        while (hasAugmentedPath()) {\r\n            let bottleneckValue = Infinity;\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x], x));\r\n            }\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                addResidualFlow(edgeTo[x], x, bottleneckValue);\r\n            }\r\n            value += bottleneckValue;\r\n        }\r\n\r\n        const getFlows = () => {\r\n            const f = [];\r\n            for (let v = 0; v < V; v++) {\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for(const i of vertexAdjacency){\r\n                    const e = `${v}_${i}`;\r\n                    if (edgeProperties[e].flow > 0) {\r\n                        f.push(edgeProperties[e]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return f;\r\n        };\r\n\r\n        return {maxFlow: value, flowPath: getFlows()};\r\n    };\r\n\r\n    public kruskal = (G: GraphImmut = GraphState.graph): { mst: any[]; totalWeight: any } => {\r\n        // If we have a multigraph, reduce it by using the minimum edge weights\r\n        G.reduceMultiGraph(Math.min, Infinity);\r\n\r\n        const Q = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\r\n        Q.sort((a, b) => {\r\n            return a.getWeight() - b.getWeight();\r\n        });\r\n\r\n        const kruskal = [];\r\n        const set = new SpanningTree(G.getNumberOfNodes());\r\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\r\n            const e = Q.shift();\r\n            if (!set.connected(e.getFrom(), e.getTo())) {\r\n                set.union(e.getFrom(), e.getTo());\r\n                kruskal.push(e);\r\n            }\r\n        }\r\n\r\n        // Get the total cost of the MST\r\n        const weight = kruskal.reduce((acc, e) => {\r\n            return acc + e.getWeight();\r\n        }, 0);\r\n\r\n        return {mst: kruskal, totalWeight: weight};\r\n    };\r\n\r\n    public topologicalSort = (G: GraphImmut = GraphState.graph): boolean | any[] => {\r\n        const adjacency = G.getFullAdjacency();\r\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\r\n\r\n        const L = [];\r\n        const S = (G.getAllNodes(true) as NodeImmut[]).filter((n) => {\r\n            return degrees[n.getID()].in === 0;\r\n        });\r\n        let edges = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        while (S.length !== 0) {\r\n            const nodeN = S.pop();\r\n            L.push(nodeN);\r\n\r\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\r\n\r\n            // Remove n to m edges for all nodes m\r\n            edges = edges.filter((edge) => {\r\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\r\n                    degrees[edge.getTo()].in--;\r\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter((v) => {\r\n                        return v !== edge.getTo();\r\n                    });\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // If m has no more incoming edges, add it to S\r\n            nodeNConnectedTo.forEach((mID) => {\r\n                if (degrees[mID].in === 0) {\r\n                    S.push(G.getNode(mID, true) as NodeImmut);\r\n                }\r\n            });\r\n        }\r\n\r\n        return edges.length > 0 || L;\r\n    };\r\n\r\n    public isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\r\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\r\n        return this.topologicalSort(G) === true;\r\n    };\r\n\r\n    public directionalEulerian = async (directionalDegrees): Promise<boolean> => {\r\n        const scc = await GraphState.getProperty(\"stronglyConnectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        directionalDegrees.forEach((deg, id) => {\r\n            if (deg.in !== deg.out) {\r\n                eulerian = false;\r\n            }\r\n            if (deg.in > 0) {\r\n                if (component === -1) {\r\n                    component = scc[id];\r\n                }\r\n                if (component !== scc[id]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n\r\n    public hasEulerianCircuit = async (degrees): Promise<boolean> => {\r\n        const oddDegree = degrees.filter((v) => {\r\n            return v % 2 !== 0;\r\n        });\r\n\r\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\r\n        if (oddDegree.length !== 0) {\r\n            return false;\r\n        }\r\n\r\n        const cc = await GraphState.getProperty(\"connectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        degrees.forEach((v, i) => {\r\n            if (v !== 0) {\r\n                if (component === -1) {\r\n                    component = cc[i];\r\n                }\r\n                if (component !== cc[i]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n}\r\n\r\n"],"sourceRoot":""}