{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/graphState.ts","webpack:///./src/js/genericHelpers.ts","webpack:///./src/js/graphHelpers.ts","webpack:///./src/js/main.ts","webpack:///./src/js/settings.ts","webpack:///./src/js/UIInteractions.ts","webpack:///./src/js/app.ts","webpack:///./src/js/GraphImmut/NodeImmut.ts","webpack:///./src/js/GraphImmut/EdgeImmut.ts","webpack:///./src/js/GraphImmut/GraphImmut.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","5","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","head","document","getElementsByTagName","script","createElement","charset","timeout","nc","setAttribute","src","p","0","1","2","setTimeout","onScriptComplete","type","target","event","onerror","onload","clearTimeout","chunk","errorType","realSrc","error","Error","request","undefined","appendChild","all","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","bind","slice","GraphState","setUpToDate","listOptions","upToDate","forEach","v","always","indexOf","makeAndPrintProperties","getProperty","updateIfNotUpdated","a","find","applyFunc","_a","sent","state","graphProperties","getPropertyImm","recalcLong","directional","settings","getOption","vertices","graph","getNumberOfNodes","edges","getNumberOfEdges","keys","__awaiter","_this","printableProperties","map","_b","_c","printGraphProperties","properties","k","_genericHelpers__WEBPACK_IMPORTED_MODULE_2__","toTitleCase","trim","htmlEncode","jquery__WEBPACK_IMPORTED_MODULE_0__","html","addEdge","from","to","weight","main","setData","nodes","clearColorFromNodes","getAllNodes","getAllEdges","addNode","label","x","y","editNode","id","getGraphData","editEdge","newWeight","oldWeight","newGraph","_GraphImmut_GraphImmut__WEBPACK_IMPORTED_MODULE_3__","deleteEdge","deleteNode","color","nodeIDToLabel","getNode","_GraphImmut_NodeImmut__WEBPACK_IMPORTED_MODULE_4__","getLabel","toString","nodeLabelToID","filter","node","toLowerCase","getID","rID","found","getGraphAsDataSet","isWeighted","vis_index_network__WEBPACK_IMPORTED_MODULE_1__","setLocations","locations","newNodes","getAllNodesAsImmutableList","parseInt","getAttribute","set","getAllEdgesAsImmutableList","isDirected","clearColors","directed","weighted","backHistory","forwardHistory","maxHistory","ui","makeAndPrintGraphColoring","makeAndPrintEulerian","makeAndPrintConnectedComponents","makeAndPrintStronglyConnectedComponents","makeAndPrintIsCyclic","stronglyConnectedComponents","connectedComponents","graphColoring","eulerian","Chromatic Number","Connected Components","Strongly Connected Components","cyclic","defaultCancelCb","$modal","modal","self","deepFreeze","freeze","getOwnPropertyNames","prop","isFrozen","sort","arr","compareFunction","datasetToArray","ds","key","keepOnlyKeys","getFileExtension","filename","split","string","text","replace","printout","escape","flatten","rotate","max","iterable","reduce","b","Math","str","match","toUpperCase","showSimpleModal","title","body","showFormModal","initialValue","makeFormModal","successText","form","footer","f","class","formRow","basicMap","extraAttrs","attrname","validFunc","container","validationFunc","generalValidator","valueMutator","$v","val","valid","removeClass","next","remove","addClass","after","append","checked","for","prepend","clickDismiss","$b","onclick","on","parseFloat","$options_1","optionText","oText","oIndex","optionValues","$footer","tabindex","role","aria-hidden","data-dismiss","aria-label","off","last","trigger","first","successCb","cancelCb","vals","hasErrors","each","tagName","attr","files","hasClass","__webpack_exports__","findVertexDegreesDirectional","adjacencyMatrix","degrees","out","in","outV","interpolateNodesFromEdges","main_self","graphState","getElementById","visWeightEdgeEdit","callback","genericHelpers","visOptions","interaction","hover","manipulation","$popup","saveData","cancelEdit","confirm","network","_data","fromId","toId","operation","nodeLabelIDValidator","applyColors","main_awaiter","graphColors","chromaticNumber","colors","randomColor_default","count","luminosity","G","recalcProps","graphChanged","rearrangeGraph","saveState","changeOption","g","GraphImmut","randomizeNetworkLayoutSeed","getPositions","disableEditMode","enableEditMode","printGraphAlgorithms","saveStateLocalStorage","getStateForSaving","jquery","parent","includes","Array","isArray","undo","applyState","redo","newState","firstLoad","currentState","pop","oldKey","checkForLocalStorage","localStorage","setItem","JSON","stringify","shuffleNetworkLayout","round","random","layoutEngine","randomSeed","initialRandomSeed","addNetworkListeners","editEdgeMode","lastNetworkClickEvent","has","parents","deleteSelected","ctrlKey","shiftKey","settings_self","defaults","nodePhysics","direction","weights","current","removeItem","saveSettings","loadSettings","parse","getItem","setAll","setOptions","physics","arrows","editWithoutDrag","option","resetToDefault","asChangedDirectedWeighted","UIInteractions_makeAndPrintShortestPath","fn","values","source","sink","pathExists","distance","cost","path","UIInteractions_callWithGraphAlgorithms","UIInteractions_awaiter","then","gAlgo","UIInteractions_makeAndPrintComponents","stronglyConnected","cc","componentKey","components","UIInteractions","getAlgorithms","display","makeAndPrintBFS","makeAndPrintDijkstra","makeAndPrintBFSP","makeAndPrintFFMCMF","makeAndPrintKruskal","makeAndPrintTopologicalSort","makeAndPrintDirectionalEulerian","registerListeners","this","makeSimpleClickListener","selector","preventDefault","printHelp","printOptions","predefined","default","Petersen","Konigsberg","Complete","Hypercube","Custom","makeImportFileModal","makeImportTextModal","makeExportFileModal","makeExportTextModal","asDirected","asUndirected","asWeighted","asUnweighted","colorNetwork","directionalEulerian","graphHelpers","getFullAdjacency","hasEulerianCircuit","getAllOutDegrees","breadthFirstSearch","dijkstraSearch","bellmanFord","fordFulkerson","maxFlow","flowPath","flow","capacity","kruskal","totalWeight","mst","isGraphCyclic","topologicalSort","$div","empty","addAlgoToPane","alg","href","index_network","js_UIInteractions","singleton","install","Raven","app_loadDefault","app_s","app_awaiter","NodeImmut","attributes","_newTarget","toPlain","toReturn","attribute","getAllAttributes","assign","EdgeImmut","getFrom","getTo","getWeight","GraphImmut_filterNodeExtraAttr","obj","GraphImmut_genericEdgesToImmutEdges","nodeMap","newEdges","immutable","edge","GraphImmut_EdgeImmut","GraphImmut_genericNodesToImmutNodes","floor","nodeNum_1","GraphImmut_GraphImmut","numNodes","size","numEdges","alignNodeIDs","alignTo","nodeCount","rich","deleteAll","foundOneEdge","foundFirst","index","toArray","doubleEdges","addedEdges","getNodeAdjacency","adj","areAdjacent","id1","id2","getEdgesBetween","edgeList","getMinWeightEdgeBetween","minWeight","Infinity","reduceMultiGraph","reducer","multiEdges","uniques","Set","acc","keep","duplicateEdge"],"mappings":"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","file":"bundle-ab70d5afa4caf0ab81fb.min.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t5: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\t\tvar script = document.createElement('script');\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \"-\" + {\"0\":\"664acc8ea8f7eabb128e\",\"1\":\"200c1dffc07d0dde6cb6\",\"2\":\"d8000a36a4ea585bbbc8\"}[chunkId] + \".min.js\";\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tfunction onScriptComplete(event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\tvar error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\thead.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([43,3]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\nimport {DataSet} from 'vis/index-network';\r\nimport help from './genericHelpers';\r\nimport GraphImmut from './GraphImmut/GraphImmut';\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\nimport NodeImmut, {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\n\r\ndeclare interface GraphProperties {\r\n    name: string;\r\n    upToDate: boolean;\r\n    type: string;\r\n    always?: boolean;\r\n    applyFunc?: () => Promise<any>;\r\n}\r\n\r\nexport default class GraphState {\r\n    public static backHistory: any = [];\r\n    public static forwardHistory: any = [];\r\n    public static maxHistory = 10;\r\n    public static upToDate: GraphProperties[] = [\r\n        {\r\n            name: \"Chromatic Number\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {\r\n            name: \"graphColoring\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {name: \"vertices\", upToDate: true, always: true, type: \"property\"},\r\n        {name: \"edges\", upToDate: true, always: true, type: \"property\"},\r\n        {\r\n            name: \"eulerian\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintEulerian();\r\n            }\r\n        },\r\n        {\r\n            name: \"Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"connectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"Strongly Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"stronglyConnectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"cyclic\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                return window.ui.makeAndPrintIsCyclic();\r\n            }\r\n        },\r\n    ];\r\n    public static state = {\r\n        stronglyConnectedComponents: null,\r\n        connectedComponents: null,\r\n        graphColoring: null,\r\n    };\r\n    public static graph: GraphImmut = null;\r\n    public static graphProperties = {\r\n        vertices: 0,\r\n        edges: 0,\r\n        eulerian: false,\r\n        \"Chromatic Number\": null,\r\n        \"Connected Components\": null,\r\n        \"Strongly Connected Components\": null,\r\n        cyclic: false,\r\n    };\r\n\r\n    static setUpToDate(value = false, listOptions?: string[]) {\r\n        const all = listOptions === null || typeof listOptions === \"undefined\";\r\n        let property = false;\r\n        GraphState.upToDate.forEach((v) => {\r\n            if ((!(\"always\" in v) || !v.always) && (all || listOptions.indexOf(v.name) > -1)) {\r\n                v.upToDate = value;\r\n                if (v.type === \"property\") {\r\n                    property = true;\r\n                }\r\n            }\r\n        });\r\n        if (property) {\r\n            GraphState.makeAndPrintProperties();\r\n        }\r\n    }\r\n\r\n    static async getProperty(property: string, updateIfNotUpdated = false): Promise<any> {\r\n        const a = GraphState.upToDate.find((v) => {\r\n            return (\"name\" in v && v.name === property);\r\n        });\r\n        if (!a.upToDate) {\r\n            if (\"applyFunc\" in a && updateIfNotUpdated) {\r\n                await a.applyFunc();\r\n            }\r\n            else {\r\n                return Promise.resolve(null);\r\n            }\r\n        }\r\n        if (a.type === \"state\") {\r\n            return Promise.resolve(GraphState.state[property]);\r\n        }\r\n        return Promise.resolve(GraphState.graphProperties[property]);\r\n    }\r\n\r\n    static getPropertyImm(property: string): any {\r\n        const a = GraphState.upToDate.find((v) => {\r\n            return (\"name\" in v && v.name === property);\r\n        });\r\n        if (!a.upToDate) {\r\n            return null;\r\n        }\r\n        if (a.type === \"state\") {\r\n            return GraphState.state[property];\r\n        }\r\n        return GraphState.graphProperties[property];\r\n    }\r\n\r\n    static async makeAndPrintProperties(recalcLong = false) {\r\n        const directional = window.settings.getOption(\"direction\");\r\n\r\n        GraphState.graphProperties.vertices = GraphState.graph.getNumberOfNodes();\r\n        GraphState.graphProperties.edges = GraphState.graph.getNumberOfEdges();\r\n\r\n        if (!directional) {\r\n            await GraphState.getProperty(\"eulerian\", true);\r\n        }\r\n\r\n        const p = Object.keys(GraphState.graphProperties);\r\n        if (recalcLong) {\r\n            p.forEach(async (v) => {\r\n                await GraphState.getProperty(v, true);\r\n            });\r\n        }\r\n\r\n        const printableProperties: any = {};\r\n        await Promise.all(p.map(async (v) => {\r\n            printableProperties[v] = await GraphState.getProperty(v);\r\n        }));\r\n\r\n        GraphState.printGraphProperties(printableProperties);\r\n    }\r\n\r\n    static printGraphProperties(properties: any) {\r\n        let p = \"\";\r\n        Object.keys(properties).forEach((k) => {\r\n            if (properties[k] !== null) {\r\n                p += `${help.toTitleCase(k)}: ${properties[k]}\\n`;\r\n            }\r\n        });\r\n        p = p.trim();\r\n        p = help.htmlEncode(p);\r\n        $(\"#graphProps\").html(`<p class='nav-link'>${p}</p>`);\r\n    }\r\n\r\n    static addEdge(from, to, weight = 0, graph = GraphState.graph) {\r\n        graph = graph.addEdge(from, to, weight);\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: graph.getAllEdges() as EdgeImmutPlain[]\r\n        });\r\n    }\r\n\r\n    static addNode(data, graph = GraphState.graph) {\r\n        graph = graph.addNode({label: data.label, x: data.x, y: data.y});\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: graph.getAllEdges() as EdgeImmutPlain[]\r\n        });\r\n    }\r\n\r\n    static editNode(id, label, graph = GraphState.graph) {\r\n        graph = graph.editNode(id, {label});\r\n        window.main.setData(GraphState.getGraphData(graph), false, false);\r\n    }\r\n\r\n    static editEdge(from, to, newWeight, oldWeight, graph = GraphState.graph) {\r\n        const newGraph = graph.editEdge(from, to, newWeight, oldWeight);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData(GraphState.getGraphData(newGraph), false, false);\r\n        }\r\n    }\r\n\r\n    static deleteEdge(from, to, weight = null, graph = GraphState.graph) {\r\n        graph = graph.deleteEdge(from, to, weight, false);\r\n        window.main.setData({\r\n            nodes: GraphState.clearColorFromNodes(graph.getAllNodes() as NodeImmutPlain[]),\r\n            edges: graph.getAllEdges() as EdgeImmutPlain[]\r\n        });\r\n    }\r\n\r\n    static deleteNode(id, graph = GraphState.graph) {\r\n        const newGraph = graph.deleteNode(id);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData({\r\n                nodes: GraphState.clearColorFromNodes(newGraph.getAllNodes() as NodeImmutPlain[]),\r\n                edges: newGraph.getAllEdges() as EdgeImmutPlain[]\r\n            });\r\n        }\r\n    }\r\n\r\n    static clearColorFromNodes(nodes: NodeImmutPlain[]) {\r\n        nodes.forEach((v) => {\r\n            v.color = null;\r\n        });\r\n        return nodes;\r\n    }\r\n\r\n    static nodeIDToLabel(id, graph = GraphState.graph) {\r\n        const n = graph.getNode(id, true);\r\n        if (n !== false && n !== null && n instanceof NodeImmut && n.getLabel().trim().length > 0) {\r\n            return n.getLabel().trim();\r\n        }\r\n\r\n        return id.toString();\r\n    }\r\n\r\n    // Preferentially search by ID, label, and case-insensitive label\r\n    static nodeLabelToID(label, graph = GraphState.graph) {\r\n        let n = graph.getAllNodes(true) as NodeImmut[];\r\n        n = n.filter((node) => {\r\n            return node.getLabel().toLowerCase() === label.toLowerCase() || node.getID().toString() === label;\r\n        });\r\n\r\n        if (n.length === 0) {\r\n            return -1;\r\n        }\r\n        else if (n.length === 1) {\r\n            return n[0].getID();\r\n        }\r\n\r\n        let rID = -1;\r\n        let found = false;\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getID().toString() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel().toLowerCase() === label.toLowerCase()) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        return rID;\r\n    }\r\n\r\n    // Return graph as a Vis compatible dataset\r\n    static getGraphAsDataSet(graph) {\r\n        const d = GraphState.getGraphData(graph);\r\n        if (graph.isWeighted()) {\r\n            d.edges.forEach((e) => {\r\n                e.label = e.weight.toString();\r\n            });\r\n        }\r\n\r\n        return {nodes: new DataSet(d.nodes), edges: new DataSet(d.edges)};\r\n    }\r\n\r\n    static setLocations(locations, graph = GraphState.graph) {\r\n        let newNodes = graph.getAllNodesAsImmutableList();\r\n        Object.keys(locations).forEach((i) => {\r\n            const v = locations[i];\r\n            const node = newNodes.get(parseInt(i));\r\n            // Only change when there is actually a new position\r\n            if (node.getAttribute(\"x\") !== v.x || node.getAttribute(\"y\") !== v.y) {\r\n                // Batch up all changes that we'll be making\r\n                newNodes = newNodes.set(parseInt(i), node.editNode(node.getLabel(), {x: v.x, y: v.y}));\r\n            }\r\n        });\r\n\r\n        return new GraphImmut(newNodes, graph.getAllEdgesAsImmutableList(), graph.isDirected(), graph.isWeighted());\r\n    }\r\n\r\n    static getGraphData(graph = GraphState.graph, clearColors = false): GraphPlain {\r\n        const nodes = graph.getAllNodes() as NodeImmutPlain[];\r\n        return {\r\n            nodes: clearColors ? GraphState.clearColorFromNodes(nodes) : nodes,\r\n            edges: graph.getAllEdges() as EdgeImmutPlain[],\r\n            directed: graph.isDirected(),\r\n            weighted: graph.isWeighted()\r\n        };\r\n    }\r\n}\r\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\n\r\ndeclare interface ModalFormRow {\r\n    type: string;\r\n    label?: string;\r\n    initialValue?: any;\r\n    id?: string | number;\r\n    extraAttrs?: any;\r\n    validationFunc?: (value?: any, container?: JQuery) => boolean | string;\r\n    clickDismiss?: boolean;\r\n    onclick?: (...args: any[]) => void;\r\n    optionText?: any[];\r\n    optionValues?: any[];\r\n}\r\n\r\ndeclare interface BasicMapType {\r\n    class: string;\r\n    id: string;\r\n    value: any,\r\n\r\n    [key: number]: any,\r\n\r\n    [key: string]: any\r\n}\r\n\r\nconst defaultCancelCb = ($modal) => {\r\n    $modal.modal(\"hide\");\r\n};\r\n\r\nconst self = {\r\n    deepFreeze: <T>(o: T): Readonly<T> => {\r\n        Object.freeze(o);\r\n\r\n        Object.getOwnPropertyNames(o).forEach((prop: string | number) => {\r\n            if (o.hasOwnProperty(prop) && (o as any)[prop] !== null\r\n                && (typeof (o as any)[prop] === \"object\" || typeof (o as any)[prop] === \"function\")\r\n                && !Object.isFrozen((o as any)[prop])) {\r\n                self.deepFreeze((o as any)[prop]);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    },\r\n\r\n    sort: <T>(arr: T[], compareFunction: (a: any, b: any) => number): T[] => {\r\n        return [...arr].sort(compareFunction);\r\n    },\r\n\r\n    datasetToArray: (ds: any, key: string): Readonly<any[]> => {\r\n        const r: any[] = [];\r\n        ds.forEach((v) => {\r\n            r.push(v[key]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    keepOnlyKeys: <T>(arr: T[], keys: string[]): Readonly<T[]> => {\r\n        arr = arr.slice();\r\n        arr.forEach((v: any) => {\r\n            const k = Object.keys(v);\r\n            k.forEach((key) => {\r\n                if (keys.indexOf(key) < 0) {\r\n                    delete v[key];\r\n                }\r\n            });\r\n        });\r\n        return self.deepFreeze(arr);\r\n    },\r\n\r\n    getFileExtension: (filename: string): string => {\r\n        return filename.split(\".\").splice(-1)[0];\r\n    },\r\n\r\n    htmlEncode: (string: string): string => {\r\n        string = $(\"<div>\").text(string).html();\r\n        string = string.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>');\r\n        return string;\r\n    },\r\n\r\n    printout: (text: string, escape?: string): void => {\r\n        if (escape) {\r\n            text = this.htmlEncode(escape);\r\n        }\r\n        $(\"#printout\").html(text);\r\n    },\r\n\r\n    flatten: <T>(map: { [key: string]: T }): Readonly<T[]> => {\r\n        const r: T[] = [];\r\n        Object.keys(map).forEach((i) => {\r\n            r.push(map[i]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    rotate: (map: any): Readonly<any> => {\r\n        const r: any = {};\r\n        Object.keys(map).forEach((i) => {\r\n            if (map[i] in r) {\r\n                r[map[i]].push(i);\r\n            }\r\n            else {\r\n                r[map[i]] = [i];\r\n            }\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    max: (iterable: any[]): number => {\r\n        return iterable.reduce((a, b) => {\r\n            return Math.max(a, b);\r\n        });\r\n    },\r\n\r\n    toTitleCase: (str: string): string => {\r\n        return str.replace(/(?:^|\\s)\\w/g, (match) => {\r\n            return match.toUpperCase();\r\n        });\r\n    },\r\n\r\n    showSimpleModal: (title: string, body: string): void => {\r\n        self.showFormModal(null, title, null, [{type: \"html\", initialValue: body}], null, false);\r\n    },\r\n\r\n    makeFormModal: (title: string, successText: string, form: ModalFormRow[], footer = true): JQuery => {\r\n        const f = $(\"<div>\", {class: \"modal-body form-group\"});\r\n        form.forEach((formRow, i) => {\r\n            if (!(\"initialValue\" in formRow)) {\r\n                formRow.initialValue = \"\";\r\n            }\r\n\r\n            let id = \"form-modal-\" + i;\r\n            if (\"id\" in formRow && formRow.id !== \"\" && formRow.id !== null && typeof formRow.id === \"string\") {\r\n                id = formRow.id;\r\n            }\r\n\r\n            const basicMap: BasicMapType = {class: \"form-control\", id, value: formRow.initialValue};\r\n\r\n            if (\"extraAttrs\" in formRow) {\r\n                Object.keys(formRow.extraAttrs).forEach((attrname) => {\r\n                    if (typeof formRow.extraAttrs[attrname] !== \"function\") {\r\n                        basicMap[attrname] = formRow.extraAttrs[attrname];\r\n                    }\r\n                });\r\n            }\r\n\r\n            let validFunc = (value?: any, container?: JQuery): string | boolean => true;\r\n            if (\"validationFunc\" in formRow) {\r\n                validFunc = formRow.validationFunc;\r\n            }\r\n\r\n            const generalValidator = (event: any, valueMutator: (v: any) => any = null) => {\r\n                const $v = $(event.target);\r\n                let val = $v.val();\r\n                if (valueMutator !== null && typeof valueMutator === \"function\") {\r\n                    val = valueMutator(val);\r\n                }\r\n                const valid = validFunc(val, $v);\r\n\r\n                if (valid === true) {\r\n                    $v.removeClass(\"is-invalid\").next(\"#feedback-\" + i).remove();\r\n                }\r\n                else {\r\n                    $v.addClass(\"is-invalid\");\r\n                    if ($v.next(\"#feedback-\" + i).length === 0) {\r\n                        $v.after($(\"<div>\", {class: \"invalid-feedback\", id: \"feedback-\" + i}).text(valid));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (formRow.type === \"html\") {\r\n                f.append($(formRow.initialValue));\r\n            }\r\n            else if (formRow.type === \"checkbox\") {\r\n                basicMap.type = \"checkbox\";\r\n                basicMap.class = \"form-check-input\";\r\n                delete basicMap.value;\r\n                if (formRow.initialValue) {\r\n                    basicMap.checked = \"\";\r\n                }\r\n\r\n                f.append($(\"<div>\", {class: \"form-check\"})\r\n                    .append($(\"<label>\", {for: id, class: \"form-check-label\"})\r\n                        .text(formRow.label).prepend($(\"<input>\", basicMap))\r\n                    )\r\n                );\r\n            }\r\n            else {\r\n                f.append($(\"<label>\", {for: id, class: \"col-form-label\"}).text(formRow.label));\r\n\r\n                if (formRow.type === \"button\") {\r\n                    if (\"clickDismiss\" in formRow && formRow.clickDismiss === true) {\r\n                        basicMap.class += \" btn-dismiss\";\r\n                    }\r\n                    const $b = $(\"<button>\", basicMap).text(formRow.initialValue);\r\n                    if (\"onclick\" in formRow && typeof formRow.onclick === \"function\") {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"numeric\") {\r\n                    basicMap.type = \"number\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", (e) => {\r\n                        generalValidator(e, parseFloat);\r\n                    }));\r\n                }\r\n                else if (formRow.type === \"text\") {\r\n                    basicMap.type = \"text\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"file\") {\r\n                    basicMap.type = \"file\";\r\n                    basicMap.class = \"form-control-file form-control\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"textarea\") {\r\n                    const $b = $(\"<textarea>\", basicMap).on(\"blur validate\", generalValidator);\r\n                    if (\"onclick\" in formRow) {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"select\") {\r\n                    const $options = $(\"<select>\", basicMap);\r\n                    formRow.optionText.forEach((oText, oIndex) => {\r\n                        if (oIndex < formRow.optionValues.length) {\r\n                            $options.append($(\"<option>\", {value: formRow.optionValues[oIndex]}).text(oText));\r\n                        }\r\n                        else {\r\n                            $options.append($(\"<option>\").text(oText));\r\n                        }\r\n                    });\r\n                    f.append($options.on(\"blur validate\", generalValidator));\r\n                }\r\n            }\r\n        });\r\n\r\n        let $footer = $(\"<div>\", {class: \"modal-footer\"})\r\n            .append($(\"<button>\", {class: \"btn btn-success\", type: \"button\"}).text(successText))\r\n            .append($(\"<button>\", {class: \"btn btn-danger btn-cancel\", type: \"button\"}).text(\"Cancel\"));\r\n\r\n        if (footer === false) {\r\n            $footer = null;\r\n        }\r\n\r\n        const $modal = ($(\"<div>\", {class: \"modal fade\", tabindex: \"-1\", role: \"dialog\", \"aria-hidden\": \"true\"}));\r\n        $modal\r\n            .append($(\"<div>\", {class: \"modal-dialog\"})\r\n                .append($(\"<div>\", {class: \"modal-content\"})\r\n                    .append($(\"<div>\", {class: \"modal-header\"})\r\n                        .append($(\"<h5>\", {class: \"modal-title\"}).text(title))\r\n                        .append($(\"<button>\", {class: \"close\", \"data-dismiss\": \"modal\", \"aria-label\": \"close\"})\r\n                            .append($(\"<span>\", {\"aria-hidden\": \"true\"}).html(\"&times;\"))\r\n                        )\r\n                    )\r\n                    .append(f)\r\n                    .append($footer)\r\n                )\r\n            );\r\n        $modal.find(\"input, textarea\").off(\"keyup\").on(\"keyup\", (e) => {\r\n            if (e.key === \"Enter\") {\r\n                $(\".btn-success\").last().trigger(\"click\");\r\n            }\r\n        });\r\n        $modal.on(\"shown.bs.modal\", () => {\r\n            $modal.find(\"input[type='text'], input[type='number'], textarea\").first().trigger(\"focus\");\r\n        });\r\n\r\n        return $modal;\r\n    },\r\n\r\n    showFormModal: (successCb: ($modal: JQuery, vals: any[]) => void,\r\n                    title: string, successText: string, form: ModalFormRow[],\r\n                    cancelCb: ($modal: JQuery) => void = defaultCancelCb, footer = true) => {\r\n        const $modal = self.makeFormModal(title, successText, form, footer);\r\n\r\n        $modal.on(\"click\", \".btn-cancel\", () => {\r\n            if (typeof cancelCb === \"function\") {\r\n                cancelCb($modal);\r\n            }\r\n            else {\r\n                $modal.modal(\"hide\");\r\n            }\r\n        }).on(\"click\", \".btn-dismiss\", () => {\r\n            $modal.modal(\"hide\");\r\n        }).on(\"click\", \".btn-success\", () => {\r\n            const vals: any[] = [];\r\n            let hasErrors = false;\r\n\r\n            $modal.find(\"input, textarea, select\").each((i, v) => {\r\n                const $v = $(v);\r\n\r\n                if (($v as any).tagName === \"SELECT\") {\r\n                    vals.push($v.find(\":selected\").val());\r\n                }\r\n                else if ($v.attr(\"type\") === \"checkbox\") {\r\n                    vals.push($v.prop(\"checked\"));\r\n                }\r\n                else if ($v.attr(\"type\") === \"file\") {\r\n                    vals.push(($v.get(0) as any).files);\r\n                }\r\n                else if ($v.attr(\"type\") === \"number\") {\r\n                    vals.push(parseFloat($v.val() as string));\r\n                }\r\n                else {\r\n                    vals.push($v.val());\r\n                }\r\n\r\n                if ($v.trigger(\"validate\").hasClass(\"is-invalid\")) {\r\n                    hasErrors = true;\r\n                }\r\n\r\n            });\r\n\r\n            if (!hasErrors && typeof successCb === \"function\") {\r\n                successCb($modal, vals);\r\n            }\r\n        }).on(\"hidden.bs.modal\", () => {\r\n            $modal.remove();\r\n        }).modal(\"show\");\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\nimport {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\n\r\nexport default {\r\n    findVertexDegreesDirectional: (adjacencyMatrix: Array<Array<number>>): Array<{ in: number; out: number; }> => {\r\n        // Adjacency stores IDs of edges TO\r\n        const degrees = [];\r\n        adjacencyMatrix.forEach((v, i) => {\r\n            if (i in degrees) {\r\n                degrees[i].out += v.length;\r\n            }\r\n            else {\r\n                degrees[i] = {out: v.length, in: 0};\r\n            }\r\n            v.forEach((outV) => {\r\n                if (outV in degrees) {\r\n                    degrees[outV].in += 1;\r\n                }\r\n                else {\r\n                    degrees[outV] = {in: 1, out: 0};\r\n                }\r\n            });\r\n        });\r\n\r\n        return degrees;\r\n    },\r\n\r\n    interpolateNodesFromEdges: (edges: EdgeImmutPlain[]): Array<NodeImmutPlain> => {\r\n        const nodes = [];\r\n        edges.forEach((v) => {\r\n            nodes[v.from] = {id: v.from, label: \"\" + v.from};\r\n            nodes[v.to] = {id: v.to, label: \"\" + v.to};\r\n        });\r\n\r\n        return nodes;\r\n    },\r\n};\r\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\nimport help from './genericHelpers';\r\nimport randomColor from 'randomcolor';\r\nimport GraphState from './graphState';\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\nimport {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\n\r\nexport interface MainI {\r\n    graphState: GraphState;\r\n    container: HTMLElement;\r\n    visWeightEdgeEdit: (data: any, callback: Function) => void;\r\n    visOptions: {\r\n        interaction: { hover: boolean };\r\n        manipulation: {\r\n            addNode: (data: any, callback: Function) => void;\r\n            editNode: (data: any, callback: Function) => void;\r\n            addEdge: (data: any, callback?: Function) => undefined | void;\r\n            editEdge: (data: any, callback: Function) => void;\r\n            deleteEdge: (data: any, callback?: Function) => void;\r\n            deleteNode: (data: any, callback: Function) => void\r\n        }\r\n    };\r\n    cancelEdit: (callback: Function) => void;\r\n    saveData: (data: any, callback: Function, operation: string, label: string) => void;\r\n    nodeLabelIDValidator: (v: string) => (boolean | string);\r\n    applyColors: () => undefined | void;\r\n    setData: (data: GraphPlain, recalcProps?: boolean, graphChanged?: boolean, rearrangeGraph?: boolean) => void;\r\n    saveState: () => undefined | void;\r\n    getStateForSaving: () => {};\r\n    undo: () => void;\r\n    redo: () => void;\r\n    applyState: (undo?: boolean, newState?: any) => void;\r\n    saveStateLocalStorage: () => void;\r\n    shuffleNetworkLayout: () => void;\r\n    randomizeNetworkLayoutSeed: (network: any) => void;\r\n    addNetworkListeners: (network: any) => void\r\n}\r\n\r\nconst self: MainI = {\r\n    graphState: GraphState,\r\n    container: document.getElementById('network'),\r\n    // Function used to overwrite the edge edit functionality when weights are active\r\n    visWeightEdgeEdit: (data, callback) => {\r\n        help.showFormModal(($modal, vals) => {\r\n            callback(null);\r\n            $modal.modal(\"hide\");\r\n            const value = parseFloat(vals[0]);\r\n            GraphState.editEdge(data.from.id, data.to.id, value, parseFloat(data.label));\r\n        }, \"Edit Edge\", \"Save\", [\r\n            {\r\n                type: \"numeric\",\r\n                label: \"Weight/Capacity\",\r\n                initialValue: parseFloat(data.label)\r\n            }\r\n        ]);\r\n    },\r\n    visOptions: {\r\n        interaction: {hover: true},\r\n        manipulation: {\r\n            addNode: (data, callback) => {\r\n                const $popup = help.makeFormModal(\"Add Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: `<p>Node ID: ${GraphState.getPropertyImm(\"vertices\")}</p>`\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: GraphState.getPropertyImm(\"vertices\")}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"add\", $popup.find(\"input\").first().val() as string);\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            editNode: (data, callback) => {\r\n                const $popup = help.makeFormModal(\"Edit Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: `<p>Node ID: ${data.id}</p>`\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: data.label}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"editNode\", $popup.find(\"input\").first().val() as string);\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            addEdge: (data, callback?: any) => {\r\n                const apply = () => {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(null);\r\n                    }\r\n                    GraphState.addEdge(data.from, data.to);\r\n                };\r\n                if (data.from === data.to) {\r\n                    if (confirm(\"Do you want to connect the node to itself?\")) {\r\n                        apply();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                apply();\r\n            },\r\n            editEdge: (data, callback) => {\r\n                callback(null);\r\n                self.visOptions.manipulation.deleteEdge({edges: [data.id]});\r\n                self.visOptions.manipulation.addEdge(data);\r\n            },\r\n            deleteEdge: (data, callback?: any) => {\r\n                if (typeof callback === \"function\") {\r\n                    callback(null);\r\n                }\r\n                data.edges.forEach((v: any) => {\r\n                    let weight = null;\r\n                    if (typeof (window.network as any).body.data.edges._data[v].label !== \"undefined\") {\r\n                        weight = parseFloat((window.network as any).body.data.edges._data[v].label);\r\n                    }\r\n\r\n                    GraphState.deleteEdge((window.network as any).body.edges[v].fromId,\r\n                        (window.network as any).body.edges[v].toId, weight);\r\n                });\r\n            },\r\n            deleteNode: (data, callback) => {\r\n                callback(null);\r\n                data.nodes.forEach((v: number) => {\r\n                    GraphState.deleteNode(v);\r\n                });\r\n            },\r\n        },\r\n    },\r\n\r\n    cancelEdit: (callback) => {\r\n        if (typeof callback === \"function\") {\r\n            callback(null);\r\n        }\r\n    },\r\n\r\n    saveData: (data, callback, operation, label) => {\r\n        data.label = label;\r\n        callback(null);\r\n\r\n        if (operation === \"add\") {\r\n            GraphState.addNode(data);\r\n        }\r\n        else if (operation === \"editNode\") {\r\n            GraphState.editNode(data.id, data.label);\r\n        }\r\n    },\r\n\r\n    nodeLabelIDValidator: (v: string) => {\r\n        if (GraphState.nodeLabelToID(v) > -1) {\r\n            return true;\r\n        }\r\n        return \"Invalid Label or ID\";\r\n    },\r\n\r\n    applyColors: async () => {\r\n        if (window.settings.getOption(\"direction\")) {\r\n            return;\r\n        }\r\n        const graphColors = await GraphState.getProperty(\"graphColoring\", true);\r\n        const chromaticNumber = await GraphState.getProperty(\"Chromatic Number\", true);\r\n\r\n        const colors = randomColor({count: chromaticNumber, luminosity: \"light\"});\r\n        let G = GraphState.graph;\r\n        (G.getAllNodes() as NodeImmutPlain[]).forEach((v) => {\r\n            G = G.editNode(v.id, {color: colors[graphColors[v.id]]});\r\n        });\r\n        self.setData(GraphState.getGraphData(G), false, false);\r\n    },\r\n\r\n    setData: (data: GraphPlain, recalcProps = false, graphChanged = true, rearrangeGraph = false) => {\r\n        // Store existing positions in the data if we're supposed to keep the layout\r\n        if (rearrangeGraph) {\r\n            data.nodes.forEach((v) => {\r\n                delete v.x;\r\n                delete v.y;\r\n            });\r\n        }\r\n\r\n        if (graphChanged) {\r\n            self.saveState();\r\n        }\r\n\r\n        if (\"directed\" in data) {\r\n            window.settings.changeOption(\"direction\", data.directed);\r\n        }\r\n        if (\"weighted\" in data) {\r\n            window.settings.changeOption(\"weights\", data.weighted);\r\n        }\r\n        const directional = window.settings.getOption(\"direction\") as boolean;\r\n        const weighted = window.settings.getOption(\"weights\") as boolean;\r\n\r\n        const g = new GraphImmut(data.nodes, data.edges, directional, weighted);\r\n        GraphState.graph = g;\r\n\r\n        // Set a new random seed so that the layout will be different\r\n        self.randomizeNetworkLayoutSeed(window.network);\r\n        window.network.setData(GraphState.getGraphAsDataSet(g));\r\n        GraphState.graph = GraphState.setLocations(window.network.getPositions());\r\n\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        if (graphChanged) {\r\n            window.ui.printGraphAlgorithms();\r\n            help.printout(\"\");\r\n            GraphState.setUpToDate();\r\n            GraphState.makeAndPrintProperties(recalcProps);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveState: (): void | undefined => {\r\n        if (GraphState.graph === null) {\r\n            return;\r\n        }\r\n\r\n        if (GraphState.backHistory.length >= GraphState.maxHistory) {\r\n            GraphState.backHistory.shift();\r\n        }\r\n\r\n        GraphState.backHistory.push(self.getStateForSaving());\r\n        GraphState.forwardHistory = [];\r\n        $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n    },\r\n\r\n    getStateForSaving: () => {\r\n        const state: any = {};\r\n        Object.keys(GraphState).forEach((k: string) => {\r\n            const v: any = (GraphState as any)[k];\r\n            if (typeof v !== \"function\") {\r\n                if (typeof v !== \"object\") {\r\n                    state[k] = v;\r\n                }\r\n                else {\r\n                    if (k === \"graph\" && v !== null) {\r\n                        state[k] = v;\r\n                    }\r\n                    if (!k.toLowerCase().includes(\"history\")) {\r\n                        state[k] = $.extend(true, Array.isArray(v) ? [] : {}, v);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return state;\r\n    },\r\n\r\n    undo: () => {\r\n        if (GraphState.backHistory.length > 0) {\r\n            self.applyState(true);\r\n        }\r\n    },\r\n\r\n    redo: () => {\r\n        if (GraphState.forwardHistory.length > 0) {\r\n            self.applyState(false);\r\n        }\r\n    },\r\n\r\n    applyState: (undo = true, newState: any = null) => {\r\n        const firstLoad = newState !== null;\r\n        const currentState = self.getStateForSaving();\r\n\r\n        if (!firstLoad) {\r\n            if (undo) {\r\n                newState = GraphState.backHistory.pop();\r\n            }\r\n            else {\r\n                newState = GraphState.forwardHistory.pop();\r\n            }\r\n        }\r\n\r\n        newState.graph = new GraphImmut(newState.graph.nodes, newState.graph.edges, newState.graph.directed, newState.graph.weighted);\r\n\r\n        window.settings.changeOption(\"direction\", newState.graph.isDirected());\r\n        window.settings.changeOption(\"weights\", newState.graph.isWeighted());\r\n\r\n        GraphState.graph = newState.graph;\r\n\r\n        window.network.setData(GraphState.getGraphAsDataSet(GraphState.graph));\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        window.ui.printGraphAlgorithms();\r\n        help.printout(\"\");\r\n\r\n        Object.keys(newState).forEach((k: string) => {\r\n            const v = newState[k];\r\n            if (typeof v !== \"object\") {\r\n                (GraphState as any)[k] = v;\r\n            }\r\n            else if (!k.toLowerCase().includes(\"history\") && k.toLowerCase() !== \"graph\") {\r\n                if (k.toLowerCase() === \"uptodate\") {\r\n                    Object.keys((GraphState as any)[k]).forEach((oldKey) => {\r\n                        (GraphState as any)[k][oldKey].upToDate = v[oldKey].upToDate;\r\n                    });\r\n                }\r\n                else {\r\n                    (GraphState as any)[k] = $.extend(true, (GraphState as any)[k], v);\r\n                }\r\n            }\r\n        });\r\n\r\n        GraphState.makeAndPrintProperties();\r\n        if (undo && !firstLoad) {\r\n            $(\".icon-redo\").parent().parent().addClass(\"active\");\r\n            if (GraphState.backHistory.length === 0) {\r\n                $(\".icon-undo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            GraphState.forwardHistory.push(currentState);\r\n        }\r\n        else if (!undo && !firstLoad) {\r\n            $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n            if (GraphState.forwardHistory.length === 0) {\r\n                $(\".icon-redo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            GraphState.backHistory.push(currentState);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveStateLocalStorage: () => {\r\n        if (window.settings.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.lastState\", JSON.stringify(self.getStateForSaving()));\r\n        }\r\n    },\r\n\r\n    shuffleNetworkLayout: () => {\r\n        self.setData({\r\n            nodes: GraphState.graph.getAllNodes() as NodeImmutPlain[],\r\n            edges: GraphState.graph.getAllEdges() as EdgeImmutPlain[]\r\n        }, false, false, true);\r\n    },\r\n\r\n    randomizeNetworkLayoutSeed: (network) => {\r\n        const r = Math.round(Math.random() * 1000000);\r\n        network.layoutEngine.randomSeed = r;\r\n        network.layoutEngine.initialRandomSeed = r;\r\n    },\r\n\r\n    addNetworkListeners: (network) => {\r\n        // Enable edit node/edge when double clicking\r\n        network.on(\"doubleClick\", (p) => {\r\n            if (window.settings.getOption(\"weights\") && \"edges\" in p && p.edges.length === 1) {\r\n                network.editEdgeMode();\r\n            }\r\n            if (\"nodes\" in p && p.nodes.length === 1) {\r\n                network.editNode();\r\n            }\r\n        });\r\n\r\n        // Save locations of nodes after dragging\r\n        network.on(\"dragEnd\", () => {\r\n            GraphState.graph = GraphState.setLocations(network.getPositions());\r\n            self.saveStateLocalStorage(); // Save the new locations as part of the state\r\n        });\r\n\r\n        // Delete nodes/edges when hit \"Delete\"\r\n        let lastNetworkClickEvent: any = null;\r\n        network.on('click', (event) => {\r\n            lastNetworkClickEvent = event;\r\n        });\r\n\r\n        // Delete key to delete node or edge\r\n        $(document).on('keyup', (key) => {\r\n            if (key.key === \"Delete\" && lastNetworkClickEvent !== null) {\r\n                if ($(self.container).has(lastNetworkClickEvent.event.target).length > 0) {\r\n                    if ((\"edges\" in lastNetworkClickEvent && lastNetworkClickEvent.edges.length === 1)\r\n                        || (\"nodes\" in lastNetworkClickEvent && lastNetworkClickEvent.nodes.length === 1)) {\r\n                        if ($(':focus').parents(\".modal\").length === 0) {\r\n                            network.deleteSelected();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Undo/Redo keyboard commands\r\n        $(document).on(\"keydown\", (e) => {\r\n            if ((e.key.toLowerCase() === 'y' && e.ctrlKey) || (e.key.toLowerCase() === 'z' && e.ctrlKey && e.shiftKey)) {\r\n                self.redo();\r\n            }\r\n            else if (e.key.toLowerCase() === 'z' && e.ctrlKey) {\r\n                self.undo();\r\n            }\r\n        });\r\n\r\n        // When clicking off of the network, remove the Delete functionality\r\n        $(document).on(\"click\", (e) => {\r\n            if ($(self.container).has(e.target).length === 0) {\r\n                lastNetworkClickEvent = null;\r\n            }\r\n        });\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\nimport GraphState from './graphState';\r\n\r\ninterface SettingsList {\r\n    nodePhysics: boolean;\r\n    direction: boolean;\r\n    weights: boolean;\r\n\r\n    [index: string]: boolean\r\n}\r\n\r\nexport interface SettingsI {\r\n    defaults: SettingsList;\r\n    current: any;\r\n    checkForLocalStorage: () => (boolean);\r\n    saveSettings: () => void;\r\n    loadSettings: () => void;\r\n    setAll: () => void;\r\n    changeOption: (option: string, value: string | boolean) => void;\r\n    getOption: (option: string) => string | boolean;\r\n    resetToDefault: () => void\r\n}\r\n\r\nconst self: SettingsI = {\r\n    defaults: {\r\n        nodePhysics: true,\r\n        direction: false,\r\n        weights: false\r\n    } as SettingsList,\r\n\r\n    current: {} as any,\r\n\r\n    checkForLocalStorage: () => {\r\n        try {\r\n            const x = '__storage_test__';\r\n            localStorage.setItem(x, x);\r\n            localStorage.removeItem(x);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    saveSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.settings\", JSON.stringify(self.current));\r\n        }\r\n    },\r\n\r\n    loadSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            self.current = JSON.parse(localStorage.getItem(\"graphPlayground.settings\"));\r\n        }\r\n        if (self.current === null) {\r\n            self.current = {};\r\n        }\r\n        self.setAll();\r\n    },\r\n\r\n    setAll: () => {\r\n        window.network.setOptions({nodes: {physics: self.getOption(\"nodePhysics\") as boolean}});\r\n        window.network.setOptions({edges: {arrows: {to: self.getOption(\"direction\") as boolean}}});\r\n        if (self.getOption(\"weights\")) {\r\n            window.network.setOptions({\r\n                manipulation: {\r\n                    editEdge: {\r\n                        editWithoutDrag: window.main.visWeightEdgeEdit\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            window.network.setOptions({manipulation: {editEdge: window.main.visOptions.manipulation.editEdge}});\r\n        }\r\n    },\r\n\r\n    changeOption: (option: string, value: string | boolean): void => {\r\n        self.current[option] = value;\r\n        self.saveSettings();\r\n        self.setAll();\r\n    },\r\n\r\n    getOption: (option: string): string | boolean => {\r\n        if (option in self.current) {\r\n            return self.current[option];\r\n        }\r\n        return self.defaults[option];\r\n    },\r\n\r\n    resetToDefault: (): void => {\r\n        self.current = {};\r\n        self.saveSettings();\r\n        self.setAll();\r\n\r\n        // Reset graph to just a plain graph. Not sure if this should actually happen or not.\r\n        const G = GraphState.graph.asChangedDirectedWeighted(self.defaults.direction, self.defaults.weights);\r\n        window.main.setData(GraphState.getGraphData(G));\r\n    }\r\n};\r\n\r\nexport default self;\r\n","import gHelp from \"./graphHelpers\";\nimport help from \"./genericHelpers\";\nimport * as $ from \"jquery\";\nimport GraphState from './graphState';\nimport GraphAlgorithms from \"./GraphAlgorithms\";\n\ninterface ShortestPathResult {\n    pathExists: boolean;\n    cost?: number;\n    distance: number;\n    path: number[]\n}\n\nexport interface AlgorithmI {\n    name: string;\n    directional?: boolean;\n    weighted?: boolean;\n    applyFunc: () => any;\n    display: boolean\n}\n\nexport interface UIInteractionsI {\n    getAlgorithms(): AlgorithmI[];\n\n    registerListeners(): void;\n\n    printHelp(): void;\n\n    printOptions(): void;\n\n    makeAndPrintGraphColoring(): Promise<void>;\n\n    makeAndPrintConnectedComponents(): Promise<void>;\n\n    makeAndPrintDirectionalEulerian(): Promise<void>;\n\n    makeAndPrintEulerian(): Promise<void>;\n\n    makeAndPrintStronglyConnectedComponents(): Promise<void>;\n\n    makeAndPrintBFS(): Promise<void>;\n\n    makeAndPrintDijkstra(): Promise<void>;\n\n    makeAndPrintBFSP(): Promise<void>;\n\n    makeAndPrintFFMCMF(): void;\n\n    makeAndPrintKruskal(): Promise<void>;\n\n    makeAndPrintIsCyclic(): Promise<void>;\n\n    makeAndPrintTopologicalSort(): Promise<void>;\n\n    printGraphAlgorithms(): void;\n}\n\nconst makeAndPrintShortestPath = (title: string,\n                                  fn: (a: number, b: number) => boolean | ShortestPathResult,\n                                  weighted: boolean): void => {\n    help.showFormModal(($modal, values) => {\n            $modal.modal(\"hide\");\n\n            const source = GraphState.nodeLabelToID(values[0]);\n            const sink = GraphState.nodeLabelToID(values[1]);\n\n            let a = fn(source, sink);\n            if (a === false) {\n                return;\n            }\n\n            a = a as ShortestPathResult;\n\n            let p = `<h3>${title}</h3><hr>No path exists from ${help.htmlEncode(source.toString())} to ${help.htmlEncode(sink.toString())}`;\n\n            if (a.pathExists) {\n                p = `${title} From ${GraphState.nodeIDToLabel(source)} to `;\n                p += `${GraphState.nodeIDToLabel(sink)}: ${a.distance}`;\n                if (weighted) {\n                    p += `\\nWith weighted cost: ${a.cost}`;\n                }\n                p += \"\\n\\nUsing Path: \";\n\n                p = help.htmlEncode(p);\n                a.path.forEach((v) => {\n                    p += `${help.htmlEncode(GraphState.nodeIDToLabel(v))} &rarr; `;\n                });\n                p = p.slice(0, -8);\n                p = `<h3>${title}</h3><hr>${p}`;\n            }\n\n            help.printout(p);\n        },\n        title, \"Go\", [\n            {label: \"Start Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n            {label: \"End Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n        ]);\n};\n\nconst callWithGraphAlgorithms = async (f: (gAlgo: GraphAlgorithms) => any): Promise<any> => {\n    const gAlgo = new ((await import(\"./GraphAlgorithms\")).default)();\n    return f(gAlgo);\n};\n\nconst makeAndPrintComponents = async (stronglyConnected: boolean): Promise<any> => {\n    let a = null;\n    let cc = \"Connected Components\";\n    let componentKey = \"connectedComponents\";\n\n    const gAlgo = new ((await import(\"./GraphAlgorithms\")).default)();\n    if (stronglyConnected) {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        cc = \"Strongly \" + cc;\n        componentKey = \"stronglyConnectedComponents\";\n        a = await gAlgo.stronglyConnectedComponents();\n    }\n    else {\n        if (window.settings.getOption(\"direction\")) {\n            return;\n        }\n        a = await gAlgo.connectedComponents();\n    }\n\n    GraphState.graphProperties[cc] = a.count;\n    GraphState.setUpToDate(true, [cc, componentKey]);\n    GraphState.state[componentKey] = a.components;\n\n    const components = help.flatten(a.components);\n    let p = `Number of ${cc}: ${a.count}`;\n    p += \"\\n\\n\";\n\n    components.forEach((v, i) => {\n        p += `Vertex ${GraphState.nodeIDToLabel(i)} is in connected component #${v}\\n`;\n    });\n\n    p += `\\n${JSON.stringify(help.rotate(a.components), null, 4)}\\n\\n`;\n    p = `<h3>${cc}</h3><hr>${help.htmlEncode(p)}`;\n\n    help.printout(p);\n\n    return Promise.resolve(\"hi\");\n};\n\nexport default class UIInteractions {\n    static getAlgorithms(): AlgorithmI[] {\n        return [\n            {\n                name: \"Graph Coloring\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintGraphColoring,\n                display: true\n            },\n            {\n                name: \"Connected Components\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintConnectedComponents,\n                display: true\n            },\n            {\n                name: \"Strongly Connected Components\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintStronglyConnectedComponents\n            },\n            {\n                name: \"Breadth-First Shortest Path\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintBFS,\n                display: true\n            },\n            {\n                name: \"Dijkstra Shortest Path\",\n                applyFunc: UIInteractions.makeAndPrintDijkstra,\n                display: true\n            },\n            {\n                name: \"Bellman-Ford Shortest Path\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintBFSP,\n                display: true\n            },\n            {\n                name: \"Ford-Fulkerson\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintFFMCMF,\n                display: true\n            },\n            {\n                name: \"Kruskal Minimum Spanning Tree\",\n                weighted: true,\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintKruskal,\n                display: true\n            },\n            {\n                name: \"Cyclic\",\n                applyFunc: UIInteractions.makeAndPrintIsCyclic,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Topological Sort\",\n                applyFunc: UIInteractions.makeAndPrintTopologicalSort,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Eulerian\",\n                directional: false,\n                display: false,\n                applyFunc: null\n            },\n            {\n                name: \"Eulerian\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintDirectionalEulerian\n            },\n        ] as AlgorithmI[];\n    }\n\n    static registerListeners(): void {\n        const makeSimpleClickListener = (selector: string, fn: () => void) => {\n            $(selector).on(\"click\", (e) => {\n                e.preventDefault();\n                fn();\n            });\n        };\n\n        makeSimpleClickListener(\"#print-help-link\", UIInteractions.printHelp);\n        makeSimpleClickListener(\"#graph-options-link\", UIInteractions.printOptions);\n        makeSimpleClickListener(\"#load-petersen-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            window.main.setData(predefined.Petersen(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-konigsberg-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            window.main.setData(predefined.Konigsberg(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-complete-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Complete();\n        });\n        makeSimpleClickListener(\"#load-hypercube-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Hypercube();\n        });\n        makeSimpleClickListener(\"#load-custom-link\", async () => {\n            const predefined = (await import('./predefinedGraphs')).default;\n            predefined.Custom();\n        });\n        makeSimpleClickListener(\"#undo-link\", window.main.undo);\n        makeSimpleClickListener(\"#redo-link\", window.main.redo);\n        makeSimpleClickListener(\"#calculate-all-properties-link\", async () => {\n            return GraphState.makeAndPrintProperties(true);\n        });\n        makeSimpleClickListener(\"#new-graph-layout-link\", window.main.shuffleNetworkLayout);\n        makeSimpleClickListener(\"#import-file-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeImportFileModal();\n        });\n        makeSimpleClickListener(\"#import-text-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeImportTextModal();\n        });\n        makeSimpleClickListener(\"#export-file-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeExportFileModal();\n        });\n        makeSimpleClickListener(\"#export-text-link\", async () => {\n            const imp = (await import(\"./dataImportExport\")).default;\n            imp.makeExportTextModal();\n        });\n    }\n\n    static printHelp(): void {\n        help.showSimpleModal(\"Help\", \"<h4>For support see the <a href='https://github.com/MikeDombo/graphPlayground' \" +\n            \"target='_blank'>GitHub repository</a> for guides</h4> <h4>See \" +\n            \"<a href='https://github.com/MikeDombo/graphPlayground/issues' target='_blank'>GitHub issues</a>\" +\n            \" to submit bugs or feature requests.</h4>\");\n    }\n\n    static printOptions(): void {\n        help.showFormModal(\n            ($modal, vals) => {\n                $modal.modal(\"hide\");\n                if (window.settings.getOption(\"nodePhysics\") !== vals[0]) {\n                    window.settings.changeOption(\"nodePhysics\", vals[0]); // Physics\n                }\n                if (window.settings.getOption(\"direction\") !== vals[1]) {\n                    window.settings.changeOption(\"direction\", vals[1]);\n                    let G = GraphState.graph;\n                    G = vals[1] ? G.asDirected(true) : G.asUndirected();\n                    // Clear node coloring because graph color doesn't apply to directed graphs\n                    window.main.setData(GraphState.getGraphData(G, true));\n                }\n                if (window.settings.getOption(\"weights\") !== vals[2]) {\n                    window.settings.changeOption(\"weights\", vals[2]);\n                    let G = GraphState.graph;\n                    G = vals[2] ? G.asWeighted() : G.asUnweighted();\n                    window.main.setData(GraphState.getGraphData(G));\n                }\n            },\n            \"Options\", \"Save\", [\n                {label: \"Graph Physics\", initialValue: window.settings.getOption(\"nodePhysics\"), type: \"checkbox\"},\n                {label: \"Directed Graph\", initialValue: window.settings.getOption(\"direction\"), type: \"checkbox\"},\n                {label: \"Weighted Graph\", initialValue: window.settings.getOption(\"weights\"), type: \"checkbox\"}\n            ], null);\n    }\n\n    static async makeAndPrintGraphColoring(): Promise<void> {\n        if (window.settings.getOption(\"direction\")) {\n            return;\n        }\n\n        // Use cached responses when able\n        let a = {\n            chromaticNumber: (await GraphState.getProperty(\"Chromatic Number\")) as number,\n            colors: GraphState.state.graphColoring as {}\n        };\n        if (!(a.chromaticNumber !== null && (await GraphState.getProperty(\"graphColoring\")) !== null)) {\n            const gAlgo = new ((await import(\"./GraphAlgorithms\")).default)();\n            a = gAlgo.colorNetwork();\n        }\n\n        (GraphState.graphProperties[\"Chromatic Number\"] as number) = a.chromaticNumber;\n        GraphState.setUpToDate(true, [\"Chromatic Number\", \"graphColoring\"]);\n        (GraphState.state.graphColoring as {}) = a.colors;\n\n        const colors = help.flatten(a.colors);\n        let p = `Number of Vertices: ${colors.length}`;\n        p += `\\nChromatic Number: ${a.chromaticNumber}`;\n        p += \"\\n\\n\";\n\n        colors.forEach((v, i) => {\n            p += `Vertex ${GraphState.nodeIDToLabel(i)} gets color ${v}\\n`;\n        });\n\n        p += `\\n${JSON.stringify(help.rotate(a.colors), null, 4)}\\n\\n`;\n\n        p = `<h3>Graph Coloring Using Welsh-Powell Algorithm</h3><hr>${help.htmlEncode(p)}`;\n        p += \"<br/><button class='btn btn-primary' onclick='main.applyColors()'>Apply New Colors To Graph</button>\";\n\n        help.printout(p);\n        window.main.applyColors();\n    }\n\n    static makeAndPrintConnectedComponents(): Promise<void> {\n        return makeAndPrintComponents(false);\n    }\n\n    static makeAndPrintDirectionalEulerian(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        return callWithGraphAlgorithms(async (gAlgo) => {\n            GraphState.graphProperties.eulerian = await gAlgo.directionalEulerian(\n                gHelp.findVertexDegreesDirectional(\n                    GraphState.graph.getFullAdjacency()));\n            GraphState.setUpToDate(true, [\"eulerian\"]);\n        });\n    }\n\n    static makeAndPrintEulerian(): Promise<void> {\n        if (window.settings.getOption(\"direction\")) {\n            return UIInteractions.makeAndPrintDirectionalEulerian();\n        }\n\n        return callWithGraphAlgorithms(async (gAlgo) => {\n            GraphState.graphProperties.eulerian = await gAlgo.hasEulerianCircuit(GraphState.graph.getAllOutDegrees());\n            GraphState.setUpToDate(true, [\"eulerian\"]);\n        });\n    }\n\n    static makeAndPrintStronglyConnectedComponents(): Promise<void> {\n        return makeAndPrintComponents(true);\n    }\n\n    static makeAndPrintBFS(): Promise<void> {\n        return callWithGraphAlgorithms((gAlgo) => {\n            makeAndPrintShortestPath(\"Breadth-First Shortest Path\", gAlgo.breadthFirstSearch as any, false);\n        });\n    }\n\n    static makeAndPrintDijkstra(): Promise<void> {\n        return callWithGraphAlgorithms((gAlgo) => {\n            makeAndPrintShortestPath(\"Dijkstra Shortest Path\", gAlgo.dijkstraSearch as any, true);\n        });\n    }\n\n    static makeAndPrintBFSP(): Promise<void> {\n        return callWithGraphAlgorithms((gAlgo) => {\n            makeAndPrintShortestPath(\"Bellman-Ford Shortest Path\", gAlgo.bellmanFord as any, true);\n        });\n    }\n\n    static makeAndPrintFFMCMF(): void {\n        if (!window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n        help.showFormModal(async ($modal, values) => {\n                $modal.modal(\"hide\");\n\n                const source = GraphState.nodeLabelToID(values[0]);\n                const sink = GraphState.nodeLabelToID(values[1]);\n                const gAlgo = new ((await import(\"./GraphAlgorithms\")).default)();\n                let a = gAlgo.fordFulkerson(source, sink);\n\n                let p = `<h3>Ford-Fulkerson</h3><hr>No path exists from ${help.htmlEncode(GraphState.nodeIDToLabel(source))} to ${help.htmlEncode(GraphState.nodeIDToLabel(sink))}`;\n\n                if (a === false) {\n                    help.printout(p);\n                    return;\n                }\n                a = a as { maxFlow: number; flowPath: any[] };\n\n                p = `Ford-Fulkerson MaxFlow-MinCut Max Flow From ${GraphState.nodeIDToLabel(source)} to ${GraphState.nodeIDToLabel(sink)}: ${a.maxFlow}`;\n                p += \"\\n\\nUsing Capacities:\\n\\n\";\n                p = help.htmlEncode(p);\n                a.flowPath.forEach((v) => {\n                    p += `${GraphState.nodeIDToLabel(v.from)}&rarr;${GraphState.nodeIDToLabel(v.to)} using ${v.flow} of ${v.capacity}\\n`;\n                });\n                p = p.trim();\n                p = \"<h3>Ford-Fulkerson MaxFlow-MinCut</h3><hr>\" + p;\n\n                help.printout(p);\n            },\n            \"Ford-Fulkerson MaxFlow-MinCut\", \"Go\", [\n                {label: \"Source Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n                {label: \"Sink Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n            ]);\n    }\n\n    static makeAndPrintKruskal(): Promise<void> {\n        if (window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n        return callWithGraphAlgorithms((gAlgo) => {\n            const a = gAlgo.kruskal();\n\n            let p = `Kruskal's Minimum Spanning Tree Total Weight: ${a.totalWeight}`;\n            p += \"\\n\\nUsing Edges:\\n\\n\";\n            p = help.htmlEncode(p);\n            a.mst.forEach((v) => {\n                p += `${GraphState.nodeIDToLabel(v.from)}&rarr;${GraphState.nodeIDToLabel(v.to)}\\n`;\n            });\n            p = p.trim();\n            p = `<h3>Kruskal Minimum Spanning Tree</h3><hr>${p}`;\n\n            help.printout(p);\n        });\n    }\n\n    static async makeAndPrintIsCyclic(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        return callWithGraphAlgorithms((gAlgo) => {\n            GraphState.graphProperties.cyclic = gAlgo.isGraphCyclic();\n            GraphState.setUpToDate(true, [\"cyclic\"]);\n        });\n    }\n\n    static makeAndPrintTopologicalSort(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        return callWithGraphAlgorithms((gAlgo) => {\n            const a = gAlgo.topologicalSort();\n\n            if (a === true) {\n                GraphState.graphProperties.cyclic = true;\n                GraphState.setUpToDate(true, [\"cyclic\"]);\n\n                help.printout(\"<h3>Topological Sorting Failed</h3><hr>Topological sorting failed because the graph contains a cycle\");\n\n                return;\n            }\n\n            let p = \"Topological Sorting:\\n\\n\";\n            p = help.htmlEncode(p);\n            (a as any[]).forEach((v) => {\n                p += `${GraphState.nodeIDToLabel(v.id)}, `;\n            });\n            p = p.slice(0, -2);\n            p = `<h3>Topological Sorting</h3><hr>${p}`;\n\n            help.printout(p);\n        });\n    }\n\n    static printGraphAlgorithms(): void {\n        const $div = $(\"#algorithms-pane\");\n        $div.empty();\n        const directional = window.settings.getOption(\"direction\");\n        const weighted = window.settings.getOption(\"weights\");\n\n        const addAlgoToPane = (alg: AlgorithmI) => {\n            $div.append($(\"<a>\", {class: \"nav-link\", href: \"#\"})\n                .text(alg.name).on(\"click\", (e) => {\n                    e.preventDefault();\n                    alg.applyFunc();\n                }));\n        };\n\n        const a = UIInteractions.getAlgorithms();\n        a.forEach((alg) => {\n            if (!alg.display) {\n                return;\n            }\n            if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n            else if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n        });\n    }\n}\n","\"use strict\";\r\n\r\nimport 'bootstrap';\r\nimport * as Raven from 'raven-js';\r\nimport {Network} from 'vis/index-network';\r\nimport {default as main, MainI} from './main';\r\nimport {default as settings, SettingsI} from './settings';\r\nimport {default as UI, UIInteractionsI} from './UIInteractions';\r\n\r\ndeclare global {\r\n    interface Window {\r\n        main: MainI;\r\n        network: Network;\r\n        settings: SettingsI;\r\n        ui: UIInteractionsI,\r\n        Raven: Raven.RavenStatic\r\n    }\r\n}\r\n\r\nwindow.main = main;\r\nwindow.network = new Network(main.container, {}, main.visOptions);\r\nwindow.settings = settings;\r\nwindow.ui = UI;\r\n\r\n// Initialize Sentry.io error logging\r\nRaven.config('https://92aaeee7e2fb4ef4837a2261a029e8ed@sentry.home.mikedombrowski.com/2').install();\r\nwindow.Raven = Raven;\r\n\r\nmain.addNetworkListeners(window.network);\r\n\r\nsettings.loadSettings();\r\n\r\nlet loadDefault = true;\r\nif (settings.checkForLocalStorage()) {\r\n    let s: any = localStorage.getItem(\"graphPlayground.lastState\");\r\n    if (s !== null) {\r\n        s = JSON.parse(s);\r\n        if (\"graph\" in s && \"nodes\" in s.graph) {\r\n            loadDefault = false;\r\n            main.applyState(false, s);\r\n        }\r\n    }\r\n}\r\nif (loadDefault) {\r\n    (async () => {\r\n        const predefined = (await import(\"./predefinedGraphs\")).default;\r\n        main.setData(predefined.Petersen(), false, true, true);\r\n    })();\r\n}\r\n\r\nwindow.ui.registerListeners();\r\n","\"use strict\";\n\nexport interface NodeImmutPlain {\n    id: Readonly<number>;\n    label: string;\n\n    [key: string]: any;\n\n    [key: number]: any\n}\n\nexport default class NodeImmut {\n    private readonly id: Readonly<number>;\n    private readonly label: Readonly<string>;\n    private readonly attributes: any;\n\n    constructor(id: any, label: any = null, extraAttrs: null | any = null) {\n        if (label === null) {\n            this.label = id.toString();\n        }\n        else {\n            this.label = label;\n        }\n\n        this.attributes = {};\n        if (extraAttrs !== null && typeof extraAttrs === \"object\") {\n            Object.keys(extraAttrs).forEach((key) => {\n                this.attributes[key] = Object.freeze(extraAttrs[key]);\n            });\n        }\n\n        this.attributes = Object.freeze(this.attributes);\n        this.label = Object.freeze(this.label);\n        this.id = Object.freeze(id);\n\n        if (new.target === NodeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    toPlain(): NodeImmutPlain {\n        const toReturn: NodeImmutPlain = {id: this.id, label: this.label};\n        Object.keys(this.attributes).forEach((key) => {\n            if (!(key in toReturn)) {\n                toReturn[key] = this.attributes[key];\n            }\n        });\n\n        return toReturn;\n    }\n\n    getID(): Readonly<number> {\n        return this.id;\n    }\n\n    getLabel(): Readonly<string> {\n        return this.label;\n    }\n\n    getAttribute(attribute: string | number): any {\n        if (attribute in this.attributes) {\n            return this.attributes[attribute];\n        }\n\n        return null;\n    }\n\n    getAllAttributes(): { [key: string]: any; [key: number]: any } {\n        return this.attributes;\n    }\n\n    editNode(label: any = null, extraAttrs: any = null): NodeImmut {\n        if (label === null) {\n            label = this.getLabel();\n        }\n\n        // Merge existing and new attributes favoring the new\n        const attributes = Object.assign({}, this.attributes);\n        Object.keys(extraAttrs).forEach((key) => {\n            attributes[key] = extraAttrs[key];\n        });\n\n        return new NodeImmut(this.getID(), label, attributes);\n    }\n}\n","\"use strict\";\n\nexport interface EdgeImmutPlain {\n    label?: string;\n    from: number;\n    to: number;\n    weight: number\n}\n\nexport default class EdgeImmut {\n    private readonly from: Readonly<number>;\n    private readonly to: Readonly<number>;\n    private readonly weight: Readonly<number>;\n\n    constructor(from: number, to: number, weight: any = 1) {\n        this.from = Object.freeze(from);\n        this.to = Object.freeze(to);\n        this.weight = Object.freeze(parseFloat(weight));\n\n        if (new.target === EdgeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    getFrom(): Readonly<number> {\n        return this.from;\n    }\n\n    getTo(): Readonly<number> {\n        return this.to;\n    }\n\n    getWeight(): Readonly<number> {\n        return this.weight;\n    }\n\n    toPlain(): { from: Readonly<number>; to: Readonly<number>; weight: Readonly<number> } {\n        return {from: this.from, to: this.to, weight: this.weight};\n    }\n\n    editEdge(newWeight: number): EdgeImmut {\n        return new EdgeImmut(this.getFrom(), this.getTo(), newWeight);\n    }\n}\n","\"use strict\";\n\nimport {List} from 'immutable';\nimport {default as NodeImmut, NodeImmutPlain} from './NodeImmut';\nimport {default as EdgeImmut, EdgeImmutPlain} from './EdgeImmut';\n\ninterface NodeMapping {\n    [key: number]: number\n}\n\nconst filterNodeExtraAttr = (data: any) => {\n    return Object.keys(data)\n        .filter((key) => !([\"label\", \"id\"]).includes(key))\n        .reduce((obj: any, key) => {\n            obj[key] = data[key];\n            return obj;\n        }, {});\n};\n\nconst genericEdgesToImmutEdges = (edges: any, nodeMap: NodeMapping = {}): boolean | List<EdgeImmut> => {\n    if (edges === null) {\n        return false;\n    }\n\n    let newEdges: List<EdgeImmut> = List();\n\n    if (typeof edges === 'object') {\n        edges.forEach((edge: any) => {\n            let weight = 0;\n            let from = 0;\n            let to = 0;\n\n            if (\"weight\" in edge) {\n                weight = parseFloat(edge.weight);\n            }\n            if (\"from\" in edge) {\n                from = nodeMap[edge.from];\n            }\n            if (\"to\" in edge) {\n                to = nodeMap[edge.to];\n            }\n\n            newEdges = newEdges.push(new EdgeImmut(from, to, weight));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return newEdges;\n};\n\nconst genericNodesToImmutNodes = (nodes: any): boolean | { nodes: Readonly<List<NodeImmut>>; map: { [key: number]: number } } => {\n    if (nodes === null) {\n        return false;\n    }\n\n    let newNodes: List<NodeImmut> = List();\n    const nodeMap: NodeMapping = {};\n\n    if (typeof nodes === \"number\") {\n        // Create the nodes\n        for (let i = 0; i < Math.floor(nodes); i++) {\n            newNodes = newNodes.set(i, new NodeImmut(i));\n            nodeMap[i] = i;\n        }\n    }\n    else if (typeof nodes === 'object') {\n        let nodeNum = 0;\n        nodes.forEach((n: any) => {\n            const id = nodeNum++;\n            let label = null;\n            let extraAttrs = null;\n\n            if (\"label\" in n) {\n                label = n.label;\n            }\n            if (\"id\" in n) {\n                nodeMap[n.id] = id;\n                if (\"label\" in n && n.label === n.id.toString()) {\n                    label = id.toString();\n                }\n            }\n            else {\n                nodeMap[id] = id;\n            }\n            if (\"attributes\" in n) {\n                extraAttrs = filterNodeExtraAttr(n.attributes);\n            }\n            else {\n                extraAttrs = filterNodeExtraAttr(n);\n            }\n\n            newNodes = newNodes.set(id, new NodeImmut(id, label, extraAttrs));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return {nodes: Object.freeze(newNodes), map: nodeMap};\n};\n\nexport default class GraphImmut {\n    private readonly directed: Readonly<boolean>;\n    private readonly weighted: Readonly<boolean>;\n    private readonly nodes: Readonly<List<NodeImmut>>;\n    private readonly numNodes: Readonly<number>;\n    private readonly edges: Readonly<List<EdgeImmut>>;\n    private readonly numEdges: Readonly<number>;\n\n    constructor(nodes: number | List<NodeImmut> | NodeImmutPlain[],\n                edges: null | List<EdgeImmut> | EdgeImmutPlain[] = null,\n                directed = false, weighted = false) {\n        this.directed = Object.freeze(directed);\n        this.weighted = Object.freeze(weighted);\n        let nodeMap = {};\n\n        // Make Nodes\n        if (typeof nodes === \"number\" || (typeof nodes === \"object\" && !(nodes instanceof List))) {\n            const n = genericNodesToImmutNodes(nodes);\n            if (typeof n !== \"object\") {\n                throw new Error(\"Unable to parse node input!\");\n            }\n            this.nodes = n.nodes;\n            nodeMap = n.map;\n        }\n        else if (nodes instanceof List) {\n            this.nodes = nodes as List<NodeImmut>;\n        }\n        else {\n            throw new Error(\"Illegal type of 'node' input to GraphImmut constructor\");\n        }\n        this.nodes = Object.freeze(this.nodes);\n        this.numNodes = Object.freeze(this.nodes.size);\n\n        // If we are given edges, add them to the graph\n        if (edges !== null && typeof edges === \"object\" && !(edges instanceof List)) {\n            const e = genericEdgesToImmutEdges(edges, nodeMap);\n            if (typeof e !== \"object\") {\n                throw new Error(\"Unable to parse Edge input\");\n            }\n            this.edges = e;\n        }\n        else if (edges instanceof List) {\n            this.edges = edges as List<EdgeImmut>;\n        }\n        else {\n            this.edges = List();\n        }\n        this.edges = Object.freeze(this.edges);\n        this.numEdges = Object.freeze(this.edges.size);\n\n        if (new.target === GraphImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    alignNodeIDs(alignTo = 0): GraphImmut {\n        const nodeMap: NodeMapping = {};\n        let nodeCount = alignTo;\n        let newNodes: List<NodeImmut> = List();\n        this.nodes.forEach((v) => {\n            let label = v.getLabel();\n            if (v.getLabel() === v.getID().toString()) {\n                label = nodeCount.toString();\n            }\n\n            newNodes = newNodes.set(nodeCount, new NodeImmut(nodeCount, label, v.getAllAttributes()));\n            nodeMap[v.getID()] = nodeCount++;\n        });\n\n        let newEdges: List<EdgeImmut> = List();\n        this.edges.forEach((v) => {\n            newEdges = newEdges.push(new EdgeImmut(nodeMap[v.getFrom()], nodeMap[v.getTo()], v.getWeight()));\n        });\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    getNode(id: number, rich = false): NodeImmut | NodeImmutPlain | boolean {\n        if (id >= this.numNodes) {\n            return false;\n        }\n        if (rich) {\n            return this.nodes.get(id);\n        }\n        return this.nodes.get(id).toPlain();\n    }\n\n    addNode(data: any = null): GraphImmut {\n        if (data === null) {\n            data = {};\n        }\n\n        const id = this.numNodes;\n        if (!(\"label\" in data)) {\n            data.label = id.toString();\n        }\n\n        const extraAttrs = filterNodeExtraAttr(data);\n\n        return new GraphImmut(this.nodes.set(id, new NodeImmut(id, data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    editNode(id: number, data: any): any {\n        if (!this.nodes.has(id)) {\n            return false;\n        }\n\n        const extraAttrs = filterNodeExtraAttr(data);\n        if (!(\"label\" in data)) {\n            data.label = (this.getNode(id, true) as NodeImmut).getLabel();\n        }\n        return new GraphImmut(this.nodes.set(id, (this.getNode(id, true) as NodeImmut).editNode(data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    deleteNode(id: number): GraphImmut | boolean {\n        // Make sure the ID exists\n        if (!(id >= 0 && id < this.numNodes)) {\n            return false;\n        }\n\n        const nodeMap: NodeMapping = {}; // Map for old IDs to new ones since we're deleting an entry\n\n        // Remove it from the node list\n        let nodeCount = 0;\n        const newNodes: List<NodeImmut> = this.nodes\n            .filter((n) => {\n                if (n.getID() === id) {\n                    nodeMap[n.getID()] = -1;\n                }\n                else {\n                    nodeMap[n.getID()] = nodeCount++;\n                }\n\n                return n.getID() !== id;\n            })\n            .map((node) => {\n                let label = node.getLabel();\n                if (node.getID().toString() === label) {\n                    label = nodeMap[node.getID()].toString();\n                }\n\n                return new NodeImmut(nodeMap[node.getID()], label, node.getAllAttributes());\n            }) as List<NodeImmut>;\n\n        // Remap edges\n        const newEdges: List<EdgeImmut> = this.edges\n            .filter((edge) => {\n                return !(edge.getFrom() === id || edge.getTo() === id);\n            })\n            .map((edge) => {\n                return new EdgeImmut(nodeMap[edge.getFrom()], nodeMap[edge.getTo()], edge.getWeight());\n            }) as List<EdgeImmut>;\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    addEdge(from: number, to: number, weight: any = 1): GraphImmut {\n        if (!this.weighted) {\n            weight = 1; // Ensure that edge weights are 1 if this is an unweighted graph\n        }\n\n        const newEdges = this.edges.push(new EdgeImmut(from, to, parseFloat(weight)));\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    deleteEdge(from: number, to: number, weight: any = null, deleteAll = true): GraphImmut {\n        if (weight !== null) {\n            weight = parseFloat(weight);\n        }\n\n        let foundOneEdge = false;\n        const newEdges: List<EdgeImmut> = this.edges.filter((edge) => {\n            // If we're not deleting everything and we have found one edge, then do not filter anymore\n            if (foundOneEdge && !deleteAll) {\n                return true;\n            }\n\n            // If we have an exact match\n            if (edge.getFrom() === from && edge.getTo() === to && (weight === null || edge.getWeight() === weight)) {\n                foundOneEdge = true;\n                return false; // Remove this edge\n            }\n\n            // If we are undirected, check for opposing matches\n            if (!this.directed) {\n                if (edge.getFrom() === to && edge.getTo() === from && (weight === null || edge.getWeight() === weight)) {\n                    foundOneEdge = true;\n                    return false; // Remove this edge\n                }\n            }\n\n            return true;\n        }) as List<EdgeImmut>;\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    editEdge(from: number, to: number, newWeight: any, oldWeight: any = null): GraphImmut | boolean {\n        // Editing only makes sense for weighted graphs.\n        // To change from/to, just delete the edge and add a new one\n        if (!this.weighted) {\n            return false;\n        }\n\n        let foundFirst = false;\n\n        if (oldWeight !== null) {\n            oldWeight = parseFloat(oldWeight);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge, index) => {\n            if (foundFirst) {\n                return;\n            }\n            if (edge.getFrom() === from && edge.getTo() === to && (oldWeight === null || edge.getWeight() === oldWeight)) {\n                newEdges = newEdges.set(index, edge.editEdge(parseFloat(newWeight)));\n                foundFirst = true;\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    getAllNodes(rich = false): NodeImmut[] | NodeImmutPlain[] {\n        if (rich) {\n            return this.nodes.toArray();\n        }\n        return this.nodes.map((node) => {\n            return node.toPlain();\n        }).toArray();\n    }\n\n    getAllNodesAsImmutableList(): List<NodeImmut> {\n        return this.nodes;\n    }\n\n    getAllEdgesAsImmutableList(): List<EdgeImmut> {\n        return this.edges;\n    }\n\n    getAllEdges(rich = false): EdgeImmut[] | EdgeImmutPlain[] {\n        if (rich) {\n            return this.edges.toArray();\n        }\n        return this.edges.map((edge) => {\n            return edge.toPlain();\n        }).toArray();\n    }\n\n    getNumberOfNodes(): number {\n        return this.numNodes;\n    }\n\n    getNumberOfEdges(): number {\n        return this.numEdges;\n    }\n\n    getAllOutDegrees(): number[] {\n        const degrees: number[] = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() in degrees) {\n                degrees[edge.getFrom()]++;\n            }\n            else {\n                degrees[edge.getFrom()] = 1;\n            }\n        });\n\n        return degrees;\n    }\n\n    asWeighted(): GraphImmut {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }) as List<EdgeImmut>, this.directed, true);\n    }\n\n    asUnweighted(): GraphImmut {\n        return new GraphImmut(this.nodes, this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }) as List<EdgeImmut>, this.directed, false);\n    }\n\n    asDirected(doubleEdges = false): GraphImmut {\n        if (!doubleEdges) {\n            return new GraphImmut(this.nodes, this.edges, true, this.weighted);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.getTo(), edge.getFrom(), edge.getWeight()));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, true, this.weighted);\n    }\n\n    asUndirected(): GraphImmut {\n        let newEdges: List<EdgeImmut> = List();\n        const addedEdges: { [key: string]: null } = {};\n\n        this.edges.forEach((edge) => {\n            let from = edge.getFrom();\n            let to = edge.getTo();\n            if (to > from) {\n                from = to;\n                to = edge.getFrom();\n            }\n            if (!(`${from}_${to}` in addedEdges)) {\n                addedEdges[`${from}_${to}`] = null;\n                newEdges = newEdges.push(new EdgeImmut(from, to, edge.getWeight()));\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, false, this.weighted);\n    }\n\n    asChangedDirectedWeighted(directed: boolean, weighted: boolean): GraphImmut {\n        let G: GraphImmut = this;\n        if (directed && !this.directed) {\n            G = this.asDirected();\n        }\n        else if (!directed && this.directed) {\n            G = this.asUndirected();\n        }\n\n        if (weighted && !this.weighted) {\n            G = this.asWeighted();\n        }\n        else if (!weighted && this.weighted) {\n            G = this.asUnweighted();\n        }\n\n        return G;\n    }\n\n    getNodeAdjacency(id: number): number[] {\n        const adj: number[] = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() === id) {\n                adj.push(edge.getTo());\n            }\n            else if (!this.directed && edge.getTo() === id) {\n                adj.push(edge.getFrom());\n            }\n        });\n\n        return adj;\n    }\n\n    getFullAdjacency(): number[][] {\n        const adj: number[][] = [];\n        this.nodes.forEach((n) => {\n            adj[n.getID()] = this.getNodeAdjacency(n.getID());\n        });\n\n        return adj;\n    }\n\n    areAdjacent(id1: number, id2: number): boolean {\n        return this.getNodeAdjacency(id1).includes(id2);\n    }\n\n    getEdgesBetween(id1: number, id2: number): EdgeImmut[] {\n        const edgeList: EdgeImmut[] = [];\n        this.edges.forEach((edge) => {\n            if (!this.directed && edge.getFrom() === id2 && edge.getTo() === id1) {\n                edgeList.push(edge);\n            }\n\n            if (edge.getFrom() === id1 && edge.getTo() === id2) {\n                edgeList.push(edge);\n            }\n        });\n\n        return edgeList;\n    }\n\n    getMinWeightEdgeBetween(id1: number, id2: number): number {\n        let minWeight = Infinity;\n        this.getEdgesBetween(id1, id2).forEach((edge) => {\n            if (edge.getWeight() < minWeight) {\n                minWeight = edge.getWeight();\n            }\n        });\n\n        return minWeight;\n    }\n\n    // Take a multigraph and reduce all multiple edges to a single edge, weighted using the reducer\n    reduceMultiGraph(reducer: Function, initialValue?: any): GraphImmut {\n        if (typeof initialValue === \"undefined\") {\n            initialValue = 0;\n        }\n\n        const multiEdges: EdgeImmutPlain[] = [];\n        this.nodes.forEach((node) => {\n            // If we have duplicates\n            const adj = this.getNodeAdjacency(node.getID());\n            const uniques = new Set(adj);\n            if (uniques.size < adj.length) {\n                uniques.forEach((to) => {\n                    const newWeight = this.getEdgesBetween(node.getID(), to).reduce((acc, edge) => {\n                        return reducer(acc, edge.getWeight());\n                    }, initialValue);\n\n                    multiEdges.push({from: node.getID(), to, weight: parseFloat(newWeight)});\n                });\n            }\n        });\n\n        // Remove all multigraph edges and replace them with single new edges\n        let newEdges = this.edges.filter((edge) => {\n            let keep = true;\n            multiEdges.forEach((duplicateEdge) => {\n                if (edge.getFrom() === duplicateEdge.from && edge.getTo() === duplicateEdge.to) {\n                    keep = false;\n                }\n            });\n\n            return keep;\n        }) as List<EdgeImmut>;\n        multiEdges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.from, edge.to, edge.weight));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    isWeighted() {\n        return this.weighted;\n    }\n\n    isDirected() {\n        return this.directed;\n    }\n}\n"],"sourceRoot":""}