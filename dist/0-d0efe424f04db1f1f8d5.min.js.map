{"version":3,"sources":["webpack:///./src/js/GraphAlgorithms.ts","webpack:///./src/js/SpanningTree.ts"],"names":["GraphAlgorithms_self","colorNetwork","graphState","window","main","G","graph","nodeArr","genericHelpers","datasetToArray","getAllNodes","degrees","getAllOutDegrees","vertexOrder","sort","a","b","colorIndex","currentColor","length","root","shift","myGroup","push","i","p","conflict","j","areAdjacent","splice","colors","chromaticNumber","max","flatten","connectedComponents","components","componentCount","setComponentNum","v","getNumberOfNodes","depthFirstSearch","forEach","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","w","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","showSimpleModal","queue","this","_nodes","enqueue","priority","key","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","V","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","vertexAdjacency","bottleneckValue","maxFlow","flowPath","f","getFlows","kruskal","set","[object Object]","id","q","connected","union","mst","totalWeight","reduce","acc","topologicalSort","adjacency","getFullAdjacency","graphHelpers","findVertexDegreesDirectional","L","filter","n","in","edges","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","scc","getProperty","eulerian","component","deg","out","hasEulerianCircuit","cc","__webpack_exports__"],"mappings":"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","file":"0-d0efe424f04db1f1f8d5.min.js","sourcesContent":["\"use strict\";\r\n\r\nimport genericH from './genericHelpers';\r\nimport graphH from './graphHelpers';\r\nimport SpanningTree from './SpanningTree';\r\n\r\nlet self = {\r\n    // Welsh-Powell Algorithm\r\n    colorNetwork: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Get node ID's only\r\n        let nodeArr = <Readonly<any[]>> genericH.datasetToArray(G.getAllNodes(), \"id\");\r\n\r\n        // Put vertices in array in decreasing order of degree\r\n        let degrees = G.getAllOutDegrees();\r\n        let vertexOrder = genericH.sort(<any[]> nodeArr, (a, b) => {\r\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\r\n        });\r\n\r\n        let colorIndex = {};\r\n        let currentColor = 0;\r\n        while (vertexOrder.length > 0) {\r\n            let root = vertexOrder.shift();\r\n            colorIndex[root] = currentColor;\r\n\r\n            let myGroup = [];\r\n            myGroup.push(root);\r\n\r\n            for (let i = 0; i < vertexOrder.length;) {\r\n                let p = vertexOrder[i];\r\n                let conflict = false;\r\n\r\n                for (let j = 0; j < myGroup.length; j++) {\r\n                    if (G.areAdjacent(p, myGroup[j])) {\r\n                        i++;\r\n                        conflict = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (conflict) {\r\n                    continue;\r\n                }\r\n\r\n                colorIndex[p] = currentColor;\r\n                myGroup.push(p);\r\n                vertexOrder.splice(i, 1);\r\n            }\r\n\r\n            currentColor++;\r\n        }\r\n\r\n        let chromaticNumber = genericH.max(<any[]> genericH.flatten(colorIndex)) + 1;\r\n        return {colors: colorIndex, chromaticNumber: chromaticNumber};\r\n    },\r\n\r\n    connectedComponents: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let components = {};\r\n        let componentCount = 0;\r\n        const setComponentNum = (v) => {\r\n            components[v] = componentCount;\r\n        };\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in components)) {\r\n                let visited = self.depthFirstSearch(G, i);\r\n                visited.forEach(setComponentNum);\r\n                componentCount++;\r\n            }\r\n        }\r\n\r\n        return {components: components, count: componentCount};\r\n    },\r\n\r\n    depthFirstSearch: (G = window.main.graphState.graph, start) => {\r\n        let visisted = [];\r\n        let Stack = [];\r\n        Stack.push(start);\r\n        while (Stack.length > 0) {\r\n            let v = Stack.pop();\r\n            if (!visisted.includes(v)) {\r\n                visisted.push(v);\r\n                G.getNodeAdjacency(v).forEach((nodeID) => {\r\n                    Stack.push(nodeID);\r\n                });\r\n            }\r\n        }\r\n\r\n        return visisted;\r\n    },\r\n\r\n    // Tarjan's algorithm\r\n    stronglyConnectedComponents: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let index = 0;\r\n        let indices = {};\r\n        let lowlink = {};\r\n        let S = [];\r\n        let components = {};\r\n        let componentCount = 0;\r\n\r\n        let strongConnect = (v) => {\r\n            indices[v] = index;\r\n            lowlink[v] = index++;\r\n            S.push(v);\r\n\r\n            G.getNodeAdjacency(v).forEach((w) => {\r\n                if (!(w in indices)) {\r\n                    strongConnect(w);\r\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\r\n                }\r\n                else if (S.includes(w)) {\r\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\r\n                }\r\n            });\r\n\r\n            if (lowlink[v] === indices[v]) {\r\n                let w = -1;\r\n                if (S.length > 0) {\r\n                    do {\r\n                        w = S.pop();\r\n                        components[w] = componentCount;\r\n                    }\r\n                    while (w !== v);\r\n                    componentCount++;\r\n                }\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in indices)) {\r\n                strongConnect(i);\r\n            }\r\n        }\r\n\r\n        return {components: components, count: componentCount};\r\n    },\r\n\r\n    breadthFirstSearch: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Perform the BFS\r\n        let visisted = [];\r\n        let Q = []; // Use Push and Shift for Queue operations\r\n        let edgeTo = {};\r\n\r\n        Q.push(startNodeID);\r\n        while (Q.length > 0) {\r\n            let x = Q.shift();\r\n            if (!visisted.includes(x)) {\r\n                visisted.push(x);\r\n                G.getNodeAdjacency(x).forEach((y) => {\r\n                    if (!visisted.includes(y)) {\r\n                        edgeTo[y] = x;\r\n                        Q.push(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visisted.includes(targetNodeID)) {\r\n            // Build the path\r\n            let path = [];\r\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\r\n                path.push(x);\r\n            }\r\n            path.push(startNodeID);\r\n            path.reverse();\r\n\r\n            // Get the path weight\r\n            let weight = 0;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\r\n            }\r\n\r\n            return {pathExists: true, path: path, distance: path.length, weight: weight};\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, weight: -1};\r\n    },\r\n\r\n    dijkstraSearch: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        if (!G.isDirected()) {\r\n            G = G.asDirected(true);\r\n        }\r\n        if (!G.isWeighted()) {\r\n            G = G.asWeighted();\r\n        }\r\n\r\n        let nonNegative = G.getAllEdges(true).find((edge) => {\r\n            return edge.getWeight() < 0;\r\n        });\r\n        if (typeof nonNegative !== \"undefined\") {\r\n            genericH.showSimpleModal(\"Dijkstra Error\", \"<p>The Dijkstra algorithm only works on graphs\" +\r\n                \" with totally non-negative edge weights. Please fix the graph so that there are no\" +\r\n                \" negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves\" +\r\n                \" exactly this problem.</p>\");\r\n            return false;\r\n        }\r\n\r\n        // Priority Queue implementation for Dijkstra\r\n        const PriorityQueue = function () {\r\n            this._nodes = [];\r\n\r\n            this.enqueue = function (priority, key) {\r\n                this._nodes.push({key: key, priority: priority});\r\n                this.sort();\r\n            };\r\n            this.dequeue = function () {\r\n                return this._nodes.shift().key;\r\n            };\r\n            this.sort = function () {\r\n                this._nodes.sort(function (a, b) {\r\n                    return a.priority - b.priority;\r\n                });\r\n            };\r\n            this.isEmpty = function () {\r\n                return !this._nodes.length;\r\n            };\r\n        };\r\n\r\n        let queue = new PriorityQueue();\r\n        let distances = {};\r\n        let previous = {};\r\n        let path = [];\r\n\r\n        // Initialize Queue and distances\r\n        G.getAllNodes(true).forEach((node) => {\r\n            let dist = Infinity;\r\n            if (node.getID() === startNodeID) {\r\n                dist = 0;\r\n            }\r\n\r\n            distances[node.getID()] = dist;\r\n            queue.enqueue(dist, node.getID());\r\n            previous[node.getID()] = null;\r\n        });\r\n\r\n        while (!queue.isEmpty()) {\r\n            let smallest = queue.dequeue();\r\n\r\n            if (smallest === targetNodeID) {\r\n                path = [];\r\n                while (previous[smallest] !== null) {\r\n                    path.push(smallest);\r\n                    smallest = previous[smallest];\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (distances[smallest] === Infinity) {\r\n                continue;\r\n            }\r\n\r\n            G.getNodeAdjacency(smallest).forEach((neighbor) => {\r\n                let alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\r\n\r\n                if (alt < distances[neighbor]) {\r\n                    distances[neighbor] = alt;\r\n                    previous[neighbor] = smallest;\r\n\r\n                    queue.enqueue(alt, neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        path.push(startNodeID);\r\n        path.reverse();\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            return {pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    },\r\n\r\n    bellmanFord: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let distances = [];\r\n        let parents = [];\r\n\r\n        // Initialize\r\n        G.getAllNodes(true).forEach((node) => {\r\n            distances[node.getID()] = Infinity;\r\n            parents[node.getID()] = null;\r\n        });\r\n\r\n        // Relax Edges\r\n        distances[startNodeID] = 0;\r\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\r\n            G.getAllEdges(true).forEach((edge) => {\r\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\r\n                    parents[edge.getTo()] = edge.getFrom();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for negative weight cycles\r\n        let negativeCylce = false;\r\n        G.getAllEdges(true).forEach((edge) => {\r\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                negativeCylce = true;\r\n            }\r\n        });\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            let path = [targetNodeID];\r\n            while (!path.includes(startNodeID)) {\r\n                path.push(parents[path.slice().pop()]);\r\n            }\r\n            path.reverse();\r\n\r\n            return {pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n        if (negativeCylce) {\r\n            genericH.showSimpleModal(\"Bellman-Ford Error\", \"<p>The Bellman-Ford algorithm only works on graphs\" +\r\n                \" with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>\");\r\n            return false;\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    },\r\n\r\n    fordFulkerson: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Must be a directed graph\r\n        if (!G.isDirected()) {\r\n            return false;\r\n        }\r\n\r\n        // Source == sink\r\n        if (startNodeID === targetNodeID) {\r\n            return false;\r\n        }\r\n\r\n        let bfs = self.breadthFirstSearch(startNodeID, targetNodeID, graphState);\r\n        // No path from source to sink\r\n        if (!bfs.pathExists) {\r\n            return false;\r\n        }\r\n\r\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\r\n        G = G.reduceMultiGraph((a, b) => {\r\n            return a + b;\r\n        });\r\n\r\n        let V = G.getNumberOfNodes();\r\n        let value = 0;\r\n        let marked = null;\r\n        let edgeTo = null;\r\n\r\n        let edgeProperties = {};\r\n        G.getAllEdges(true).forEach((edge) => {\r\n            edgeProperties[edge.getFrom() + \"_\" + edge.getTo()] = {\r\n                from: edge.getFrom(),\r\n                to: edge.getTo(),\r\n                capacity: edge.getWeight(),\r\n                flow: 0\r\n            };\r\n        });\r\n\r\n        const other = (e, x) => {\r\n            e = e.split(\"_\");\r\n            let a = parseInt(e[0]);\r\n            let b = parseInt(e[1]);\r\n            return x === a ? b : a;\r\n        };\r\n\r\n        const residualCapacity = (e, x) => {\r\n            let edge = e.split(\"_\");\r\n            let a = parseInt(edge[0]);\r\n            if (x === a) {\r\n                return edgeProperties[e].flow;\r\n            }\r\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\r\n        };\r\n\r\n        const addResidualFlow = (e, x, deltaFlow) => {\r\n            let edge = e.split(\"_\");\r\n            let v = parseInt(edge[0]);\r\n            if (x === v) {\r\n                edgeProperties[e].flow -= deltaFlow;\r\n            }\r\n            else {\r\n                edgeProperties[e].flow += deltaFlow;\r\n            }\r\n        };\r\n\r\n        const hasAugmentedPath = () => {\r\n            marked = [];\r\n            edgeTo = [];\r\n            for (let v = 0; v < V; ++v) {\r\n                marked.push(false);\r\n                edgeTo.push(null);\r\n            }\r\n\r\n            let queue = [];\r\n            queue.push(startNodeID);\r\n\r\n            marked[startNodeID] = true;\r\n            while (queue.length > 0) {\r\n                let v = queue.shift();\r\n                let vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (let i = 0; i < vertexAdjacency.length; i++) {\r\n                    let e = v + \"_\" + vertexAdjacency[i];\r\n                    let w = other(e, v);\r\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\r\n                        edgeTo[w] = e;\r\n                        marked[w] = true;\r\n                        if (w === targetNodeID) {\r\n                            return true;\r\n                        }\r\n\r\n                        queue.push(w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        while (hasAugmentedPath()) {\r\n            let bottleneckValue = Infinity;\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x], x));\r\n            }\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                addResidualFlow(edgeTo[x], x, bottleneckValue);\r\n            }\r\n            value += bottleneckValue;\r\n        }\r\n\r\n        const getFlows = () => {\r\n            let f = [];\r\n            for (let v = 0; v < V; v++) {\r\n                let vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (let i = 0; i < vertexAdjacency.length; i++) {\r\n                    let e = v + \"_\" + vertexAdjacency[i];\r\n                    if (edgeProperties[e].flow > 0) {\r\n                        f.push(edgeProperties[e]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return f;\r\n        };\r\n\r\n        return {maxFlow: value, flowPath: getFlows()};\r\n    },\r\n\r\n    kruskal: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // If we have a multigraph, reduce it by using the minimum edge weights\r\n        G.reduceMultiGraph(Math.min, Infinity);\r\n\r\n        let Q = G.getAllEdges(true);\r\n\r\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\r\n        Q.sort((a, b) => {\r\n            return a.getWeight() - b.getWeight();\r\n        });\r\n\r\n        let kruskal = [];\r\n        let set = new SpanningTree(G.getNumberOfNodes());\r\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\r\n            let e = Q.shift();\r\n            if (!set.connected(e.getFrom(), e.getTo())) {\r\n                set.union(e.getFrom(), e.getTo());\r\n                kruskal.push(e);\r\n            }\r\n        }\r\n\r\n        // Get the total cost of the MST\r\n        let weight = kruskal.reduce((acc, e) => {\r\n            return acc + e.getWeight();\r\n        }, 0);\r\n\r\n        return {mst: kruskal, totalWeight: weight};\r\n    },\r\n\r\n    topologicalSort: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let adjacency = G.getFullAdjacency();\r\n        let degrees = graphH.findVertexDegreesDirectional(adjacency);\r\n\r\n        let L = [];\r\n        let S = G.getAllNodes(true).filter((n) => {\r\n            return degrees[n.getID()].in === 0;\r\n        });\r\n        let edges = G.getAllEdges(true);\r\n\r\n        while (S.length !== 0) {\r\n            let nodeN = S.pop();\r\n            L.push(nodeN);\r\n\r\n            let nodeNConnectedTo = adjacency[nodeN.getID()];\r\n\r\n            // Remove n to m edges for all nodes m\r\n            edges = edges.filter((edge) => {\r\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\r\n                    degrees[edge.getTo()].in--;\r\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter((v) => {\r\n                        return v !== edge.getTo();\r\n                    });\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // If m has no more incoming edges, add it to S\r\n            nodeNConnectedTo.forEach((mID) => {\r\n                if (degrees[mID].in === 0) {\r\n                    S.push(G.getNode(mID, true));\r\n                }\r\n            });\r\n        }\r\n\r\n        return edges.length > 0 || L;\r\n    },\r\n\r\n    isGraphCyclic: (graphState = window.main.graphState) => {\r\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\r\n        return self.topologicalSort(graphState) === true;\r\n    },\r\n\r\n    directionalEulerian: (directionalDegrees, graphState = window.main.graphState) => {\r\n        let scc = graphState.getProperty(\"stronglyConnectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        directionalDegrees.forEach((deg, id) => {\r\n            if (deg.in !== deg.out) {\r\n                eulerian = false;\r\n            }\r\n            if (deg.in > 0) {\r\n                if (component === -1) {\r\n                    component = scc[id];\r\n                }\r\n                if (component !== scc[id]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    },\r\n\r\n    hasEulerianCircuit: (degrees, graphState = window.main.graphState) => {\r\n        let oddDegree = degrees.filter((v) => {\r\n            return v % 2 !== 0;\r\n        });\r\n\r\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\r\n        if (oddDegree.length !== 0) {\r\n            return false;\r\n        }\r\n\r\n        let cc = graphState.getProperty(\"connectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        degrees.forEach((v, i) => {\r\n            if (v !== 0) {\r\n                if (component === -1) {\r\n                    component = cc[i];\r\n                }\r\n                if (component !== cc[i]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nexport default class SpanningTree {\r\n    private id: number[];\r\n\r\n    constructor(V: number) {\r\n        this.id = [];\r\n        for (let v = 0; v < V; v++) {\r\n            this.id.push(v);\r\n        }\r\n    }\r\n\r\n    union(v: number, w: number) {\r\n        let q = this.root(v);\r\n        let p = this.root(w);\r\n\r\n        if (p !== q) {\r\n            this.id[p] = q;\r\n        }\r\n    }\r\n\r\n    root(q: number) {\r\n        while (this.id[q] !== q) {\r\n            q = this.id[q];\r\n        }\r\n        return q;\r\n    }\r\n\r\n    connected(v: number, w: number) {\r\n        return this.root(v) === this.root(w);\r\n    }\r\n}\r\n"],"sourceRoot":""}