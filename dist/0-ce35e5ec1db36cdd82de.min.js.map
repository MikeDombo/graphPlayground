{"version":3,"sources":["webpack:///./src/js/SpanningTree.js","webpack:///./src/js/GraphAlgorithms.js"],"names":["SpanningTree_SpanningTree","V","this","id","v","push","prototype","constructor","union","w","q","root","p","connected","js_SpanningTree","genericHelpers","deepFreeze","GraphAlgorithms_self","colorNetwork","graphState","window","main","G","graph","nodeArr","datasetToArray","getAllNodes","degrees","getAllOutDegrees","vertexOrder","sort","a","b","colorIndex","currentColor","length","shift","myGroup","i","conflict","j","areAdjacent","splice","colors","chromaticNumber","max","flatten","connectedComponents","components","componentCount","setComponentNum","getNumberOfNodes","depthFirstSearch","forEach","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","showSimpleModal","queue","_nodes","enqueue","priority","key","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","vertexAdjacency","bottleneckValue","maxFlow","flowPath","f","getFlows","kruskal","set","mst","totalWeight","reduce","acc","topologicalSort","adjacency","getFullAdjacency","graphHelpers","findVertexDegreesDirectional","L","filter","n","in","edges","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","scc","getProperty","eulerian","component","deg","out","hasEulerianCircuit","cc","__webpack_exports__"],"mappings":"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","file":"0-ce35e5ec1db36cdd82de.min.js","sourcesContent":["\"use strict\";\r\n\r\nimport genericH from \"./genericHelpers\";\r\n\r\nlet SpanningTree = function (V) {\r\n    this.id = [];\r\n    for (let v = 0; v < V; v++) {\r\n        this.id.push(v);\r\n    }\r\n};\r\n\r\nSpanningTree.prototype = {\r\n    constructor: SpanningTree,\r\n    union: function (v, w) {\r\n        let q = this.root(v);\r\n        let p = this.root(w);\r\n\r\n        if (p !== q) {\r\n            this.id[p] = q;\r\n        }\r\n    },\r\n\r\n    root: function (q) {\r\n        while (this.id[q] !== q) {\r\n            q = this.id[q];\r\n        }\r\n        return q;\r\n    },\r\n\r\n    connected: function (v, w) {\r\n        return this.root(v) === this.root(w);\r\n    }\r\n};\r\n\r\nexport default genericH.deepFreeze(SpanningTree);\r\n","\"use strict\";\r\n\r\nimport genericH from './genericHelpers';\r\nimport graphH from './graphHelpers';\r\nimport SpanningTree from './SpanningTree';\r\n\r\nlet self = {\r\n    // Welsh-Powell Algorithm\r\n    colorNetwork: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Get node ID's only\r\n        let nodeArr = genericH.datasetToArray(G.getAllNodes(), \"id\");\r\n\r\n        // Put vertices in array in decreasing order of degree\r\n        let degrees = G.getAllOutDegrees();\r\n        let vertexOrder = genericH.sort(nodeArr, (a, b) => {\r\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\r\n        });\r\n\r\n        let colorIndex = {};\r\n        let currentColor = 0;\r\n        while (vertexOrder.length > 0) {\r\n            let root = vertexOrder.shift();\r\n            colorIndex[root] = currentColor;\r\n\r\n            let myGroup = [];\r\n            myGroup.push(root);\r\n\r\n            for (let i = 0; i < vertexOrder.length;) {\r\n                let p = vertexOrder[i];\r\n                let conflict = false;\r\n\r\n                for (let j = 0; j < myGroup.length; j++) {\r\n                    if (G.areAdjacent(p, myGroup[j])) {\r\n                        i++;\r\n                        conflict = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (conflict) {\r\n                    continue;\r\n                }\r\n\r\n                colorIndex[p] = currentColor;\r\n                myGroup.push(p);\r\n                vertexOrder.splice(i, 1);\r\n            }\r\n\r\n            currentColor++;\r\n        }\r\n\r\n        let chromaticNumber = genericH.max(genericH.flatten(colorIndex)) + 1;\r\n        return {colors: colorIndex, chromaticNumber: chromaticNumber};\r\n    },\r\n\r\n    connectedComponents: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let components = {};\r\n        let componentCount = 0;\r\n        const setComponentNum = (v) => {\r\n            components[v] = componentCount;\r\n        };\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in components)) {\r\n                let visited = self.depthFirstSearch(G, i);\r\n                visited.forEach(setComponentNum);\r\n                componentCount++;\r\n            }\r\n        }\r\n\r\n        return {components: components, count: componentCount};\r\n    },\r\n\r\n    depthFirstSearch: (G = window.main.graphState.graph, start) => {\r\n        let visisted = [];\r\n        let Stack = [];\r\n        Stack.push(start);\r\n        while (Stack.length > 0) {\r\n            let v = Stack.pop();\r\n            if (!visisted.includes(v)) {\r\n                visisted.push(v);\r\n                G.getNodeAdjacency(v).forEach((nodeID) => {\r\n                    Stack.push(nodeID);\r\n                });\r\n            }\r\n        }\r\n\r\n        return visisted;\r\n    },\r\n\r\n    // Tarjan's algorithm\r\n    stronglyConnectedComponents: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let index = 0;\r\n        let indices = {};\r\n        let lowlink = {};\r\n        let S = [];\r\n        let components = {};\r\n        let componentCount = 0;\r\n\r\n        let strongConnect = (v) => {\r\n            indices[v] = index;\r\n            lowlink[v] = index++;\r\n            S.push(v);\r\n\r\n            G.getNodeAdjacency(v).forEach((w) => {\r\n                if (!(w in indices)) {\r\n                    strongConnect(w);\r\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\r\n                }\r\n                else if (S.includes(w)) {\r\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\r\n                }\r\n            });\r\n\r\n            if (lowlink[v] === indices[v]) {\r\n                let w = -1;\r\n                if (S.length > 0) {\r\n                    do {\r\n                        w = S.pop();\r\n                        components[w] = componentCount;\r\n                    }\r\n                    while (w !== v);\r\n                    componentCount++;\r\n                }\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in indices)) {\r\n                strongConnect(i);\r\n            }\r\n        }\r\n\r\n        return {components: components, count: componentCount};\r\n    },\r\n\r\n    breadthFirstSearch: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Perform the BFS\r\n        let visisted = [];\r\n        let Q = []; // Use Push and Shift for Queue operations\r\n        let edgeTo = {};\r\n\r\n        Q.push(startNodeID);\r\n        while (Q.length > 0) {\r\n            let x = Q.shift();\r\n            if (!visisted.includes(x)) {\r\n                visisted.push(x);\r\n                G.getNodeAdjacency(x).forEach((y) => {\r\n                    if (!visisted.includes(y)) {\r\n                        edgeTo[y] = x;\r\n                        Q.push(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visisted.includes(targetNodeID)) {\r\n            // Build the path\r\n            let path = [];\r\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\r\n                path.push(x);\r\n            }\r\n            path.push(startNodeID);\r\n            path.reverse();\r\n\r\n            // Get the path weight\r\n            let weight = 0;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\r\n            }\r\n\r\n            return {pathExists: true, path: path, distance: path.length, weight: weight};\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, weight: -1};\r\n    },\r\n\r\n    dijkstraSearch: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        if (!G.isDirected()) {\r\n            G = G.asDirected(true);\r\n        }\r\n        if (!G.isWeighted()) {\r\n            G = G.asWeighted();\r\n        }\r\n\r\n        let nonNegative = G.getAllEdges(true).find((edge) => {\r\n            return edge.getWeight() < 0;\r\n        });\r\n        if (typeof nonNegative !== \"undefined\") {\r\n            genericH.showSimpleModal(\"Dijkstra Error\", \"<p>The Dijkstra algorithm only works on graphs\" +\r\n                \" with totally non-negative edge weights. Please fix the graph so that there are no\" +\r\n                \" negative edge weights.</p><p>Alternatively, try the Bellman-Ford algorithm which solves\" +\r\n                \" exactly this problem.</p>\");\r\n            return false;\r\n        }\r\n\r\n        // Priority Queue implementation for Dijkstra\r\n        const PriorityQueue = function () {\r\n            this._nodes = [];\r\n\r\n            this.enqueue = function (priority, key) {\r\n                this._nodes.push({key: key, priority: priority});\r\n                this.sort();\r\n            };\r\n            this.dequeue = function () {\r\n                return this._nodes.shift().key;\r\n            };\r\n            this.sort = function () {\r\n                this._nodes.sort(function (a, b) {\r\n                    return a.priority - b.priority;\r\n                });\r\n            };\r\n            this.isEmpty = function () {\r\n                return !this._nodes.length;\r\n            };\r\n        };\r\n\r\n        let queue = new PriorityQueue();\r\n        let distances = {};\r\n        let previous = {};\r\n        let path = [];\r\n\r\n        // Initialize Queue and distances\r\n        G.getAllNodes(true).forEach((node) => {\r\n            let dist = Infinity;\r\n            if (node.getID() === startNodeID) {\r\n                dist = 0;\r\n            }\r\n\r\n            distances[node.getID()] = dist;\r\n            queue.enqueue(dist, node.getID());\r\n            previous[node.getID()] = null;\r\n        });\r\n\r\n        while (!queue.isEmpty()) {\r\n            let smallest = queue.dequeue();\r\n\r\n            if (smallest === targetNodeID) {\r\n                path = [];\r\n                while (previous[smallest] !== null) {\r\n                    path.push(smallest);\r\n                    smallest = previous[smallest];\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (distances[smallest] === Infinity) {\r\n                continue;\r\n            }\r\n\r\n            G.getNodeAdjacency(smallest).forEach((neighbor) => {\r\n                let alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\r\n\r\n                if (alt < distances[neighbor]) {\r\n                    distances[neighbor] = alt;\r\n                    previous[neighbor] = smallest;\r\n\r\n                    queue.enqueue(alt, neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        path.push(startNodeID);\r\n        path.reverse();\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            return {pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    },\r\n\r\n    bellmanFord: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let distances = [];\r\n        let parents = [];\r\n\r\n        // Initialize\r\n        G.getAllNodes(true).forEach((node) => {\r\n            distances[node.getID()] = Infinity;\r\n            parents[node.getID()] = null;\r\n        });\r\n\r\n        // Relax Edges\r\n        distances[startNodeID] = 0;\r\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\r\n            G.getAllEdges(true).forEach((edge) => {\r\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\r\n                    parents[edge.getTo()] = edge.getFrom();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for negative weight cycles\r\n        let negativeCylce = false;\r\n        G.getAllEdges(true).forEach((edge) => {\r\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                negativeCylce = true;\r\n            }\r\n        });\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            let path = [targetNodeID];\r\n            while (!path.includes(startNodeID)) {\r\n                path.push(parents[path.slice().pop()]);\r\n            }\r\n            path.reverse();\r\n\r\n            return {pathExists: true, path: path, distance: path.length, cost: distances[targetNodeID]};\r\n        }\r\n\r\n        if (negativeCylce) {\r\n            genericH.showSimpleModal(\"Bellman-Ford Error\", \"<p>The Bellman-Ford algorithm only works on graphs\" +\r\n                \" with no negative edge-weight cycles. Please remove the negative cycle and try again.</p>\");\r\n            return false;\r\n        }\r\n\r\n        return {pathExists: false, path: [], distance: -1, cost: 0};\r\n    },\r\n\r\n    fordFulkerson: (startNodeID, targetNodeID, graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // Must be a directed graph\r\n        if (!G.isDirected()) {\r\n            return false;\r\n        }\r\n\r\n        // Source == sink\r\n        if (startNodeID === targetNodeID) {\r\n            return false;\r\n        }\r\n\r\n        let bfs = self.breadthFirstSearch(startNodeID, targetNodeID, graphState);\r\n        // No path from source to sink\r\n        if (!bfs.pathExists) {\r\n            return false;\r\n        }\r\n\r\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\r\n        G = G.reduceMultiGraph((a, b) => {\r\n            return a + b;\r\n        });\r\n\r\n        let V = G.getNumberOfNodes();\r\n        let value = 0;\r\n        let marked = null;\r\n        let edgeTo = null;\r\n\r\n        let edgeProperties = {};\r\n        G.getAllEdges(true).forEach((edge) => {\r\n            edgeProperties[edge.getFrom() + \"_\" + edge.getTo()] = {\r\n                from: edge.getFrom(),\r\n                to: edge.getTo(),\r\n                capacity: edge.getWeight(),\r\n                flow: 0\r\n            };\r\n        });\r\n\r\n        const other = (e, x) => {\r\n            e = e.split(\"_\");\r\n            let a = parseInt(e[0]);\r\n            let b = parseInt(e[1]);\r\n            return x === a ? b : a;\r\n        };\r\n\r\n        const residualCapacity = (e, x) => {\r\n            let edge = e.split(\"_\");\r\n            let a = parseInt(edge[0]);\r\n            if (x === a) {\r\n                return edgeProperties[e].flow;\r\n            }\r\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\r\n        };\r\n\r\n        const addResidualFlow = (e, x, deltaFlow) => {\r\n            let edge = e.split(\"_\");\r\n            let v = parseInt(edge[0]);\r\n            if (x === v) {\r\n                edgeProperties[e].flow -= deltaFlow;\r\n            }\r\n            else {\r\n                edgeProperties[e].flow += deltaFlow;\r\n            }\r\n        };\r\n\r\n        const hasAugmentedPath = () => {\r\n            marked = [];\r\n            edgeTo = [];\r\n            for (let v = 0; v < V; ++v) {\r\n                marked.push(false);\r\n                edgeTo.push(null);\r\n            }\r\n\r\n            let queue = [];\r\n            queue.push(startNodeID);\r\n\r\n            marked[startNodeID] = true;\r\n            while (queue.length > 0) {\r\n                let v = queue.shift();\r\n                let vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (let i = 0; i < vertexAdjacency.length; i++) {\r\n                    let e = v + \"_\" + vertexAdjacency[i];\r\n                    let w = other(e, v);\r\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\r\n                        edgeTo[w] = e;\r\n                        marked[w] = true;\r\n                        if (w === targetNodeID) {\r\n                            return true;\r\n                        }\r\n\r\n                        queue.push(w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        while (hasAugmentedPath()) {\r\n            let bottleneckValue = Infinity;\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x], x));\r\n            }\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x], x)) {\r\n                addResidualFlow(edgeTo[x], x, bottleneckValue);\r\n            }\r\n            value += bottleneckValue;\r\n        }\r\n\r\n        const getFlows = () => {\r\n            let f = [];\r\n            for (let v = 0; v < V; v++) {\r\n                let vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (let i = 0; i < vertexAdjacency.length; i++) {\r\n                    let e = v + \"_\" + vertexAdjacency[i];\r\n                    if (edgeProperties[e].flow > 0) {\r\n                        f.push(edgeProperties[e]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return f;\r\n        };\r\n\r\n        return {maxFlow: value, flowPath: getFlows()};\r\n    },\r\n\r\n    kruskal: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        // If we have a multigraph, reduce it by using the minimum edge weights\r\n        G.reduceMultiGraph(Math.min, Infinity);\r\n\r\n        let Q = G.getAllEdges(true);\r\n\r\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\r\n        Q.sort((a, b) => {\r\n            return a.getWeight() - b.getWeight();\r\n        });\r\n\r\n        let kruskal = [];\r\n        let set = new SpanningTree(G.getNumberOfNodes());\r\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\r\n            let e = Q.shift();\r\n            if (!set.connected(e.getFrom(), e.getTo())) {\r\n                set.union(e.getFrom(), e.getTo());\r\n                kruskal.push(e);\r\n            }\r\n        }\r\n\r\n        // Get the total cost of the MST\r\n        let weight = kruskal.reduce((acc, e) => {\r\n            return acc + e.getWeight();\r\n        }, 0);\r\n\r\n        return {mst: kruskal, totalWeight: weight};\r\n    },\r\n\r\n    topologicalSort: (graphState = window.main.graphState) => {\r\n        let G = graphState.graph;\r\n\r\n        let adjacency = G.getFullAdjacency();\r\n        let degrees = graphH.findVertexDegreesDirectional(adjacency);\r\n\r\n        let L = [];\r\n        let S = G.getAllNodes(true).filter((n) => {\r\n            return degrees[n.getID()].in === 0;\r\n        });\r\n        let edges = G.getAllEdges(true);\r\n\r\n        while (S.length !== 0) {\r\n            let nodeN = S.pop();\r\n            L.push(nodeN);\r\n\r\n            let nodeNConnectedTo = adjacency[nodeN.getID()];\r\n\r\n            // Remove n to m edges for all nodes m\r\n            edges = edges.filter((edge) => {\r\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\r\n                    degrees[edge.getTo()].in--;\r\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter((v) => {\r\n                        return v !== edge.getTo();\r\n                    });\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // If m has no more incoming edges, add it to S\r\n            nodeNConnectedTo.forEach((mID) => {\r\n                if (degrees[mID].in === 0) {\r\n                    S.push(G.getNode(mID, true));\r\n                }\r\n            });\r\n        }\r\n\r\n        return edges.length > 0 || L;\r\n    },\r\n\r\n    isGraphCyclic: (graphState = window.main.graphState) => {\r\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\r\n        return self.topologicalSort(graphState) === true;\r\n    },\r\n\r\n    directionalEulerian: (directionalDegrees, graphState = window.main.graphState) => {\r\n        let scc = graphState.getProperty(\"stronglyConnectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        directionalDegrees.forEach((deg, id) => {\r\n            if (deg.in !== deg.out) {\r\n                eulerian = false;\r\n            }\r\n            if (deg.in > 0) {\r\n                if (component === -1) {\r\n                    component = scc[id];\r\n                }\r\n                if (component !== scc[id]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    },\r\n\r\n    hasEulerianCircuit: (degrees, graphState = window.main.graphState) => {\r\n        let oddDegree = degrees.filter((v) => {\r\n            return v % 2 !== 0;\r\n        });\r\n\r\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\r\n        if (oddDegree.length !== 0) {\r\n            return false;\r\n        }\r\n\r\n        let cc = graphState.getProperty(\"connectedComponents\", true);\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        degrees.forEach((v, i) => {\r\n            if (v !== 0) {\r\n                if (component === -1) {\r\n                    component = cc[i];\r\n                }\r\n                if (component !== cc[i]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n"],"sourceRoot":""}