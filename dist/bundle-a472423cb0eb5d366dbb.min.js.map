{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/genericHelpers.ts","webpack:///./src/js/graphHelpers.ts","webpack:///./src/js/graphState.ts","webpack:///./src/js/main.ts","webpack:///./src/js/settings.ts","webpack:///./src/js/UIInteractions.ts","webpack:///./src/js/app.ts","webpack:///./src/js/GraphImmut/NodeImmut.ts","webpack:///./src/js/GraphImmut/EdgeImmut.ts","webpack:///./src/js/GraphImmut/GraphImmut.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","5","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","head","document","getElementsByTagName","script","createElement","charset","timeout","nc","setAttribute","src","p","0","1","2","setTimeout","onScriptComplete","type","target","event","onerror","onload","clearTimeout","chunk","errorType","realSrc","error","Error","request","undefined","appendChild","all","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","bind","slice","self","deepFreeze","freeze","getOwnPropertyNames","forEach","prop","isFrozen","sort","arr","compareFunction","datasetToArray","ds","key","v","keepOnlyKeys","keys","indexOf","getFileExtension","filename","split","htmlEncode","string","jquery__WEBPACK_IMPORTED_MODULE_0__","text","html","replace","printout","escape","flatten","map","rotate","max","iterable","reduce","a","b","Math","toTitleCase","str","match","toUpperCase","showSimpleModal","title","body","showFormModal","initialValue","makeFormModal","successText","form","footer","f","class","formRow","id","basicMap","extraAttrs","attrname","validFunc","container","validationFunc","generalValidator","valueMutator","$v","val","valid","removeClass","next","remove","addClass","after","append","checked","for","label","prepend","clickDismiss","$b","onclick","on","parseFloat","$options","optionText","oText","oIndex","optionValues","$footer","$modal","tabindex","role","aria-hidden","data-dismiss","aria-label","find","off","last","click","first","focus","successCb","cancelCb","modal","vals","hasErrors","each","tagName","attr","files","trigger","hasClass","__webpack_exports__","findVertexDegreesDirectional","adjacencyMatrix","degrees","out","in","outV","interpolateNodesFromEdges","edges","nodes","from","to","graphState_self","backHistory","forwardHistory","maxHistory","upToDate","applyFunc","ui","makeAndPrintGraphColoring","always","makeAndPrintEulerian","makeAndPrintConnectedComponents","makeAndPrintStronglyConnectedComponents","makeAndPrintIsCyclic","state","stronglyConnectedComponents","connectedComponents","graphColoring","graph","graphProperties","vertices","eulerian","Chromatic Number","Connected Components","Strongly Connected Components","cyclic","setUpToDate","listOptions","makeAndPrintProperties","getProperty","updateIfNotUpdated","recalcLong","directional","settings","getOption","getNumberOfNodes","getNumberOfEdges","printableProperties","printGraphProperties","properties","k","genericHelpers","trim","jquery","addEdge","weight","main","setData","clearColorFromNodes","getAllNodes","getAllEdges","addNode","x","y","editNode","getGraphData","editEdge","newWeight","oldWeight","newGraph","GraphImmut","deleteEdge","deleteNode","color","nodeIDToLabel","getNode","NodeImmut","getLabel","toString","nodeLabelToID","filter","node","toLowerCase","getID","rID","found","getGraphAsDataSet","isWeighted","index_network","setLocations","locations","newNodes","getAllNodesAsImmutableList","parseInt","getAttribute","set","getAllEdgesAsImmutableList","isDirected","clearColors","directed","weighted","main_self","graphState","getElementById","visWeightEdgeEdit","callback","visOptions","interaction","hover","manipulation","$popup","saveData","cancelEdit","confirm","network","_data","fromId","toId","operation","nodeLabelIDValidator","applyColors","graphColors","chromaticNumber","colors","randomColor_default","count","luminosity","G","recalcProps","graphChanged","rearrangeGraph","saveState","changeOption","g","randomizeNetworkLayoutSeed","getPositions","disableEditMode","enableEditMode","printGraphAlgorithms","saveStateLocalStorage","getStateForSaving","parent","includes","Array","isArray","undo","applyState","redo","newState","firstLoad","currentState","pop","oldKey","checkForLocalStorage","localStorage","setItem","JSON","stringify","shuffleNetworkLayout","round","random","layoutEngine","randomSeed","initialRandomSeed","addNetworkListeners","editEdgeMode","lastNetworkClickEvent","has","parents","deleteSelected","keydown","which","ctrlKey","shiftKey","settings_self","defaults","nodePhysics","direction","weights","current","removeItem","saveSettings","loadSettings","parse","getItem","setAll","setOptions","physics","arrows","editWithoutDrag","option","resetToDefault","asChangedDirectedWeighted","UIInteractions_makeAndPrintShortestPath","fn","values","source","sink","pathExists","distance","cost","path","UIInteractions_makeAndPrintComponents","stronglyConnected","UIInteractions_awaiter","cc","componentKey","gAlgo","then","default","components","UIInteractions_UIInteractions","[object Object]","display","makeAndPrintBFS","makeAndPrintDijkstra","makeAndPrintBFSP","makeAndPrintFFMCMF","makeAndPrintKruskal","makeAndPrintTopologicalSort","makeAndPrintDirectionalEulerian","makeSimpleClickListener","selector","preventDefault","printHelp","printOptions","this","predefined","Petersen","Konigsberg","Complete","Hypercube","Custom","makeImportFileModal","makeImportTextModal","makeExportFileModal","makeExportTextModal","asDirected","asUndirected","asWeighted","asUnweighted","colorNetwork","t","directionalEulerian","graphHelpers","getFullAdjacency","hasEulerianCircuit","getAllOutDegrees","breadthFirstSearch","dijkstraSearch","bellmanFord","fordFulkerson","maxFlow","flowPath","flow","capacity","kruskal","totalWeight","mst","isGraphCyclic","topologicalSort","$div","empty","addAlgoToPane","alg","href","getAlgorithms","singleton","install","Raven","app_loadDefault","app_awaiter","registerListeners","attributes","toReturn","attribute","assign","EdgeImmut","getFrom","getTo","GraphImmut_filterNodeExtraAttr","obj","GraphImmut_genericEdgesToImmutEdges","nodeMap","newEdges","immutable","edge","GraphImmut_genericNodesToImmutNodes","floor","nodeNum","GraphImmut_GraphImmut","numNodes","size","numEdges","alignTo","nodeCount","getAllAttributes","getWeight","rich","toPlain","deleteAll","foundOneEdge","foundFirst","index","toArray","doubleEdges","addedEdges","adj","getNodeAdjacency","id1","id2","edgeList","minWeight","Infinity","getEdgesBetween","reducer","multiEdges","uniques","Set","acc","keep","duplicateEdge"],"mappings":"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","file":"bundle-a472423cb0eb5d366dbb.min.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t5: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\t\tvar script = document.createElement('script');\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = __webpack_require__.p + \"\" + ({}[chunkId]||chunkId) + \"-\" + {\"0\":\"d0efe424f04db1f1f8d5\",\"1\":\"8f92d2300dde419096a8\",\"2\":\"b43bf7eb1a1e0d664da0\"}[chunkId] + \".min.js\";\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tfunction onScriptComplete(event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\tvar error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\thead.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([42,3]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\nimport {DataSet} from \"vis\";\r\n\r\ndeclare interface modalFormRow {\r\n    type: string;\r\n    label?: string;\r\n    initialValue?: any;\r\n    id?: string | number;\r\n    extraAttrs?: any;\r\n    validationFunc?: (value?: any, container?: JQuery<HTMLElement>) => boolean|string;\r\n    clickDismiss?: boolean;\r\n    onclick?: (...args: any[]) => void;\r\n    optionText?: any[];\r\n    optionValues?: any[];\r\n}\r\n\r\nlet self = {\r\n    deepFreeze: (o: any): Readonly<any> => {\r\n        Object.freeze(o);\r\n\r\n        Object.getOwnPropertyNames(o).forEach(prop => {\r\n            if (o.hasOwnProperty(prop) && o[prop] !== null\r\n                && (typeof o[prop] === \"object\" || typeof o[prop] === \"function\")\r\n                && !Object.isFrozen(o[prop])) {\r\n                self.deepFreeze(o[prop]);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    },\r\n\r\n    sort: (arr: any[], compareFunction: (a: any, b: any) => number): any[] => {\r\n        return [...arr].sort(compareFunction);\r\n    },\r\n\r\n    datasetToArray: (ds: DataSet<any>, key: string): Readonly<any> => {\r\n        let r = [];\r\n        ds.forEach((v) => {\r\n            r.push(v[key]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    keepOnlyKeys: (arr: any[], keys: string[]): any => {\r\n        arr = arr.slice();\r\n        arr.forEach((v) => {\r\n            let k = Object.keys(v);\r\n            k.forEach((key) => {\r\n                if (keys.indexOf(key) < 0) {\r\n                    delete v[key];\r\n                }\r\n            });\r\n        });\r\n        return self.deepFreeze(arr);\r\n    },\r\n\r\n    getFileExtension: (filename: string): string => {\r\n        return filename.split(\".\").splice(-1)[0];\r\n    },\r\n\r\n    htmlEncode: (string: string): string => {\r\n        string = $(\"<div>\").text(string).html();\r\n        string = string.replace(/(?:\\r\\n|\\r|\\n)/g, '<br/>');\r\n        return string;\r\n    },\r\n\r\n    printout: (text: string, escape?: string): void => {\r\n        if (escape) {\r\n            text = this.htmlEncode(escape);\r\n        }\r\n        $(\"#printout\").html(text);\r\n    },\r\n\r\n    flatten: (map: any): Readonly<any> => {\r\n        let r = [];\r\n        Object.keys(map).forEach((i) => {\r\n            r.push(map[i]);\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    rotate: (map: any): Readonly<any> => {\r\n        let r = {};\r\n        Object.keys(map).forEach((i) => {\r\n            if (map[i] in r) {\r\n                r[map[i]].push(i);\r\n            }\r\n            else {\r\n                r[map[i]] = [i];\r\n            }\r\n        });\r\n        return self.deepFreeze(r);\r\n    },\r\n\r\n    max: (iterable: any[]): number => {\r\n        return iterable.reduce((a, b) => {\r\n            return Math.max(a, b);\r\n        });\r\n    },\r\n\r\n    toTitleCase: (str: string): string => {\r\n        return str.replace(/(?:^|\\s)\\w/g, (match) => {\r\n            return match.toUpperCase();\r\n        });\r\n    },\r\n\r\n    showSimpleModal: (title: string, body: string): void => {\r\n        self.showFormModal(null, title, null, [{type: \"html\", initialValue: body}], null, false);\r\n    },\r\n\r\n    makeFormModal: (title: string, successText: string, form: modalFormRow[], footer: boolean = true): JQuery<HTMLElement> => {\r\n        let f = $(\"<div>\", {class: \"modal-body form-group\"});\r\n        form.forEach((formRow, i) => {\r\n            if (!(\"initialValue\" in formRow)) {\r\n                formRow.initialValue = \"\";\r\n            }\r\n\r\n            let id = \"form-modal-\" + i;\r\n            if (\"id\" in formRow && formRow.id !== \"\" && formRow.id !== null && typeof formRow.id === \"string\") {\r\n                id = formRow.id;\r\n            }\r\n\r\n            let basicMap: { class: string; id: string; value: any, [key: number]: any, [key: string]: any } =\r\n                {class: \"form-control\", id: id, value: formRow.initialValue};\r\n\r\n            if (\"extraAttrs\" in formRow) {\r\n                Object.keys(formRow.extraAttrs).forEach((attrname) => {\r\n                    if (typeof formRow.extraAttrs[attrname] !== \"function\") {\r\n                        basicMap[attrname] = formRow.extraAttrs[attrname];\r\n                    }\r\n                });\r\n            }\r\n\r\n            let validFunc = (value?: any, container?: JQuery<HTMLElement>): string|boolean => true;\r\n            if (\"validationFunc\" in formRow) {\r\n                validFunc = formRow.validationFunc;\r\n            }\r\n\r\n            let generalValidator = (event, valueMutator = null) => {\r\n                let $v = $(event.target);\r\n                let val = $v.val();\r\n                if (valueMutator !== null && typeof valueMutator === \"function\") {\r\n                    val = valueMutator(val);\r\n                }\r\n                let valid = validFunc(val, $v);\r\n\r\n                if (valid === true) {\r\n                    $v.removeClass(\"is-invalid\").next(\"#feedback-\" + i).remove();\r\n                }\r\n                else {\r\n                    $v.addClass(\"is-invalid\");\r\n                    if ($v.next(\"#feedback-\" + i).length === 0) {\r\n                        $v.after($(\"<div>\", {class: \"invalid-feedback\", id: \"feedback-\" + i}).text(valid));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (formRow.type === \"html\") {\r\n                f.append($(<string> formRow.initialValue));\r\n            }\r\n            else if (formRow.type === \"checkbox\") {\r\n                basicMap.type = \"checkbox\";\r\n                basicMap.class = \"form-check-input\";\r\n                delete basicMap.value;\r\n                if (formRow.initialValue) {\r\n                    basicMap.checked = \"\";\r\n                }\r\n\r\n                f.append($(\"<div>\", {class: \"form-check\"})\r\n                    .append($(\"<label>\", {for: id, class: \"form-check-label\"})\r\n                        .text(formRow.label).prepend($(\"<input>\", basicMap))\r\n                    )\r\n                );\r\n            }\r\n            else {\r\n                f.append($(\"<label>\", {for: id, class: \"col-form-label\"}).text(formRow.label));\r\n\r\n                if (formRow.type === \"button\") {\r\n                    if (\"clickDismiss\" in formRow && formRow.clickDismiss === true) {\r\n                        basicMap.class += \" btn-dismiss\";\r\n                    }\r\n                    let $b = $(\"<button>\", basicMap).text(formRow.initialValue);\r\n                    if (\"onclick\" in formRow && typeof formRow.onclick === \"function\") {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"numeric\") {\r\n                    basicMap.type = \"number\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", (e) => {\r\n                        generalValidator(e, parseFloat);\r\n                    }));\r\n                }\r\n                else if (formRow.type === \"text\") {\r\n                    basicMap.type = \"text\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"file\") {\r\n                    basicMap.type = \"file\";\r\n                    basicMap.class = \"form-control-file form-control\";\r\n                    f.append($(\"<input>\", basicMap).on(\"blur validate\", generalValidator));\r\n                }\r\n                else if (formRow.type === \"textarea\") {\r\n                    let $b = $(\"<textarea>\", basicMap).on(\"blur validate\", generalValidator);\r\n                    if (\"onclick\" in formRow) {\r\n                        $b.on(\"click\", formRow.onclick);\r\n                    }\r\n                    f.append($b);\r\n                }\r\n                else if (formRow.type === \"select\") {\r\n                    let $options = $(\"<select>\", basicMap);\r\n                    formRow.optionText.forEach((oText, oIndex) => {\r\n                        if (oIndex < formRow.optionValues.length) {\r\n                            $options.append($(\"<option>\", {value: formRow.optionValues[oIndex]}).text(oText));\r\n                        }\r\n                        else {\r\n                            $options.append($(\"<option>\").text(oText));\r\n                        }\r\n                    });\r\n                    f.append($options.on(\"blur validate\", generalValidator));\r\n                }\r\n            }\r\n        });\r\n\r\n        let $footer = $(\"<div>\", {class: \"modal-footer\"})\r\n            .append($(\"<button>\", {class: \"btn btn-success\", type: \"button\"}).text(successText))\r\n            .append($(\"<button>\", {class: \"btn btn-danger btn-cancel\", type: \"button\"}).text(\"Cancel\"));\r\n\r\n        if (footer === false) {\r\n            $footer = null;\r\n        }\r\n\r\n        let $modal = ($(\"<div>\", {class: \"modal fade\", tabindex: \"-1\", role: \"dialog\", \"aria-hidden\": \"true\"}));\r\n        $modal\r\n            .append($(\"<div>\", {class: \"modal-dialog\"})\r\n                .append($(\"<div>\", {class: \"modal-content\"})\r\n                    .append($(\"<div>\", {class: \"modal-header\"})\r\n                        .append($(\"<h5>\", {class: \"modal-title\"}).text(title))\r\n                        .append($(\"<button>\", {class: \"close\", \"data-dismiss\": \"modal\", \"aria-label\": \"close\"})\r\n                            .append($(\"<span>\", {\"aria-hidden\": \"true\"}).html(\"&times;\"))\r\n                        )\r\n                    )\r\n                    .append(f)\r\n                    .append($footer)\r\n                )\r\n            );\r\n        $modal.find(\"input, textarea\").off(\"keyup\").on(\"keyup\", (e) => {\r\n            if (e.key === \"Enter\") {\r\n                $(\".btn-success\").last().click();\r\n            }\r\n        });\r\n        $modal.on(\"shown.bs.modal\", () => {\r\n            $modal.find(\"input[type='text'], input[type='number'], textarea\").first().focus();\r\n        });\r\n\r\n        return $modal;\r\n    },\r\n\r\n    showFormModal: (successCb: Function, title: string, successText: string, form: modalFormRow[], cancelCb: Function = ($modal) => {\r\n        $modal.modal(\"hide\");\r\n    }, footer = true): void => {\r\n        let $modal = self.makeFormModal(title, successText, form, footer);\r\n\r\n        $modal.on(\"click\", \".btn-cancel\", () => {\r\n            if (typeof cancelCb === \"function\") {\r\n                cancelCb($modal);\r\n            }\r\n            else {\r\n                $modal.modal(\"hide\");\r\n            }\r\n        }).on(\"click\", \".btn-dismiss\", () => {\r\n            $modal.modal(\"hide\");\r\n        }).on(\"click\", \".btn-success\", () => {\r\n            let vals = [];\r\n            let hasErrors = false;\r\n\r\n            $modal.find(\"input, textarea, select\").each((i, v) => {\r\n                let $v = $(v);\r\n\r\n                if ((<any> $v).tagName === \"SELECT\") {\r\n                    vals.push($v.find(\":selected\").val());\r\n                }\r\n                else if ($v.attr(\"type\") === \"checkbox\") {\r\n                    vals.push($v.prop(\"checked\"));\r\n                }\r\n                else if ($v.attr(\"type\") === \"file\") {\r\n                    vals.push((<any>$v.get(0)).files);\r\n                }\r\n                else if ($v.attr(\"type\") === \"number\") {\r\n                    vals.push(parseFloat(<string> $v.val()));\r\n                }\r\n                else {\r\n                    vals.push($v.val());\r\n                }\r\n\r\n                if ($v.trigger(\"validate\").hasClass(\"is-invalid\")) {\r\n                    hasErrors = true;\r\n                }\r\n\r\n            });\r\n\r\n            if (!hasErrors && typeof successCb === \"function\") {\r\n                successCb($modal, vals);\r\n            }\r\n        }).on(\"hidden.bs.modal\", () => {\r\n            $modal.remove();\r\n        }).modal(\"show\");\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport { EdgeImmutPlain } from \"./GraphImmut/EdgeImmut\";\r\nimport { NodeImmutPlain } from \"./GraphImmut/NodeImmut\";\r\n\r\nexport default {\r\n    findVertexDegreesDirectional: (adjacencyMatrix: Array<Array<number>>): Array<{in: number; out: number;}> => {\r\n        // Adjacency stores IDs of edges TO\r\n        let degrees = [];\r\n        adjacencyMatrix.forEach((v, i) => {\r\n            if (i in degrees) {\r\n                degrees[i].out += v.length;\r\n            }\r\n            else {\r\n                degrees[i] = {out: v.length, in: 0};\r\n            }\r\n            v.forEach((outV) => {\r\n                if (outV in degrees) {\r\n                    degrees[outV].in += 1;\r\n                }\r\n                else {\r\n                    degrees[outV] = {in: 1, out: 0};\r\n                }\r\n            });\r\n        });\r\n\r\n        return degrees;\r\n    },\r\n\r\n    interpolateNodesFromEdges: (edges: EdgeImmutPlain[]): Array<NodeImmutPlain> => {\r\n        let nodes = [];\r\n        edges.forEach((v) => {\r\n            nodes[v.from] = {id: v.from, label: \"\" + v.from};\r\n            nodes[v.to] = {id: v.to, label: \"\" + v.to};\r\n        });\r\n\r\n        return nodes;\r\n    },\r\n};\r\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\nimport {DataSet} from 'vis/index-network';\r\nimport help from './genericHelpers';\r\nimport GraphImmut from './GraphImmut/GraphImmut';\r\nimport {EdgeImmutPlain} from \"./GraphImmut/EdgeImmut\";\r\nimport NodeImmut, {NodeImmutPlain} from \"./GraphImmut/NodeImmut\";\r\n\r\nexport interface graphStateI {\r\n    backHistory: any[];\r\n    forwardHistory: any[];\r\n    maxHistory: number;\r\n    upToDate: ({ name: string; upToDate: boolean; type: string; applyFunc: () => void } | { name: string; upToDate: boolean; always: boolean; type: string })[];\r\n    state: { stronglyConnectedComponents: null; connectedComponents: null; graphColoring: null };\r\n    graph: GraphImmut;\r\n    graphProperties: { vertices: number; edges: number; eulerian: boolean; \"Chromatic Number\": null; \"Connected Components\": null; \"Strongly Connected Components\": null; cyclic: boolean };\r\n    setUpToDate: (value: boolean, listOptions?: string[]) => void;\r\n    getProperty: (property: string, updateIfNotUpdated?: boolean) => any;\r\n    makeAndPrintProperties: (recalcLong?: boolean) => void;\r\n    printGraphProperties: (properties: {}) => void;\r\n    addEdge: (from: number, to: number, weight?: number, graph?: GraphImmut) => void;\r\n    addNode: (data, graph?: GraphImmut) => void;\r\n    editNode: (id: number, label: string, graph?: GraphImmut) => void;\r\n    editEdge: (from: number, to: number, newWeight: number, oldWeight: number, graph?: GraphImmut) => void;\r\n    deleteEdge: (from: number, to: number, weight?: any, graph?: GraphImmut) => void;\r\n    deleteNode: (id: number, graph?: GraphImmut) => void;\r\n    clearColorFromNodes: (nodes: NodeImmutPlain[]) => NodeImmutPlain[];\r\n    nodeIDToLabel: (id: number, graph?: GraphImmut) => string;\r\n    nodeLabelToID: (label: string, graph?: GraphImmut) => number;\r\n    getGraphAsDataSet: (graph: GraphImmut) => { nodes: DataSet<any>; edges: DataSet<any> };\r\n    setLocations: (locations: any, graph?: GraphImmut) => GraphImmut;\r\n    getGraphData: (graph?: GraphImmut, clearColors?: boolean) => GraphPlain;\r\n}\r\n\r\nlet self: graphStateI = {\r\n    backHistory: [],\r\n    forwardHistory: [],\r\n    maxHistory: 10,\r\n    upToDate: [\r\n        {\r\n            name: \"Chromatic Number\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {\r\n            name: \"graphColoring\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintGraphColoring();\r\n            }\r\n        },\r\n        {name: \"vertices\", upToDate: true, always: true, type: \"property\"},\r\n        {name: \"edges\", upToDate: true, always: true, type: \"property\"},\r\n        {\r\n            name: \"eulerian\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintEulerian();\r\n            }\r\n        },\r\n        {\r\n            name: \"Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"connectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"Strongly Connected Components\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"stronglyConnectedComponents\", upToDate: false, type: \"state\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintStronglyConnectedComponents();\r\n            }\r\n        },\r\n        {\r\n            name: \"cyclic\", upToDate: false, type: \"property\",\r\n            applyFunc: () => {\r\n                window.ui.makeAndPrintIsCyclic();\r\n            }\r\n        },\r\n    ],\r\n    state: {\r\n        stronglyConnectedComponents: null,\r\n        connectedComponents: null,\r\n        graphColoring: null,\r\n    },\r\n    graph: null,\r\n    graphProperties: {\r\n        vertices: 0,\r\n        edges: 0,\r\n        eulerian: false,\r\n        \"Chromatic Number\": null,\r\n        \"Connected Components\": null,\r\n        \"Strongly Connected Components\": null,\r\n        cyclic: false,\r\n    },\r\n\r\n    setUpToDate: (value = false, listOptions) => {\r\n        let all = listOptions === null || typeof listOptions === \"undefined\";\r\n        let property = false;\r\n        self.upToDate.forEach((v) => {\r\n            if ((!(\"always\" in v) || !v.always) && (all || listOptions.indexOf(v.name) > -1)) {\r\n                v.upToDate = value;\r\n                if (v.type === \"property\") {\r\n                    property = true;\r\n                }\r\n            }\r\n        });\r\n        if (property) {\r\n            self.makeAndPrintProperties();\r\n        }\r\n    },\r\n\r\n    getProperty: (property, updateIfNotUpdated = false) => {\r\n        let a = self.upToDate.find((v) => {\r\n            return (\"name\" in v && v.name === property);\r\n        });\r\n        if (!a.upToDate) {\r\n            if (\"applyFunc\" in a && updateIfNotUpdated) {\r\n                a.applyFunc();\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        if (a.type === \"state\") {\r\n            return self.state[property];\r\n        }\r\n        return self.graphProperties[property];\r\n    },\r\n\r\n    makeAndPrintProperties: (recalcLong = false) => {\r\n        let directional = window.settings.getOption(\"direction\");\r\n\r\n        self.graphProperties.vertices = self.graph.getNumberOfNodes();\r\n        self.graphProperties.edges = self.graph.getNumberOfEdges();\r\n\r\n        if (!directional) {\r\n            self.getProperty(\"eulerian\", true);\r\n        }\r\n\r\n        let p = Object.keys(self.graphProperties);\r\n        if (recalcLong) {\r\n            p.forEach((v) => {\r\n                self.getProperty(v, true);\r\n            });\r\n        }\r\n\r\n        let printableProperties = {};\r\n        p.forEach((v) => {\r\n            printableProperties[v] = self.getProperty(v);\r\n        });\r\n        self.printGraphProperties(printableProperties);\r\n    },\r\n\r\n    printGraphProperties: (properties) => {\r\n        let p = \"\";\r\n        Object.keys(properties).forEach((k) => {\r\n            if (properties[k] !== null) {\r\n                p += help.toTitleCase(k) + \": \" + properties[k] + \"\\n\";\r\n            }\r\n        });\r\n        p = p.trim();\r\n        p = help.htmlEncode(p);\r\n        $(\"#graphProps\").html(\"<p class='nav-link'>\" + p + \"</p>\");\r\n    },\r\n\r\n    addEdge: (from, to, weight = 0, graph = self.graph) => {\r\n        graph = graph.addEdge(from, to, weight);\r\n        window.main.setData({nodes: self.clearColorFromNodes(<NodeImmutPlain[]> graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    addNode: (data, graph = self.graph) => {\r\n        graph = graph.addNode({label: data.label, x: data.x, y: data.y});\r\n        window.main.setData({nodes: self.clearColorFromNodes(<NodeImmutPlain[]> graph.getAllNodes()), edges: graph.getAllEdges()});\r\n    },\r\n\r\n    editNode: (id, label, graph = self.graph) => {\r\n        graph = graph.editNode(id, {label: label});\r\n        window.main.setData(self.getGraphData(graph), false, false);\r\n    },\r\n\r\n    editEdge: (from, to, newWeight, oldWeight, graph = self.graph) => {\r\n        let newGraph = graph.editEdge(from, to, newWeight, oldWeight);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData(self.getGraphData(newGraph), false, false);\r\n        }\r\n    },\r\n\r\n    deleteEdge: (from, to, weight = null, graph = self.graph) => {\r\n        graph = graph.deleteEdge(from, to, weight, false);\r\n        window.main.setData({\r\n            nodes: self.clearColorFromNodes(<NodeImmutPlain[]>graph.getAllNodes()),\r\n            edges: graph.getAllEdges()\r\n        });\r\n    },\r\n\r\n    deleteNode: (id, graph = self.graph) => {\r\n        let newGraph = graph.deleteNode(id);\r\n        if (newGraph instanceof GraphImmut) {\r\n            window.main.setData({\r\n                nodes: self.clearColorFromNodes(<NodeImmutPlain[]> newGraph.getAllNodes()),\r\n                edges: newGraph.getAllEdges()\r\n            });\r\n        }\r\n    },\r\n\r\n    clearColorFromNodes: (nodes: NodeImmutPlain[]) => {\r\n        nodes.forEach((v) => {\r\n            v.color = null;\r\n        });\r\n        return nodes;\r\n    },\r\n\r\n    nodeIDToLabel: (id, graph = self.graph) => {\r\n        let n = <NodeImmut | boolean> graph.getNode(id, true);\r\n        if (n !== false && n !== null && n instanceof NodeImmut && n.getLabel().trim().length > 0) {\r\n            return n.getLabel().trim();\r\n        }\r\n\r\n        return id.toString();\r\n    },\r\n\r\n    // Preferentially search by ID, label, and case-insensitive label\r\n    nodeLabelToID: (label, graph = self.graph) => {\r\n        let n: NodeImmut[] = <NodeImmut[]> graph.getAllNodes(true);\r\n        n = n.filter((node) => {\r\n            return node.getLabel().toLowerCase() === label.toLowerCase() || node.getID().toString() === label;\r\n        });\r\n\r\n        if (n.length === 0) {\r\n            return -1;\r\n        }\r\n        else if (n.length === 1) {\r\n            return n[0].getID();\r\n        }\r\n\r\n        let rID = -1;\r\n        let found = false;\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getID().toString() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel() === label) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        if (found) {\r\n            return rID;\r\n        }\r\n\r\n        n.forEach((node) => {\r\n            if (!found && node.getLabel().toLowerCase() === label.toLowerCase()) {\r\n                rID = node.getID();\r\n                found = true;\r\n            }\r\n        });\r\n\r\n        return rID;\r\n    },\r\n\r\n    // Return graph as a Vis compatible dataset\r\n    getGraphAsDataSet: (graph) => {\r\n        let d = self.getGraphData(graph);\r\n        if (graph.isWeighted()) {\r\n            d.edges.forEach((e) => {\r\n                e.label = e.weight.toString();\r\n            });\r\n        }\r\n\r\n        return {nodes: new DataSet(d.nodes), edges: new DataSet(d.edges)};\r\n    },\r\n\r\n    setLocations: (locations, graph = self.graph) => {\r\n        let newNodes = graph.getAllNodesAsImmutableList();\r\n        Object.keys(locations).forEach((i) => {\r\n            let v = locations[i];\r\n            let node = newNodes.get(parseInt(i));\r\n            // Only change when there is actually a new position\r\n            if (node.getAttribute(\"x\") !== v.x || node.getAttribute(\"y\") !== v.y) {\r\n                // Batch up all changes that we'll be making\r\n                newNodes = newNodes.set(parseInt(i), node.editNode(node.getLabel(), {x: v.x, y: v.y}));\r\n            }\r\n        });\r\n\r\n        return new GraphImmut(newNodes, graph.getAllEdgesAsImmutableList(), graph.isDirected(), graph.isWeighted());\r\n    },\r\n\r\n    getGraphData: (graph = self.graph, clearColors = false): GraphPlain => {\r\n        let nodes = <NodeImmutPlain[]> graph.getAllNodes();\r\n        return {\r\n            nodes: clearColors ? self.clearColorFromNodes(nodes) : nodes,\r\n            edges: <EdgeImmutPlain[]> graph.getAllEdges(),\r\n            directed: graph.isDirected(),\r\n            weighted: graph.isWeighted()\r\n        };\r\n    }\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nimport * as $ from 'jquery';\r\nimport help from './genericHelpers';\r\nimport randomColor from 'randomcolor';\r\nimport graphState from './graphState';\r\nimport GraphImmut from \"./GraphImmut/GraphImmut\";\r\n\r\nexport interface mainI {\r\n    graphState;\r\n    container: HTMLElement;\r\n    visWeightEdgeEdit: (data, callback) => void;\r\n    visOptions: {\r\n        interaction: { hover: boolean };\r\n        manipulation: {\r\n            addNode: (data, callback) => void;\r\n            editNode: (data, callback) => void;\r\n            addEdge: (data, callback?: any) => undefined | void;\r\n            editEdge: (data, callback) => void;\r\n            deleteEdge: (data, callback?: any) => void;\r\n            deleteNode: (data, callback) => void\r\n        }\r\n    };\r\n    cancelEdit: (callback) => void;\r\n    saveData: (data, callback, operation, label) => void;\r\n    nodeLabelIDValidator: (v) => (boolean | string);\r\n    applyColors: () => undefined | void;\r\n    setData: (data, recalcProps?: boolean, graphChanged?: boolean, rearrangeGraph?: boolean) => void;\r\n    saveState: () => undefined|void;\r\n    getStateForSaving: () => {};\r\n    undo: () => void;\r\n    redo: () => void;\r\n    applyState: (undo?: boolean, newState?: any) => void;\r\n    saveStateLocalStorage: () => void;\r\n    shuffleNetworkLayout: () => void;\r\n    randomizeNetworkLayoutSeed: (network) => void;\r\n    addNetworkListeners: (network) => void\r\n}\r\n\r\nlet self: mainI = {\r\n    graphState: graphState,\r\n    container: document.getElementById('network'),\r\n    // Function used to overwrite the edge edit functionality when weights are active\r\n    visWeightEdgeEdit: (data, callback) => {\r\n        help.showFormModal(($modal, vals) => {\r\n            callback(null);\r\n            $modal.modal(\"hide\");\r\n            vals = parseFloat(vals[0]);\r\n            self.graphState.editEdge(data.from.id, data.to.id, vals, parseFloat(data.label));\r\n        }, \"Edit Edge\", \"Save\", [\r\n            {\r\n                type: \"numeric\",\r\n                label: \"Weight/Capacity\",\r\n                initialValue: parseFloat(data.label)\r\n            }\r\n        ]);\r\n    },\r\n    visOptions: {\r\n        interaction: {hover: true},\r\n        manipulation: {\r\n            addNode: function (data, callback): void {\r\n                let $popup = help.makeFormModal(\"Add Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: \"<p>Node ID: \" + self.graphState.getProperty(\"vertices\") + \"</p>\"\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: self.graphState.getProperty(\"vertices\")}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"add\", $popup.find(\"input\").first().val());\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            editNode: function (data, callback): void {\r\n                let $popup = help.makeFormModal(\"Edit Node\", \"Save\", [\r\n                    {\r\n                        type: \"html\",\r\n                        initialValue: \"<p>Node ID: \" + data.id + \"</p>\"\r\n                    },\r\n                    {type: \"text\", label: \"Label\", initialValue: data.label}\r\n                ]);\r\n\r\n                $popup.on(\"click\", \".btn-success\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.saveData(data, callback, \"editNode\", $popup.find(\"input\").first().val());\r\n                }).on(\"click\", \".btn-cancel\", () => {\r\n                    $popup.modal(\"hide\");\r\n                    self.cancelEdit(callback);\r\n                }).on(\"hidden.bs.modal\", () => {\r\n                    $popup.remove();\r\n                    self.cancelEdit(callback);\r\n                }).modal(\"show\");\r\n            },\r\n            addEdge: function (data, callback?: any): undefined | void {\r\n                let apply = function () {\r\n                    if (typeof callback === \"function\") {\r\n                        callback(null);\r\n                    }\r\n                    self.graphState.addEdge(data.from, data.to);\r\n                };\r\n                if (data.from === data.to) {\r\n                    if (confirm(\"Do you want to connect the node to itself?\")) {\r\n                        apply();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                apply();\r\n            },\r\n            editEdge: function (data, callback) {\r\n                callback(null);\r\n                self.visOptions.manipulation.deleteEdge({edges: [data.id]});\r\n                self.visOptions.manipulation.addEdge(data);\r\n            },\r\n            deleteEdge: function (data, callback?: any) {\r\n                if (typeof callback === \"function\") {\r\n                    callback(null);\r\n                }\r\n                data.edges.forEach((v) => {\r\n                    let weight = null;\r\n                    if (typeof (<any> window.network).body.data.edges._data[v].label !== \"undefined\") {\r\n                        weight = parseFloat((<any> window.network).body.data.edges._data[v].label);\r\n                    }\r\n\r\n                    self.graphState.deleteEdge((<any> window.network).body.edges[v].fromId,\r\n                        (<any> window.network).body.edges[v].toId, weight);\r\n                });\r\n            },\r\n            deleteNode: function (data, callback) {\r\n                callback(null);\r\n                data.nodes.forEach((v) => {\r\n                    self.graphState.deleteNode(v);\r\n                });\r\n            },\r\n        },\r\n    },\r\n\r\n    cancelEdit: (callback) => {\r\n        if (typeof callback === \"function\") {\r\n            callback(null);\r\n        }\r\n    },\r\n\r\n    saveData: (data, callback, operation, label) => {\r\n        data.label = label;\r\n        callback(null);\r\n\r\n        if (operation === \"add\") {\r\n            self.graphState.addNode(data);\r\n        }\r\n        else if (operation === \"editNode\") {\r\n            self.graphState.editNode(data.id, data.label);\r\n        }\r\n    },\r\n\r\n    nodeLabelIDValidator: (v) => {\r\n        if (self.graphState.nodeLabelToID(v) > -1) {\r\n            return true;\r\n        }\r\n        return \"Invalid Label or ID\";\r\n    },\r\n\r\n    applyColors: (): void | undefined => {\r\n        if (window.settings.getOption(\"direction\")) {\r\n            return;\r\n        }\r\n        let graphColors = self.graphState.getProperty(\"graphColoring\", true);\r\n        let chromaticNumber = self.graphState.getProperty(\"Chromatic Number\", true);\r\n\r\n        let colors = randomColor({count: chromaticNumber, luminosity: \"light\"});\r\n        let G = self.graphState.graph;\r\n        G.getAllNodes().forEach((v) => {\r\n            G = G.editNode(v.id, {color: colors[graphColors[v.id]]});\r\n        });\r\n        self.setData(self.graphState.getGraphData(G), false, false);\r\n    },\r\n\r\n    setData: (data, recalcProps = false, graphChanged = true, rearrangeGraph = false) => {\r\n        // Store existing positions in the data if we're supposed to keep the layout\r\n        if (rearrangeGraph) {\r\n            data.nodes.forEach((v) => {\r\n                delete v.x;\r\n                delete v.y;\r\n            });\r\n        }\r\n\r\n        if (graphChanged) {\r\n            self.saveState();\r\n        }\r\n\r\n        if (\"directed\" in data) {\r\n            window.settings.changeOption(\"direction\", data.directed);\r\n        }\r\n        if (\"weighted\" in data) {\r\n            window.settings.changeOption(\"weights\", data.weighted);\r\n        }\r\n        let directional = window.settings.getOption(\"direction\");\r\n        let weighted = window.settings.getOption(\"weights\");\r\n\r\n        let g = new GraphImmut(data.nodes, data.edges, directional, weighted);\r\n        self.graphState.graph = g;\r\n\r\n        // Set a new random seed so that the layout will be different\r\n        self.randomizeNetworkLayoutSeed(window.network);\r\n        window.network.setData(self.graphState.getGraphAsDataSet(g));\r\n        self.graphState.graph = self.graphState.setLocations(window.network.getPositions());\r\n\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        if (graphChanged) {\r\n            window.ui.printGraphAlgorithms();\r\n            help.printout(\"\");\r\n            self.graphState.setUpToDate();\r\n            self.graphState.makeAndPrintProperties(recalcProps);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveState: ():void|undefined => {\r\n        if (self.graphState.graph === null) {\r\n            return;\r\n        }\r\n\r\n        if (self.graphState.backHistory.length >= self.graphState.maxHistory) {\r\n            self.graphState.backHistory.shift();\r\n        }\r\n\r\n        self.graphState.backHistory.push(self.getStateForSaving());\r\n        self.graphState.forwardHistory = [];\r\n        $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n    },\r\n\r\n    getStateForSaving: () => {\r\n        let state = {};\r\n        Object.keys(self.graphState).forEach((k) => {\r\n            let v = self.graphState[k];\r\n            if (typeof v !== \"function\") {\r\n                if (typeof v !== \"object\") {\r\n                    state[k] = v;\r\n                }\r\n                else {\r\n                    if (k === \"graph\" && v !== null) {\r\n                        state[k] = v;\r\n                    }\r\n                    if (!k.toLowerCase().includes(\"history\")) {\r\n                        state[k] = $.extend(true, Array.isArray(v) ? [] : {}, v);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return state;\r\n    },\r\n\r\n    undo: () => {\r\n        if (self.graphState.backHistory.length > 0) {\r\n            self.applyState(true);\r\n        }\r\n    },\r\n\r\n    redo: () => {\r\n        if (self.graphState.forwardHistory.length > 0) {\r\n            self.applyState(false);\r\n        }\r\n    },\r\n\r\n    applyState: (undo = true, newState = null) => {\r\n        let firstLoad = newState !== null;\r\n        let currentState = self.getStateForSaving();\r\n\r\n        if (!firstLoad) {\r\n            if (undo) {\r\n                newState = self.graphState.backHistory.pop();\r\n            }\r\n            else {\r\n                newState = self.graphState.forwardHistory.pop();\r\n            }\r\n        }\r\n\r\n        newState.graph = new GraphImmut(newState.graph.nodes, newState.graph.edges, newState.graph.directed, newState.graph.weighted);\r\n\r\n        window.settings.changeOption(\"direction\", newState.graph.isDirected());\r\n        window.settings.changeOption(\"weights\", newState.graph.isWeighted());\r\n\r\n        self.graphState.graph = newState.graph;\r\n\r\n        window.network.setData(self.graphState.getGraphAsDataSet(self.graphState.graph));\r\n        window.network.disableEditMode();\r\n        window.network.enableEditMode();\r\n\r\n        window.ui.printGraphAlgorithms();\r\n        help.printout(\"\");\r\n\r\n        Object.keys(newState).forEach((k) => {\r\n            let v = newState[k];\r\n            if (typeof v !== \"object\") {\r\n                self.graphState[k] = v;\r\n            }\r\n            else if (!k.toLowerCase().includes(\"history\") && k.toLowerCase() !== \"graph\") {\r\n                if (k.toLowerCase() === \"uptodate\") {\r\n                    Object.keys(self.graphState[k]).forEach((oldKey) => {\r\n                        self.graphState[k][oldKey].upToDate = v[oldKey].upToDate;\r\n                    });\r\n                }\r\n                else {\r\n                    self.graphState[k] = $.extend(true, self.graphState[k], v);\r\n                }\r\n            }\r\n        });\r\n\r\n        self.graphState.makeAndPrintProperties();\r\n        if (undo && !firstLoad) {\r\n            $(\".icon-redo\").parent().parent().addClass(\"active\");\r\n            if (self.graphState.backHistory.length === 0) {\r\n                $(\".icon-undo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            self.graphState.forwardHistory.push(currentState);\r\n        }\r\n        else if (!undo && !firstLoad) {\r\n            $(\".icon-undo\").parent().parent().addClass(\"active\");\r\n            if (self.graphState.forwardHistory.length === 0) {\r\n                $(\".icon-redo\").parent().parent().removeClass(\"active\");\r\n            }\r\n            self.graphState.backHistory.push(currentState);\r\n        }\r\n\r\n        self.saveStateLocalStorage();\r\n    },\r\n\r\n    saveStateLocalStorage: () => {\r\n        if (window.settings.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.lastState\", JSON.stringify(self.getStateForSaving()));\r\n        }\r\n    },\r\n\r\n    shuffleNetworkLayout: () => {\r\n        self.setData({\r\n            nodes: self.graphState.graph.getAllNodes(),\r\n            edges: self.graphState.graph.getAllEdges()\r\n        }, false, false, true);\r\n    },\r\n\r\n    randomizeNetworkLayoutSeed: (network) => {\r\n        let r = Math.round(Math.random() * 1000000);\r\n        network.layoutEngine.randomSeed = r;\r\n        network.layoutEngine.initialRandomSeed = r;\r\n    },\r\n\r\n    addNetworkListeners: (network) => {\r\n        // Enable edit node/edge when double clicking\r\n        network.on(\"doubleClick\", (p) => {\r\n            if (window.settings.getOption(\"weights\") && \"edges\" in p && p.edges.length === 1) {\r\n                network.editEdgeMode();\r\n            }\r\n            if (\"nodes\" in p && p.nodes.length === 1) {\r\n                network.editNode();\r\n            }\r\n        });\r\n\r\n        // Save locations of nodes after dragging\r\n        network.on(\"dragEnd\", () => {\r\n            self.graphState.graph = self.graphState.setLocations(network.getPositions());\r\n            self.saveStateLocalStorage(); // Save the new locations as part of the state\r\n        });\r\n\r\n        // Delete nodes/edges when hit \"Delete\"\r\n        let lastNetworkClickEvent = null;\r\n        network.on('click', (event) => {\r\n            lastNetworkClickEvent = event;\r\n        });\r\n\r\n        // Delete key to delete node or edge\r\n        $(document).on('keyup', (key) => {\r\n            if (key.key === \"Delete\" && lastNetworkClickEvent !== null) {\r\n                if ($(self.container).has(lastNetworkClickEvent.event.target).length > 0) {\r\n                    if ((\"edges\" in lastNetworkClickEvent && lastNetworkClickEvent.edges.length === 1)\r\n                        || (\"nodes\" in lastNetworkClickEvent && lastNetworkClickEvent.nodes.length === 1)) {\r\n                        if ($(':focus').parents(\".modal\").length === 0) {\r\n                            network.deleteSelected();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Undo/Redo keyboard commands\r\n        $(document).keydown((e) => {\r\n            if ((e.which === 89 && e.ctrlKey) || (e.which === 90 && e.ctrlKey && e.shiftKey)) {\r\n                self.redo();\r\n            }\r\n            else if (e.which === 90 && e.ctrlKey) {\r\n                self.undo();\r\n            }\r\n        });\r\n\r\n        // When clicking off of the network, remove the Delete functionality\r\n        $(document).on(\"click\", (e) => {\r\n            if ($(self.container).has(e.target).length === 0) {\r\n                lastNetworkClickEvent = null;\r\n            }\r\n        });\r\n    },\r\n\r\n};\r\n\r\nexport default self;\r\n","\"use strict\";\r\n\r\nexport interface settingsI {\r\n    defaults: { nodePhysics: boolean; direction: boolean; weights: boolean };\r\n    current: {};\r\n    checkForLocalStorage: () => (boolean);\r\n    saveSettings: () => void;\r\n    loadSettings: () => void;\r\n    setAll: () => void;\r\n    changeOption: (option, value) => void;\r\n    getOption: (option) => (any);\r\n    resetToDefault: () => void\r\n}\r\n\r\nlet self = {\r\n    defaults: {\r\n        nodePhysics: true,\r\n        direction: false,\r\n        weights: false\r\n    },\r\n    current: {},\r\n\r\n    checkForLocalStorage: () => {\r\n        try {\r\n            let x = '__storage_test__';\r\n            localStorage.setItem(x, x);\r\n            localStorage.removeItem(x);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    saveSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            localStorage.setItem(\"graphPlayground.settings\", JSON.stringify(self.current));\r\n        }\r\n    },\r\n\r\n    loadSettings: () => {\r\n        if (self.checkForLocalStorage()) {\r\n            self.current = JSON.parse(localStorage.getItem(\"graphPlayground.settings\"));\r\n        }\r\n        if (self.current === null) {\r\n            self.current = {};\r\n        }\r\n        self.setAll();\r\n    },\r\n\r\n    setAll: () => {\r\n        window.network.setOptions({nodes: {physics: self.getOption(\"nodePhysics\")}});\r\n        window.network.setOptions({edges: {arrows: {to: <boolean> self.getOption(\"direction\")}}});\r\n        if (self.getOption(\"weights\")) {\r\n            window.network.setOptions({\r\n                manipulation: {\r\n                    editEdge: {\r\n                        editWithoutDrag: window.main.visWeightEdgeEdit\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            window.network.setOptions({manipulation: {editEdge: window.main.visOptions.manipulation.editEdge}});\r\n        }\r\n    },\r\n\r\n    changeOption: (option, value) => {\r\n        self.current[option] = value;\r\n        self.saveSettings();\r\n        self.setAll();\r\n    },\r\n\r\n    getOption: (option) => {\r\n        if (option in self.current) {\r\n            return self.current[option];\r\n        }\r\n        return self.defaults[option];\r\n    },\r\n\r\n    resetToDefault: () => {\r\n        self.current = {};\r\n        self.saveSettings();\r\n        self.setAll();\r\n\r\n        // Reset graph to just a plain graph. Not sure if this should actually happen or not.\r\n        let G = window.main.graphState.graph.asChangedDirectedWeighted(self.defaults.direction, self.defaults.weights);\r\n        window.main.setData(window.main.graphState.getGraphData(G));\r\n    }\r\n};\r\n\r\nexport default self;\r\n","import gHelp from \"./graphHelpers\";\nimport help from \"./genericHelpers\";\nimport * as $ from \"jquery\";\n\n\nconst makeAndPrintShortestPath = (title, fn, weighted) => {\n    help.showFormModal(($modal, values) => {\n            $modal.modal(\"hide\");\n\n            let source = window.main.graphState.nodeLabelToID(values[0]);\n            let sink = window.main.graphState.nodeLabelToID(values[1]);\n\n            let a = fn(source, sink);\n            if (a === false) {\n                return;\n            }\n\n            let p = \"<h3>\" + title + \"</h3><hr>No path exists from \"\n                + help.htmlEncode(source) + \" to \" + help.htmlEncode(sink);\n\n            if (a.pathExists) {\n                p = title + \" From \" + window.main.graphState.nodeIDToLabel(source) + \" to \";\n                p += window.main.graphState.nodeIDToLabel(sink) + \": \" + a.distance;\n                if (weighted) {\n                    p += \"\\nWith weighted cost: \" + a.cost;\n                }\n                p += \"\\n\\nUsing Path: \";\n\n                p = help.htmlEncode(p);\n                a.path.forEach((v) => {\n                    p += help.htmlEncode(window.main.graphState.nodeIDToLabel(v)) + \" &rarr; \";\n                });\n                p = p.slice(0, -8);\n                p = \"<h3>\" + title + \"</h3><hr>\" + p;\n            }\n\n            help.printout(p);\n        },\n        title, \"Go\", [\n            {label: \"Start Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n            {label: \"End Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n        ]);\n};\n\nconst makeAndPrintComponents = async (stronglyConnected) => {\n    let a = null;\n    let cc = \"Connected Components\";\n    let componentKey = \"connectedComponents\";\n    let gg = await import(\"./GraphAlgorithms\");\n    const gAlgo = gg.default;\n\n    if (stronglyConnected) {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        cc = \"Strongly \" + cc;\n        componentKey = \"stronglyConnectedComponents\";\n        a = gAlgo.stronglyConnectedComponents();\n    }\n    else {\n        if (window.settings.getOption(\"direction\")) {\n            return;\n        }\n        a = gAlgo.connectedComponents();\n    }\n\n    window.main.graphState.graphProperties[cc] = a.count;\n    window.main.graphState.setUpToDate(true, [cc, componentKey]);\n    window.main.graphState.state[componentKey] = a.components;\n\n    let components = help.flatten(a.components);\n    let p = \"Number of \" + cc + \": \" + a.count;\n    p += \"\\n\\n\";\n\n    components.forEach((v, i) => {\n        p += \"Vertex \" + window.main.graphState.nodeIDToLabel(i) + \" is in connected component #\" + v + \"\\n\";\n    });\n\n    p += \"\\n\" + JSON.stringify(help.rotate(a.components), null, 4) + \"\\n\\n\";\n    p = \"<h3>\" + cc + \"</h3><hr>\" + help.htmlEncode(p);\n\n    help.printout(p);\n};\n\nexport interface UIInteractionsI {\n    getAlgorithms():any;\n    registerListeners():void;\n    printHelp():void;\n    printOptions():void;\n    makeAndPrintGraphColoring():Promise<void>;\n    makeAndPrintConnectedComponents():void;\n    makeAndPrintDirectionalEulerian():Promise<void>;\n    makeAndPrintEulerian():Promise<void>;\n    makeAndPrintStronglyConnectedComponents():void;\n    makeAndPrintBFS():Promise<void>;\n    makeAndPrintDijkstra():Promise<void>;\n    makeAndPrintBFSP():Promise<void>;\n    makeAndPrintFFMCMF():void;\n    makeAndPrintKruskal():Promise<void>;\n    makeAndPrintIsCyclic():Promise<void>;\n    makeAndPrintTopologicalSort():Promise<void>;\n    printGraphAlgorithms():void;\n}\n\nexport default class UIInteractions {\n    static getAlgorithms() {\n        return [\n            {\n                name: \"Graph Coloring\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintGraphColoring,\n                display: true\n            },\n            {\n                name: \"Connected Components\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintConnectedComponents,\n                display: true\n            },\n            {\n                name: \"Strongly Connected Components\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintStronglyConnectedComponents\n            },\n            {\n                name: \"Breadth-First Shortest Path\",\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintBFS,\n                display: true\n            },\n            {\n                name: \"Dijkstra Shortest Path\",\n                applyFunc: UIInteractions.makeAndPrintDijkstra,\n                display: true\n            },\n            {\n                name: \"Bellman-Ford Shortest Path\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintBFSP,\n                display: true\n            },\n            {\n                name: \"Ford-Fulkerson\",\n                weighted: true,\n                directional: true,\n                applyFunc: UIInteractions.makeAndPrintFFMCMF,\n                display: true\n            },\n            {\n                name: \"Kruskal Minimum Spanning Tree\",\n                weighted: true,\n                directional: false,\n                applyFunc: UIInteractions.makeAndPrintKruskal,\n                display: true\n            },\n            {\n                name: \"Cyclic\",\n                applyFunc: UIInteractions.makeAndPrintIsCyclic,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Topological Sort\",\n                applyFunc: UIInteractions.makeAndPrintTopologicalSort,\n                directional: true,\n                display: true\n            },\n            {\n                name: \"Eulerian\",\n                directional: false,\n                display: false,\n                applyFunc: null\n            },\n            {\n                name: \"Eulerian\",\n                directional: true,\n                display: true,\n                applyFunc: UIInteractions.makeAndPrintDirectionalEulerian\n            },\n        ];\n    }\n\n    static registerListeners(): void {\n        const makeSimpleClickListener = (selector, fn) => {\n            $(selector).on(\"click\", (e) => {\n                e.preventDefault();\n                fn();\n            });\n        };\n\n        makeSimpleClickListener(\"#print-help-link\", UIInteractions.printHelp);\n        makeSimpleClickListener(\"#graph-options-link\", UIInteractions.printOptions);\n        makeSimpleClickListener(\"#load-petersen-link\", async () => {\n            let predefined = await import('./predefinedGraphs');\n            window.main.setData(predefined.default.Petersen(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-konigsberg-link\", async () => {\n            let predefined = await import('./predefinedGraphs');\n            window.main.setData(predefined.default.Konigsberg(), false, true, true);\n        });\n        makeSimpleClickListener(\"#load-complete-link\", async () => {\n            let predefined = await import('./predefinedGraphs');\n            predefined.default.Complete();\n        });\n        makeSimpleClickListener(\"#load-hypercube-link\", async () => {\n            let predefined = await import('./predefinedGraphs');\n            predefined.default.Hypercube();\n        });\n        makeSimpleClickListener(\"#load-custom-link\", async () => {\n            let predefined = await import('./predefinedGraphs');\n            predefined.default.Custom();\n        });\n        makeSimpleClickListener(\"#undo-link\", window.main.undo);\n        makeSimpleClickListener(\"#redo-link\", window.main.redo);\n        makeSimpleClickListener(\"#calculate-all-properties-link\",\n            () => {\n                window.main.graphState.makeAndPrintProperties(true);\n            });\n        makeSimpleClickListener(\"#new-graph-layout-link\", window.main.shuffleNetworkLayout);\n        makeSimpleClickListener(\"#import-file-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeImportFileModal();\n        });\n        makeSimpleClickListener(\"#import-text-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeImportTextModal();\n        });\n        makeSimpleClickListener(\"#export-file-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeExportFileModal();\n        });\n        makeSimpleClickListener(\"#export-text-link\", async () => {\n            let imp = await import(\"./dataImportExport\");\n            imp.default.makeExportTextModal();\n        });\n    }\n\n    static printHelp(): void {\n        help.showSimpleModal(\"Help\",\n            \"<h4>For support see the <a href='https://github.com/MikeDombo/graphPlayground' \" +\n            \"target='_blank'>GitHub repository</a> for guides</h4>\" +\n            \"<h4>See <a href='https://github.com/MikeDombo/graphPlayground/issues'\" +\n            \" target='_blank'>GitHub issues</a> to submit bugs or feature requests.</h4>\");\n    }\n\n    static printOptions(): void {\n        help.showFormModal(\n            ($modal, vals) => {\n                $modal.modal(\"hide\");\n                if (window.settings.getOption(\"nodePhysics\") !== vals[0]) {\n                    window.settings.changeOption(\"nodePhysics\", vals[0]); // Physics\n                }\n                if (window.settings.getOption(\"direction\") !== vals[1]) {\n                    window.settings.changeOption(\"direction\", vals[1]);\n                    let G = window.main.graphState.graph;\n                    G = vals[1] ? G.asDirected(true) : G.asUndirected();\n                    // Clear node coloring because graph color doesn't apply to directed graphs\n                    window.main.setData(window.main.graphState.getGraphData(G, true));\n                }\n                if (window.settings.getOption(\"weights\") !== vals[2]) {\n                    window.settings.changeOption(\"weights\", vals[2]);\n                    let G = window.main.graphState.graph;\n                    G = vals[2] ? G.asWeighted() : G.asUnweighted();\n                    window.main.setData(window.main.graphState.getGraphData(G));\n                }\n            },\n            \"Options\", \"Save\", [\n                {label: \"Graph Physics\", initialValue: window.settings.getOption(\"nodePhysics\"), type: \"checkbox\"},\n                {label: \"Directed Graph\", initialValue: window.settings.getOption(\"direction\"), type: \"checkbox\"},\n                {label: \"Weighted Graph\", initialValue: window.settings.getOption(\"weights\"), type: \"checkbox\"}\n            ], null);\n    }\n\n    static async makeAndPrintGraphColoring(): Promise<void> {\n        if (window.settings.getOption(\"direction\")) {\n            return;\n        }\n\n        // Use cached responses when able\n        let a = {\n            chromaticNumber: window.main.graphState.getProperty(\"Chromatic Number\"),\n            colors: window.main.graphState.state.graphColoring\n        };\n        if (!(a.chromaticNumber !== null && window.main.graphState.getProperty(\"graphColoring\") !== null)) {\n            let gg = await import(\"./GraphAlgorithms\");\n            const gAlgo = gg.default;\n            a = gAlgo.colorNetwork();\n        }\n\n        window.main.graphState.graphProperties[\"Chromatic Number\"] = a.chromaticNumber;\n        window.main.graphState.setUpToDate(true, [\"Chromatic Number\", \"graphColoring\"]);\n        window.main.graphState.state.graphColoring = a.colors;\n\n        let colors = help.flatten(a.colors);\n        let p = \"Number of Vertices: \" + colors.length;\n        p += \"\\nChromatic Number: \" + a.chromaticNumber;\n        p += \"\\n\\n\";\n\n        colors.forEach((v, i) => {\n            p += \"Vertex \" + window.main.graphState.nodeIDToLabel(i) + \" gets color \" + v + \"\\n\";\n        });\n\n        p += \"\\n\" + JSON.stringify(help.rotate(a.colors), null, 4) + \"\\n\\n\";\n\n        p = \"<h3>Graph Coloring Using Welsh-Powell Algorithm</h3><hr>\" + help.htmlEncode(p);\n        p += \"<br/><button class='btn btn-primary' onclick='main.applyColors()'>Apply New Colors To Graph</button>\";\n\n        help.printout(p);\n        window.main.applyColors();\n    }\n\n    static makeAndPrintConnectedComponents(): void {\n        makeAndPrintComponents(false);\n    }\n\n    static async makeAndPrintDirectionalEulerian(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        let t = gAlgo.directionalEulerian(gHelp.findVertexDegreesDirectional(window.main.graphState.graph.getFullAdjacency()));\n        window.main.graphState.setUpToDate(true, [\"eulerian\"]);\n        window.main.graphState.graphProperties.eulerian = t;\n    }\n\n    static async makeAndPrintEulerian(): Promise<void> {\n        if (window.settings.getOption(\"direction\")) {\n            UIInteractions.makeAndPrintDirectionalEulerian();\n            return;\n        }\n\n        window.main.graphState.setUpToDate(true, [\"eulerian\"]);\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        window.main.graphState.graphProperties.eulerian = gAlgo.hasEulerianCircuit(window.main.graphState.graph.getAllOutDegrees());\n    }\n\n    static makeAndPrintStronglyConnectedComponents(): void {\n        makeAndPrintComponents(true);\n    }\n\n    static async makeAndPrintBFS(): Promise<void> {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Breadth-First Shortest Path\", gAlgo.breadthFirstSearch, false);\n    }\n\n    static async makeAndPrintDijkstra(): Promise<void> {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Dijkstra Shortest Path\", gAlgo.dijkstraSearch, true);\n    }\n\n    static async makeAndPrintBFSP(): Promise<void> {\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        makeAndPrintShortestPath(\"Bellman-Ford Shortest Path\", gAlgo.bellmanFord, true);\n    }\n\n    static makeAndPrintFFMCMF(): void {\n        if (!window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n        help.showFormModal(async ($modal, values) => {\n                $modal.modal(\"hide\");\n\n                let source = window.main.graphState.nodeLabelToID(values[0]);\n                let sink = window.main.graphState.nodeLabelToID(values[1]);\n                let gg = await import(\"./GraphAlgorithms\");\n                const gAlgo = gg.default;\n                let a = gAlgo.fordFulkerson(source, sink);\n\n                let p = \"<h3>Ford-Fulkerson</h3><hr>No path exists from \"\n                    + help.htmlEncode(window.main.graphState.nodeIDToLabel(source))\n                    + \" to \" + help.htmlEncode(window.main.graphState.nodeIDToLabel(sink));\n\n                if (a === false) {\n                    help.printout(p);\n                    return;\n                }\n\n                p = \"Ford-Fulkerson MaxFlow-MinCut Max Flow From \" + window.main.graphState.nodeIDToLabel(source)\n                    + \" to \" + window.main.graphState.nodeIDToLabel(sink) + \": \" + a.maxFlow;\n                p += \"\\n\\nUsing Capacities:\\n\\n\";\n                p = help.htmlEncode(p);\n                a.flowPath.forEach((v) => {\n                    p += window.main.graphState.nodeIDToLabel(v.from) + \"&rarr;\" + window.main.graphState.nodeIDToLabel(v.to)\n                        + \" using \" + v.flow + \" of \" + v.capacity + \" \\n\";\n                });\n                p = p.trim();\n                p = \"<h3>Ford-Fulkerson MaxFlow-MinCut</h3><hr>\" + p;\n\n                help.printout(p);\n            },\n            \"Ford-Fulkerson MaxFlow-MinCut\", \"Go\", [\n                {label: \"Source Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator},\n                {label: \"Sink Node\", type: \"text\", validationFunc: window.main.nodeLabelIDValidator}\n            ]);\n    }\n\n    static async makeAndPrintKruskal(): Promise<void> {\n        if (window.settings.getOption(\"direction\") || !window.settings.getOption(\"weights\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n\n        let a = gAlgo.kruskal();\n\n        let p = \"Kruskal's Minimum Spanning Tree Total Weight: \" + a.totalWeight;\n        p += \"\\n\\nUsing Edges:\\n\\n\";\n        p = help.htmlEncode(p);\n        a.mst.forEach((v) => {\n            p += window.main.graphState.nodeIDToLabel(v.from) + \"&rarr;\" + window.main.graphState.nodeIDToLabel(v.to) + \" \\n\";\n        });\n        p = p.trim();\n        p = \"<h3>Kruskal Minimum Spanning Tree</h3><hr>\" + p;\n\n        help.printout(p);\n    }\n\n    static async makeAndPrintIsCyclic(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        window.main.graphState.graphProperties.cyclic = gAlgo.isGraphCyclic();\n        window.main.graphState.setUpToDate(true, [\"cyclic\"]);\n    }\n\n    static async makeAndPrintTopologicalSort(): Promise<void> {\n        if (!window.settings.getOption(\"direction\")) {\n            return;\n        }\n        let gg = await import(\"./GraphAlgorithms\");\n        const gAlgo = gg.default;\n        let a = gAlgo.topologicalSort();\n\n        if (a === true) {\n            window.main.graphState.graphProperties.cyclic = true;\n            window.main.graphState.setUpToDate(true, [\"cyclic\"]);\n\n            let p = \"Topological sorting failed because the graph contains a cycle\";\n            p = \"<h3>Topological Sorting Failed</h3><hr>\" + p;\n            help.printout(p);\n\n            return;\n        }\n\n        let p = \"Topological Sorting:\\n\\n\";\n        p = help.htmlEncode(p);\n        a.forEach((v) => {\n            p += window.main.graphState.nodeIDToLabel(v.id) + \", \";\n        });\n        p = p.slice(0, -2);\n        p = \"<h3>Topological Sorting</h3><hr>\" + p;\n\n        help.printout(p);\n    }\n\n    static printGraphAlgorithms(): void {\n        let $div = $(\"#algorithms-pane\");\n        $div.empty();\n        let directional = window.settings.getOption(\"direction\");\n        let weighted = window.settings.getOption(\"weights\");\n\n        const addAlgoToPane = (alg) => {\n            $div.append($(\"<a>\", {class: \"nav-link\", href: \"#\"})\n                .text(alg.name).on(\"click\", (e) => {\n                    e.preventDefault();\n                    alg.applyFunc();\n                }));\n        };\n\n        let a = UIInteractions.getAlgorithms();\n        a.forEach((alg) => {\n            if (!alg.display) {\n                return;\n            }\n            if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n            else if ((\"weighted\" in alg && alg.weighted === weighted) || !(\"weighted\" in alg)) {\n                if ((\"directional\" in alg && alg.directional === directional) || !(\"directional\" in alg)) {\n                    addAlgoToPane(alg);\n                }\n            }\n        });\n    }\n}\n","\"use strict\";\r\n\r\nimport 'bootstrap';\r\nimport * as Raven from 'raven-js';\r\nimport { Network } from 'vis/index-network';\r\nimport { default as main, mainI } from './main';\r\nimport { default as settings, settingsI } from './settings';\r\nimport { default as UI, UIInteractionsI }from './UIInteractions';\r\n\r\ndeclare global {\r\n    interface Window {\r\n        main: mainI;\r\n        network: Network;\r\n        settings: settingsI;\r\n        ui: UIInteractionsI,\r\n        Raven: Raven.RavenStatic\r\n    }\r\n}\r\n\r\nwindow.main = main;\r\nwindow.network = new Network(main.container, {}, main.visOptions);\r\nwindow.settings = settings;\r\nwindow.ui = UI;\r\n\r\n// Initialize Sentry.io error logging\r\nRaven.config('https://92aaeee7e2fb4ef4837a2261a029e8ed@sentry.home.mikedombrowski.com/2').install();\r\nwindow.Raven = Raven;\r\n\r\nmain.addNetworkListeners(window.network);\r\n\r\nsettings.loadSettings();\r\n\r\nlet loadDefault = true;\r\nif (settings.checkForLocalStorage()) {\r\n    let s:any = localStorage.getItem(\"graphPlayground.lastState\");\r\n    if (s !== null) {\r\n        s = JSON.parse(s);\r\n        if (\"graph\" in s && \"nodes\" in s.graph) {\r\n            loadDefault = false;\r\n            main.applyState(false, s);\r\n        }\r\n    }\r\n}\r\nif (loadDefault) {\r\n    (async () => {\r\n        let predefined = await import(\"./predefinedGraphs\");\r\n        main.setData(predefined.default.Petersen(), false, true, true);\r\n    })();\r\n}\r\n\r\nwindow.ui.registerListeners();\r\n","\"use strict\";\n\nexport interface NodeImmutPlain {\n    id: Readonly<number>;\n    label: string;\n\n    [key: string]: any;\n\n    [key: number]: any\n}\n\nexport default class NodeImmut {\n    private readonly id: Readonly<number>;\n    private readonly label: Readonly<string>;\n    private readonly attributes: any;\n\n    constructor(id: any, label: any = null, extraAttrs: null | any = null) {\n        if (label === null) {\n            this.label = id.toString();\n        }\n        else {\n            this.label = label;\n        }\n\n        this.attributes = {};\n        if (extraAttrs !== null && typeof extraAttrs === \"object\") {\n            Object.keys(extraAttrs).forEach((key) => {\n                this.attributes[key] = Object.freeze(extraAttrs[key]);\n            });\n        }\n\n        this.attributes = Object.freeze(this.attributes);\n        this.label = Object.freeze(this.label);\n        this.id = Object.freeze(id);\n\n        if (new.target === NodeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    toPlain(): NodeImmutPlain {\n        let toReturn: NodeImmutPlain = {id: this.id, label: this.label};\n        Object.keys(this.attributes).forEach((key) => {\n            if (!(key in toReturn)) {\n                toReturn[key] = this.attributes[key];\n            }\n        });\n\n        return toReturn;\n    }\n\n    getID(): Readonly<number> {\n        return this.id;\n    }\n\n    getLabel(): Readonly<string> {\n        return this.label;\n    }\n\n    getAttribute(attribute: string | number): any {\n        if (attribute in this.attributes) {\n            return this.attributes[attribute];\n        }\n\n        return null;\n    }\n\n    getAllAttributes(): { [key: string]: any; [key: number]: any } {\n        return this.attributes;\n    }\n\n    editNode(label: any = null, extraAttrs: any = null): NodeImmut {\n        if (label === null) {\n            label = this.getLabel();\n        }\n\n        // Merge existing and new attributes favoring the new\n        let attributes = Object.assign({}, this.attributes);\n        Object.keys(extraAttrs).forEach((key) => {\n            attributes[key] = extraAttrs[key];\n        });\n\n        return new NodeImmut(this.getID(), label, attributes);\n    }\n}\n","\"use strict\";\n\nexport interface EdgeImmutPlain {\n    label?: string;\n    from: number;\n    to: number;\n    weight: number\n}\n\nexport default class EdgeImmut {\n    private readonly from: Readonly<number>;\n    private readonly to: Readonly<number>;\n    private readonly weight: Readonly<number>;\n\n    constructor(from: number, to: number, weight: any = 1) {\n        this.from = Object.freeze(from);\n        this.to = Object.freeze(to);\n        this.weight = Object.freeze(parseFloat(weight));\n\n        if (new.target === EdgeImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    getFrom(): Readonly<number> {\n        return this.from;\n    }\n\n    getTo(): Readonly<number> {\n        return this.to;\n    }\n\n    getWeight(): Readonly<number> {\n        return this.weight;\n    }\n\n    toPlain(): { from: Readonly<number>; to: Readonly<number>; weight: Readonly<number> } {\n        return {from: this.from, to: this.to, weight: this.weight};\n    }\n\n    editEdge(newWeight: number): EdgeImmut {\n        return new EdgeImmut(this.getFrom(), this.getTo(), newWeight);\n    }\n}\n","\"use strict\";\n\nimport { List } from 'immutable';\nimport { default as NodeImmut, NodeImmutPlain} from './NodeImmut';\nimport { default as EdgeImmut, EdgeImmutPlain } from './EdgeImmut';\n\ninterface NodeMapping {\n    [key: number]: number\n}\n\nconst filterNodeExtraAttr = (data: any) => {\n    return Object.keys(data)\n        .filter((key) => !([\"label\", \"id\"]).includes(key))\n        .reduce((obj: any, key) => {\n            obj[key] = data[key];\n            return obj;\n        }, {});\n};\n\nconst genericEdgesToImmutEdges = (edges: any, nodeMap: NodeMapping = {}): boolean | List<EdgeImmut> => {\n    if (edges === null) {\n        return false;\n    }\n\n    let newEdges: List<EdgeImmut> = List();\n\n    if (typeof edges === 'object') {\n        edges.forEach((edge: any) => {\n            let weight = 0;\n            let from = 0;\n            let to = 0;\n\n            if (\"weight\" in edge) {\n                weight = parseFloat(edge.weight);\n            }\n            if (\"from\" in edge) {\n                from = nodeMap[edge.from];\n            }\n            if (\"to\" in edge) {\n                to = nodeMap[edge.to];\n            }\n\n            newEdges = newEdges.push(new EdgeImmut(from, to, weight));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return newEdges;\n};\n\nconst genericNodesToImmutNodes = (nodes: any): boolean | { nodes: Readonly<List<NodeImmut>>; map: { [key: number]: number } } => {\n    if (nodes === null) {\n        return false;\n    }\n\n    let newNodes: List<NodeImmut> = List();\n    let nodeMap: NodeMapping = {};\n\n    if (typeof nodes === \"number\") {\n        // Create the nodes\n        for (let i = 0; i < Math.floor(nodes); i++) {\n            newNodes = newNodes.set(i, new NodeImmut(i));\n            nodeMap[i] = i;\n        }\n    }\n    else if (typeof nodes === 'object') {\n        let nodeNum = 0;\n        nodes.forEach((n: any) => {\n            let id = nodeNum++;\n            let label = null;\n            let extraAttrs = null;\n\n            if (\"label\" in n) {\n                label = n.label;\n            }\n            if (\"id\" in n) {\n                nodeMap[n.id] = id;\n                if (\"label\" in n && n.label === n.id.toString()) {\n                    label = id.toString();\n                }\n            }\n            else {\n                nodeMap[id] = id;\n            }\n            if (\"attributes\" in n) {\n                extraAttrs = filterNodeExtraAttr(n.attributes);\n            }\n            else {\n                extraAttrs = filterNodeExtraAttr(n);\n            }\n\n            newNodes = newNodes.set(id, new NodeImmut(id, label, extraAttrs));\n        });\n    }\n    else {\n        return false;\n    }\n\n    return {nodes: Object.freeze(newNodes), map: nodeMap};\n};\n\nexport default class GraphImmut {\n    private readonly directed: Readonly<boolean>;\n    private readonly weighted: Readonly<boolean>;\n    private readonly nodes: Readonly<List<NodeImmut>>;\n    private readonly numNodes: Readonly<number>;\n    private readonly edges: Readonly<List<EdgeImmut>>;\n    private readonly numEdges: Readonly<number>;\n\n    constructor(nodes: number | List<NodeImmut>, edges: null | List<EdgeImmut> | EdgeImmutPlain[] = null, directed = false, weighted = false) {\n        this.directed = Object.freeze(directed);\n        this.weighted = Object.freeze(weighted);\n        let nodeMap = {};\n\n        // Make Nodes\n        if (typeof nodes === \"number\" || (typeof nodes === \"object\" && !(nodes instanceof List))) {\n            let n = genericNodesToImmutNodes(nodes);\n            if (typeof n !== \"object\") {\n                throw new Error(\"Unable to parse node input!\");\n            }\n            this.nodes = n.nodes;\n            nodeMap = n.map;\n        }\n        else if (nodes instanceof List) {\n            this.nodes = nodes;\n        }\n        else {\n            throw new Error(\"Illegal type of 'node' input to GraphImmut constructor\");\n        }\n        this.nodes = Object.freeze(this.nodes);\n        this.numNodes = Object.freeze(this.nodes.size);\n\n        // If we are given edges, add them to the graph\n        if (edges !== null && typeof edges === \"object\" && !(edges instanceof List)) {\n            let e = genericEdgesToImmutEdges(edges, nodeMap);\n            if (typeof e !== \"object\") {\n                throw new Error(\"Unable to parse Edge input\");\n            }\n            this.edges = e;\n        }\n        else if (edges instanceof List) {\n            this.edges = <List<EdgeImmut>> edges;\n        }\n        else {\n            this.edges = List();\n        }\n        this.edges = Object.freeze(this.edges);\n        this.numEdges = Object.freeze(this.edges.size);\n\n        if (new.target === GraphImmut) {\n            Object.freeze(this);\n        }\n    }\n\n    alignNodeIDs(alignTo = 0): GraphImmut {\n        let nodeMap: NodeMapping = {};\n        let nodeCount = alignTo;\n        let newNodes: List<NodeImmut> = List();\n        this.nodes.forEach((v) => {\n            let label = v.getLabel();\n            if (v.getLabel() === v.getID().toString()) {\n                label = nodeCount.toString();\n            }\n\n            newNodes = newNodes.set(nodeCount, new NodeImmut(nodeCount, label, v.getAllAttributes()));\n            nodeMap[v.getID()] = nodeCount++;\n        });\n\n        let newEdges: List<EdgeImmut> = List();\n        this.edges.forEach((v) => {\n            newEdges = newEdges.push(new EdgeImmut(nodeMap[v.getFrom()], nodeMap[v.getTo()], v.getWeight()));\n        });\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    getNode(id: number, rich = false):NodeImmut|NodeImmutPlain|boolean {\n        if(id >= this.numNodes){\n            return false;\n        }\n        if (rich) {\n            return this.nodes.get(id);\n        }\n        return this.nodes.get(id).toPlain();\n    }\n\n    addNode(data: any = null): GraphImmut {\n        if (data === null) {\n            data = {};\n        }\n\n        let id = this.numNodes;\n        if (!(\"label\" in data)) {\n            data.label = id.toString();\n        }\n\n        let extraAttrs = filterNodeExtraAttr(data);\n\n        return new GraphImmut(this.nodes.set(id, new NodeImmut(id, data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    editNode(id: number, data: any): any {\n        if (!this.nodes.has(id)) {\n            return false;\n        }\n\n        let extraAttrs = filterNodeExtraAttr(data);\n        if (!(\"label\" in data)) {\n            data.label = (<NodeImmut>this.getNode(id, true)).getLabel();\n        }\n        return new GraphImmut(this.nodes.set(id, (<NodeImmut>this.getNode(id, true)).editNode(data.label, extraAttrs)),\n            this.edges, this.directed, this.weighted);\n    }\n\n    deleteNode(id: number): GraphImmut | boolean {\n        // Make sure the ID exists\n        if (!(id >= 0 && id < this.numNodes)) {\n            return false;\n        }\n\n        let nodeMap: NodeMapping = {}; // Map for old IDs to new ones since we're deleting an entry\n\n        // Remove it from the node list\n        let nodeCount = 0;\n        let newNodes: List<NodeImmut> = <List<NodeImmut>> this.nodes\n            .filter((n) => {\n                if (n.getID() === id) {\n                    nodeMap[n.getID()] = -1;\n                }\n                else {\n                    nodeMap[n.getID()] = nodeCount++;\n                }\n\n                return n.getID() !== id;\n            })\n            .map((node) => {\n                let label = node.getLabel();\n                if (node.getID().toString() === label) {\n                    label = nodeMap[node.getID()].toString();\n                }\n\n                return new NodeImmut(nodeMap[node.getID()], label, node.getAllAttributes());\n            });\n\n        // Remap edges\n        let newEdges: Immutable.List<EdgeImmut> = <List<EdgeImmut>> this.edges\n            .filter((edge) => {\n                return !(edge.getFrom() === id || edge.getTo() === id);\n            })\n            .map((edge) => {\n                return new EdgeImmut(nodeMap[edge.getFrom()], nodeMap[edge.getTo()], edge.getWeight());\n            });\n\n        return new GraphImmut(newNodes, newEdges, this.directed, this.weighted);\n    }\n\n    addEdge(from: number, to: number, weight: any = 1): GraphImmut {\n        if (!this.weighted) {\n            weight = 1; // Ensure that edge weights are 1 if this is an unweighted graph\n        }\n\n        let newEdges = this.edges.push(new EdgeImmut(from, to, parseFloat(weight)));\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    deleteEdge(from: number, to: number, weight: any = null, deleteAll: boolean = true): GraphImmut {\n        if (weight !== null) {\n            weight = parseFloat(weight);\n        }\n\n        let foundOneEdge = false;\n        let newEdges: List<EdgeImmut> = <List<EdgeImmut>> this.edges.filter((edge) => {\n            // If we're not deleting everything and we have found one edge, then do not filter anymore\n            if (foundOneEdge && !deleteAll) {\n                return true;\n            }\n\n            // If we have an exact match\n            if (edge.getFrom() === from && edge.getTo() === to && (weight === null || edge.getWeight() === weight)) {\n                foundOneEdge = true;\n                return false; // Remove this edge\n            }\n\n            // If we are undirected, check for opposing matches\n            if (!this.directed) {\n                if (edge.getFrom() === to && edge.getTo() === from && (weight === null || edge.getWeight() === weight)) {\n                    foundOneEdge = true;\n                    return false; // Remove this edge\n                }\n            }\n\n            return true;\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    editEdge(from: number, to: number, newWeight: any, oldWeight: any = null): GraphImmut | boolean {\n        // Editing only makes sense for weighted graphs.\n        // To change from/to, just delete the edge and add a new one\n        if (!this.weighted) {\n            return false;\n        }\n\n        let foundFirst = false;\n\n        if (oldWeight !== null) {\n            oldWeight = parseFloat(oldWeight);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge, index) => {\n            if (foundFirst) {\n                return;\n            }\n            if (edge.getFrom() === from && edge.getTo() === to && (oldWeight === null || edge.getWeight() === oldWeight)) {\n                newEdges = newEdges.set(index, edge.editEdge(parseFloat(newWeight)));\n                foundFirst = true;\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    getAllNodes(rich = false): NodeImmut[] | NodeImmutPlain[] {\n        if (rich) {\n            return this.nodes.toArray();\n        }\n        return this.nodes.map((node) => {\n            return node.toPlain();\n        }).toArray();\n    }\n\n    getAllNodesAsImmutableList(): List<NodeImmut> {\n        return this.nodes;\n    }\n\n    getAllEdgesAsImmutableList(): List<EdgeImmut> {\n        return this.edges;\n    }\n\n    getAllEdges(rich = false): EdgeImmut[] | EdgeImmutPlain[] {\n        if (rich) {\n            return this.edges.toArray();\n        }\n        return this.edges.map((edge) => {\n            return edge.toPlain();\n        }).toArray();\n    }\n\n    getNumberOfNodes(): number {\n        return this.numNodes;\n    }\n\n    getNumberOfEdges(): number {\n        return this.numEdges;\n    }\n\n    getAllOutDegrees(): number[] {\n        let degrees: number[] = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() in degrees) {\n                degrees[edge.getFrom()]++;\n            }\n            else {\n                degrees[edge.getFrom()] = 1;\n            }\n        });\n\n        return degrees;\n    }\n\n    asWeighted(): GraphImmut {\n        return new GraphImmut(this.nodes, <List<EdgeImmut>> this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }), this.directed, true);\n    }\n\n    asUnweighted(): GraphImmut {\n        return new GraphImmut(this.nodes, <List<EdgeImmut>> this.edges.map((edge) => {\n            return edge.editEdge(1);\n        }), this.directed, false);\n    }\n\n    asDirected(doubleEdges = false): GraphImmut {\n        if (!doubleEdges) {\n            return new GraphImmut(this.nodes, this.edges, true, this.weighted);\n        }\n\n        let newEdges = this.edges;\n        this.edges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.getTo(), edge.getFrom(), edge.getWeight()));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, true, this.weighted);\n    }\n\n    asUndirected(): GraphImmut {\n        let newEdges: List<EdgeImmut> = List();\n        let addedEdges: { [key: string]: null } = {};\n\n        this.edges.forEach((edge) => {\n            let from = edge.getFrom();\n            let to = edge.getTo();\n            if (to > from) {\n                from = to;\n                to = edge.getFrom();\n            }\n            if (!(from + \"_\" + to in addedEdges)) {\n                addedEdges[from + \"_\" + to] = null;\n                newEdges = newEdges.push(new EdgeImmut(from, to, edge.getWeight()));\n            }\n        });\n\n        return new GraphImmut(this.nodes, newEdges, false, this.weighted);\n    }\n\n    asChangedDirectedWeighted(directed: boolean, weighted: boolean): GraphImmut {\n        let G: GraphImmut = this;\n        if (directed && !this.directed) {\n            G = this.asDirected();\n        }\n        else if (!directed && this.directed) {\n            G = this.asUndirected();\n        }\n\n        if (weighted && !this.weighted) {\n            G = this.asWeighted();\n        }\n        else if (!weighted && this.weighted) {\n            G = this.asUnweighted();\n        }\n\n        return G;\n    }\n\n    getNodeAdjacency(id: number): number[] {\n        let adj: number[] = [];\n        this.edges.forEach((edge) => {\n            if (edge.getFrom() === id) {\n                adj.push(edge.getTo());\n            }\n            else if (!this.directed && edge.getTo() === id) {\n                adj.push(edge.getFrom());\n            }\n        });\n\n        return adj;\n    }\n\n    getFullAdjacency(): number[][] {\n        let adj: number[][] = [];\n        this.nodes.forEach((n) => {\n            adj[n.getID()] = this.getNodeAdjacency(n.getID());\n        });\n\n        return adj;\n    }\n\n    areAdjacent(id1: number, id2: number): boolean {\n        return this.getNodeAdjacency(id1).includes(id2);\n    }\n\n    getEdgesBetween(id1: number, id2: number): EdgeImmut[] {\n        let edgeList: EdgeImmut[] = [];\n        this.edges.forEach((edge) => {\n            if (!this.directed && edge.getFrom() === id2 && edge.getTo() === id1) {\n                edgeList.push(edge);\n            }\n\n            if (edge.getFrom() === id1 && edge.getTo() === id2) {\n                edgeList.push(edge);\n            }\n        });\n\n        return edgeList;\n    }\n\n    getMinWeightEdgeBetween(id1: number, id2: number): number {\n        let minWeight = Infinity;\n        this.getEdgesBetween(id1, id2).forEach((edge) => {\n            if (edge.getWeight() < minWeight) {\n                minWeight = edge.getWeight();\n            }\n        });\n\n        return minWeight;\n    }\n\n    // Take a multigraph and reduce all multiple edges to a single edge, weighted using the reducer\n    reduceMultiGraph(reducer: Function, initialValue: any): GraphImmut {\n        if (typeof initialValue === \"undefined\") {\n            initialValue = 0;\n        }\n\n        let multiEdges: EdgeImmutPlain[] = [];\n        this.nodes.forEach((node) => {\n            // If we have duplicates\n            let adj = this.getNodeAdjacency(node.getID());\n            let uniques = new Set(adj);\n            if (uniques.size < adj.length) {\n                uniques.forEach((to) => {\n                    let newWeight = this.getEdgesBetween(node.getID(), to).reduce((acc, edge) => {\n                        return reducer(acc, edge.getWeight());\n                    }, initialValue);\n\n                    multiEdges.push({from: node.getID(), to: to, weight: parseFloat(newWeight)});\n                });\n            }\n        });\n\n        // Remove all multigraph edges and replace them with single new edges\n        let newEdges = <List<EdgeImmut>> this.edges.filter((edge) => {\n            let keep = true;\n            multiEdges.forEach((duplicateEdge) => {\n                if (edge.getFrom() === duplicateEdge.from && edge.getTo() === duplicateEdge.to) {\n                    keep = false;\n                }\n            });\n\n            return keep;\n        });\n        multiEdges.forEach((edge) => {\n            newEdges = newEdges.push(new EdgeImmut(edge.from, edge.to, edge.weight));\n        });\n\n        return new GraphImmut(this.nodes, newEdges, this.directed, this.weighted);\n    }\n\n    isWeighted() {\n        return this.weighted;\n    }\n\n    isDirected() {\n        return this.directed;\n    }\n}\n"],"sourceRoot":""}