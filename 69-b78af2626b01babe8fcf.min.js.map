{"version":3,"file":"69-b78af2626b01babe8fcf.min.js","mappings":"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","sources":["webpack://graphPlayground/./src/js/GraphAlgorithms.ts","webpack://graphPlayground/./src/js/classes/SpanningTree.ts","webpack://graphPlayground/./src/js/workers/GraphAlgorithmWorker.ts"],"sourcesContent":["\"use strict\";\r\n\r\nimport genericH from \"./util/genericHelpers\";\r\nimport graphH from \"./util/graphHelpers\";\r\nimport SpanningTree from \"./classes/SpanningTree\";\r\nimport EdgeImmut, { EdgeImmutPlain } from \"./classes/GraphImmut/EdgeImmut\";\r\nimport NodeImmut from \"./classes/GraphImmut/NodeImmut\";\r\nimport GraphImmut from \"./classes/GraphImmut/GraphImmut\";\r\nimport GraphState from \"./graphState\";\r\nimport { GraphPlain } from \"./util/predefinedGraphs\";\r\n\r\ntype EdgeFlowProp = { from: number; to: number; capacity: number; flow: number };\r\nexport type MSTResult = { mst: EdgeImmutPlain[]; totalWeight: number };\r\nexport type FlowResult = { maxFlow: number; flowPath: EdgeFlowProp[] };\r\nexport type ShortestPathResult = {\r\n    pathExists: boolean;\r\n    path: number[];\r\n    distance: number;\r\n    cost?: number;\r\n    weight?: number;\r\n};\r\nexport type ConnectedComponentResult = { components: { [key: number]: number }; count: number };\r\n\r\nexport default class GraphAlgorithms {\r\n    public static graphPlainToGraphImmut = (gp: GraphPlain): GraphImmut => {\r\n        return new GraphImmut(gp.nodes, gp.edges, gp.directed, gp.weighted);\r\n    };\r\n\r\n    // Welsh-Powell Algorithm\r\n    public static colorNetwork = (G: GraphImmut = GraphState.graph): { colors: {}; chromaticNumber: number } => {\r\n        // Get node ID's only\r\n        const nodeArr: number[] = genericH.datasetToArray(G.getAllNodes(), \"id\") as number[];\r\n\r\n        // Put vertices in array in decreasing order of degree\r\n        const degrees = G.getAllOutDegrees();\r\n        const vertexOrder = genericH.sort(nodeArr, (a, b) => {\r\n            return degrees[a] < degrees[b] ? 1 : degrees[a] === degrees[b] ? 0 : -1;\r\n        });\r\n\r\n        const colorIndex: { [key: number]: number } = {};\r\n        let currentColor = 0;\r\n        while (vertexOrder.length > 0) {\r\n            const root = vertexOrder.shift()!;\r\n            colorIndex[root] = currentColor;\r\n\r\n            const myGroup = [];\r\n            myGroup.push(root);\r\n\r\n            for (let i = 0; i < vertexOrder.length; ) {\r\n                const p = vertexOrder[i];\r\n                let conflict = false;\r\n\r\n                for (let j = 0; j < myGroup.length; j++) {\r\n                    if (G.areAdjacent(p, myGroup[j])) {\r\n                        i++;\r\n                        conflict = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (conflict) {\r\n                    continue;\r\n                }\r\n\r\n                colorIndex[p] = currentColor;\r\n                myGroup.push(p);\r\n                vertexOrder.splice(i, 1);\r\n            }\r\n\r\n            currentColor++;\r\n        }\r\n\r\n        const chromaticNumber = genericH.max(genericH.flatten(colorIndex) as any[]) + 1;\r\n        return { colors: colorIndex, chromaticNumber };\r\n    };\r\n\r\n    public static connectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\r\n        const components: { [key: number]: number } = {};\r\n        let componentCount = 0;\r\n        const setComponentNum = (v: number) => {\r\n            components[v] = componentCount;\r\n        };\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in components)) {\r\n                const visited = GraphAlgorithms.depthFirstSearch(i, G);\r\n                visited.forEach(setComponentNum);\r\n                componentCount++;\r\n            }\r\n        }\r\n\r\n        return { components, count: componentCount };\r\n    };\r\n\r\n    public static depthFirstSearch = (start: number, G = GraphState.graph): number[] => {\r\n        const visisted: number[] = [];\r\n        const Stack: number[] = [];\r\n        Stack.push(start);\r\n        while (Stack.length > 0) {\r\n            const v = Stack.pop()!;\r\n            if (!visisted.includes(v)) {\r\n                visisted.push(v);\r\n                G.getNodeAdjacency(v).forEach(nodeID => {\r\n                    Stack.push(nodeID);\r\n                });\r\n            }\r\n        }\r\n\r\n        return visisted;\r\n    };\r\n\r\n    // Tarjan's algorithm\r\n    public static stronglyConnectedComponents = (G: GraphImmut = GraphState.graph): ConnectedComponentResult => {\r\n        let index = 0;\r\n        const indices: { [key: number]: number } = {};\r\n        const lowlink: { [key: number]: number } = {};\r\n        const S: number[] = [];\r\n        const components: { [key: number]: number } = {};\r\n        let componentCount = 0;\r\n\r\n        const strongConnect = (v: number) => {\r\n            indices[v] = index;\r\n            lowlink[v] = index++;\r\n            S.push(v);\r\n\r\n            G.getNodeAdjacency(v).forEach(w => {\r\n                if (!(w in indices)) {\r\n                    strongConnect(w);\r\n                    lowlink[v] = Math.min(lowlink[v], lowlink[w]);\r\n                } else if (S.includes(w)) {\r\n                    lowlink[v] = Math.min(lowlink[v], indices[w]);\r\n                }\r\n            });\r\n\r\n            if (lowlink[v] === indices[v]) {\r\n                let w = -1;\r\n                if (S.length > 0) {\r\n                    do {\r\n                        w = S.pop()!;\r\n                        components[w] = componentCount;\r\n                    } while (w !== v);\r\n                    componentCount++;\r\n                }\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < G.getNumberOfNodes(); i++) {\r\n            if (!(i in indices)) {\r\n                strongConnect(i);\r\n            }\r\n        }\r\n\r\n        return { components, count: componentCount };\r\n    };\r\n\r\n    public static breadthFirstSearch = (\r\n        startNodeID: number,\r\n        targetNodeID: number,\r\n        G: GraphImmut = GraphState.graph\r\n    ): ShortestPathResult => {\r\n        // Perform the BFS\r\n        const visisted: number[] = [];\r\n        const Q: number[] = []; // Use Push and Shift for Queue operations\r\n        const edgeTo: { [key: number]: number } = {};\r\n\r\n        Q.push(startNodeID);\r\n        while (Q.length > 0) {\r\n            const x = Q.shift()!;\r\n            if (!visisted.includes(x)) {\r\n                visisted.push(x);\r\n                G.getNodeAdjacency(x).forEach(y => {\r\n                    if (!visisted.includes(y)) {\r\n                        edgeTo[y] = x;\r\n                        Q.push(y);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visisted.includes(targetNodeID)) {\r\n            // Build the path\r\n            const path = [];\r\n            for (let x = targetNodeID; x !== startNodeID; x = edgeTo[x]) {\r\n                path.push(x);\r\n            }\r\n            path.push(startNodeID);\r\n            path.reverse();\r\n\r\n            // Get the path weight\r\n            let weight = 0;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                weight += G.getMinWeightEdgeBetween(path[i], path[i + 1]);\r\n            }\r\n\r\n            return { pathExists: true, path, distance: path.length, weight };\r\n        }\r\n\r\n        return { pathExists: false, path: [], distance: -1, weight: -1 };\r\n    };\r\n\r\n    public static dijkstraSearch = (\r\n        startNodeID: number,\r\n        targetNodeID: number,\r\n        G: GraphImmut = GraphState.graph\r\n    ): ShortestPathResult | boolean => {\r\n        if (!G.isDirected()) {\r\n            G = G.asDirected(true);\r\n        }\r\n        if (!G.isWeighted()) {\r\n            G = G.asWeighted();\r\n        }\r\n\r\n        const nonNegative = (G.getAllEdges(true) as EdgeImmut[]).find(edge => {\r\n            return edge.getWeight() < 0;\r\n        });\r\n        if (typeof nonNegative !== \"undefined\") {\r\n            return false;\r\n        }\r\n\r\n        // Priority Queue implementation for Dijkstra\r\n        class PriorityQueue {\r\n            private readonly _nodes: { key: number | string; priority: number }[] = [];\r\n\r\n            enqueue(priority: number, key: number): void {\r\n                this._nodes.push({ key, priority });\r\n                this.sort();\r\n            }\r\n\r\n            dequeue(): number | string {\r\n                return this._nodes.shift()!.key;\r\n            }\r\n\r\n            sort(): void {\r\n                this._nodes.sort((a: { priority: number }, b: { priority: number }) => {\r\n                    return a.priority - b.priority;\r\n                });\r\n            }\r\n\r\n            isEmpty(): boolean {\r\n                return !this._nodes.length;\r\n            }\r\n        }\r\n\r\n        const queue = new PriorityQueue();\r\n        const distances: { [key: number]: number } = {};\r\n        const previous: { [key: number]: number | null } = {};\r\n        let path = [];\r\n\r\n        // Initialize Queue and distances\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\r\n            let dist = Infinity;\r\n            if (node.getID() === startNodeID) {\r\n                dist = 0;\r\n            }\r\n\r\n            distances[node.getID()] = dist;\r\n            queue.enqueue(dist, node.getID());\r\n            previous[node.getID()] = null;\r\n        });\r\n\r\n        while (!queue.isEmpty()) {\r\n            let smallest = queue.dequeue() as number;\r\n\r\n            if (smallest === targetNodeID) {\r\n                path = [];\r\n                while (previous[smallest] !== null) {\r\n                    path.push(smallest);\r\n                    smallest = previous[smallest]!;\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (distances[smallest] === Infinity) {\r\n                continue;\r\n            }\r\n\r\n            G.getNodeAdjacency(smallest).forEach(neighbor => {\r\n                const alt = distances[smallest] + G.getMinWeightEdgeBetween(smallest, neighbor);\r\n\r\n                if (alt < distances[neighbor]) {\r\n                    distances[neighbor] = alt;\r\n                    previous[neighbor] = smallest;\r\n\r\n                    queue.enqueue(alt, neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        path.push(startNodeID);\r\n        path.reverse();\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\r\n        }\r\n\r\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\r\n    };\r\n\r\n    public static bellmanFord = (\r\n        startNodeID: number,\r\n        targetNodeID: number,\r\n        G: GraphImmut = GraphState.graph\r\n    ): ShortestPathResult | boolean => {\r\n        const distances: number[] = [];\r\n        const parents: (number | null)[] = [];\r\n\r\n        // Initialize\r\n        (G.getAllNodes(true) as NodeImmut[]).forEach(node => {\r\n            distances[node.getID()] = Infinity;\r\n            parents[node.getID()] = null;\r\n        });\r\n\r\n        // Relax Edges\r\n        distances[startNodeID] = 0;\r\n        for (let i = 0; i < G.getNumberOfNodes() - 1; i++) {\r\n            (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\r\n                if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                    distances[edge.getTo()] = distances[edge.getFrom()] + edge.getWeight();\r\n                    parents[edge.getTo()] = edge.getFrom();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for negative weight cycles\r\n        let negativeCylce = false;\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\r\n            if (distances[edge.getFrom()] + edge.getWeight() < distances[edge.getTo()]) {\r\n                negativeCylce = true;\r\n            }\r\n        });\r\n\r\n        if (distances[targetNodeID] !== Infinity) {\r\n            const path: number[] = [targetNodeID];\r\n            while (!path.includes(startNodeID)) {\r\n                path.push(parents[path.slice().pop()!] as number);\r\n            }\r\n            path.reverse();\r\n\r\n            return { pathExists: true, path, distance: path.length, cost: distances[targetNodeID] };\r\n        }\r\n\r\n        if (negativeCylce) {\r\n            return false;\r\n        }\r\n\r\n        return { pathExists: false, path: [], distance: -1, cost: 0 };\r\n    };\r\n\r\n    public static fordFulkerson = (\r\n        startNodeID: number,\r\n        targetNodeID: number,\r\n        G: GraphImmut = GraphState.graph\r\n    ): boolean | FlowResult => {\r\n        // Must be a directed graph\r\n        if (!G.isDirected()) {\r\n            return false;\r\n        }\r\n\r\n        // Source == sink\r\n        if (startNodeID === targetNodeID) {\r\n            return false;\r\n        }\r\n\r\n        const bfs = GraphAlgorithms.breadthFirstSearch(startNodeID, targetNodeID, G);\r\n        // No path from source to sink\r\n        if (!bfs.pathExists) {\r\n            return false;\r\n        }\r\n\r\n        // If we have a multigraph, then reduce the graph to have single edges with the sum of the capacities\r\n        G = G.reduceMultiGraph((a, b) => {\r\n            return a + b;\r\n        }, 0);\r\n\r\n        const V = G.getNumberOfNodes();\r\n        let value = 0;\r\n        let marked: boolean[] = [];\r\n        let edgeTo: (string | null)[] = [];\r\n\r\n        const edgeProperties: { [key: string]: EdgeFlowProp } = {};\r\n        (G.getAllEdges(true) as EdgeImmut[]).forEach(edge => {\r\n            edgeProperties[`${edge.getFrom()}_${edge.getTo()}`] = {\r\n                from: edge.getFrom(),\r\n                to: edge.getTo(),\r\n                capacity: edge.getWeight(),\r\n                flow: 0\r\n            };\r\n        });\r\n\r\n        const other = (e: string, x: number) => {\r\n            const edge = e.split(\"_\");\r\n            const a = parseInt(edge[0]);\r\n            const b = parseInt(edge[1]);\r\n            return x === a ? b : a;\r\n        };\r\n\r\n        const residualCapacity = (e: string, x: number) => {\r\n            const edge = e.split(\"_\");\r\n            const a = parseInt(edge[0]);\r\n            if (x === a) {\r\n                return edgeProperties[e].flow;\r\n            }\r\n            return edgeProperties[e].capacity - edgeProperties[e].flow;\r\n        };\r\n\r\n        const addResidualFlow = (e: string, x: number, deltaFlow: number) => {\r\n            const edge = e.split(\"_\");\r\n            const v = parseInt(edge[0]);\r\n            if (x === v) {\r\n                edgeProperties[e].flow -= deltaFlow;\r\n            } else {\r\n                edgeProperties[e].flow += deltaFlow;\r\n            }\r\n        };\r\n\r\n        const hasAugmentedPath = () => {\r\n            marked = [];\r\n            edgeTo = [];\r\n            for (let v = 0; v < V; ++v) {\r\n                marked.push(false);\r\n                edgeTo.push(null);\r\n            }\r\n\r\n            const queue = [];\r\n            queue.push(startNodeID);\r\n\r\n            marked[startNodeID] = true;\r\n            while (queue.length > 0) {\r\n                const v = queue.shift()!;\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (const i of vertexAdjacency) {\r\n                    const e = `${v}_${i}`;\r\n                    const w = other(e, v);\r\n                    if (!marked[w] && residualCapacity(e, w) > 0) {\r\n                        edgeTo[w] = e;\r\n                        marked[w] = true;\r\n                        if (w === targetNodeID) {\r\n                            return true;\r\n                        }\r\n\r\n                        queue.push(w);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        while (hasAugmentedPath()) {\r\n            let bottleneckValue = Infinity;\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\r\n                bottleneckValue = Math.min(bottleneckValue, residualCapacity(edgeTo[x]!, x));\r\n            }\r\n            for (let x = targetNodeID; x !== startNodeID; x = other(edgeTo[x]!, x)) {\r\n                addResidualFlow(edgeTo[x]!, x, bottleneckValue);\r\n            }\r\n            value += bottleneckValue;\r\n        }\r\n\r\n        const getFlows = (): EdgeFlowProp[] => {\r\n            const f: EdgeFlowProp[] = [];\r\n            for (let v = 0; v < V; v++) {\r\n                const vertexAdjacency = G.getNodeAdjacency(v);\r\n                for (const i of vertexAdjacency) {\r\n                    const e = `${v}_${i}`;\r\n                    if (edgeProperties[e].flow > 0) {\r\n                        f.push(edgeProperties[e]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return f;\r\n        };\r\n\r\n        return { maxFlow: value, flowPath: getFlows() };\r\n    };\r\n\r\n    public static kruskal = (G: GraphImmut = GraphState.graph): MSTResult => {\r\n        // If we have a multigraph, reduce it by using the minimum edge weights\r\n        G.reduceMultiGraph();\r\n\r\n        const Q: EdgeImmut[] = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        // Sort edges by weight so that they are added to the tree in the order of lowest possible weight\r\n        Q.sort((a, b) => {\r\n            return a.getWeight() - b.getWeight();\r\n        });\r\n\r\n        const kruskal: EdgeImmut[] = [];\r\n        const set = new SpanningTree(G.getNumberOfNodes());\r\n        while (Q.length > 0 && kruskal.length < G.getNumberOfNodes() - 1) {\r\n            const e = Q.shift()!;\r\n            if (!set.connected(e.getFrom(), e.getTo())) {\r\n                set.union(e.getFrom(), e.getTo());\r\n                kruskal.push(e);\r\n            }\r\n        }\r\n\r\n        // Get the total cost of the MST\r\n        const weight = kruskal.reduce((acc, e) => {\r\n            return acc + e.getWeight();\r\n        }, 0);\r\n\r\n        return { mst: (kruskal as any) as EdgeImmutPlain[], totalWeight: weight };\r\n    };\r\n\r\n    public static topologicalSort = (G: GraphImmut = GraphState.graph): boolean | NodeImmut[] => {\r\n        const adjacency = G.getFullAdjacency();\r\n        const degrees = graphH.findVertexDegreesDirectional(adjacency);\r\n\r\n        const L: NodeImmut[] = [];\r\n        const S: NodeImmut[] = (G.getAllNodes(true) as NodeImmut[]).filter(n => {\r\n            return degrees[n.getID()].in === 0;\r\n        });\r\n        let edges = G.getAllEdges(true) as EdgeImmut[];\r\n\r\n        while (S.length !== 0) {\r\n            const nodeN = S.pop()!;\r\n            L.push(nodeN);\r\n\r\n            const nodeNConnectedTo = adjacency[nodeN.getID()];\r\n\r\n            // Remove n to m edges for all nodes m\r\n            edges = edges.filter(edge => {\r\n                if (edge.getFrom() === nodeN.getID() && nodeNConnectedTo.includes(edge.getTo())) {\r\n                    degrees[edge.getTo()].in--;\r\n                    adjacency[nodeN.getID()] = adjacency[nodeN.getID()].filter(v => {\r\n                        return v !== edge.getTo();\r\n                    });\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            // If m has no more incoming edges, add it to S\r\n            nodeNConnectedTo.forEach(mID => {\r\n                if (degrees[mID].in === 0) {\r\n                    S.push(G.getNode(mID, true) as NodeImmut);\r\n                }\r\n            });\r\n        }\r\n\r\n        return edges.length > 0 || L;\r\n    };\r\n\r\n    public static isGraphCyclic = (G: GraphImmut = GraphState.graph): boolean => {\r\n        // If the topological sorting returns true, then it failed, so the graph has a cycle\r\n        return GraphAlgorithms.topologicalSort(G) === true;\r\n    };\r\n\r\n    public static directionalEulerian = (directionalDegrees: { in: number; out: number }[], scc: number[]): boolean => {\r\n        let eulerian = true;\r\n        let component = -1;\r\n        directionalDegrees.forEach((deg, id) => {\r\n            if (deg.in !== deg.out) {\r\n                eulerian = false;\r\n            }\r\n            if (deg.in > 0) {\r\n                if (component === -1) {\r\n                    component = scc[id];\r\n                }\r\n                if (component !== scc[id]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n\r\n    public static hasEulerianCircuit = (degrees: number[], cc: number[]): boolean => {\r\n        const oddDegree = degrees.filter(v => {\r\n            return v % 2 !== 0;\r\n        });\r\n\r\n        // If any nodes have odd degree, we can short-circuit the algorithm because it cannot be Eulerian\r\n        if (oddDegree.length !== 0) {\r\n            return false;\r\n        }\r\n\r\n        let eulerian = true;\r\n        let component = -1;\r\n        degrees.forEach((v, i) => {\r\n            if (v !== 0) {\r\n                if (component === -1) {\r\n                    component = cc[i];\r\n                }\r\n                if (component !== cc[i]) {\r\n                    eulerian = false;\r\n                }\r\n            }\r\n        });\r\n\r\n        return eulerian;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\nexport default class SpanningTree {\r\n    private readonly id: number[];\r\n\r\n    constructor(V: number) {\r\n        this.id = [];\r\n        for (let v = 0; v < V; v++) {\r\n            this.id.push(v);\r\n        }\r\n    }\r\n\r\n    union(v: number, w: number) {\r\n        const q = this.root(v);\r\n        const p = this.root(w);\r\n\r\n        if (p !== q) {\r\n            this.id[p] = q;\r\n        }\r\n    }\r\n\r\n    root(q: number) {\r\n        while (this.id[q] !== q) {\r\n            q = this.id[q];\r\n        }\r\n        return q;\r\n    }\r\n\r\n    connected(v: number, w: number) {\r\n        return this.root(v) === this.root(w);\r\n    }\r\n}\r\n","import GraphAlgorithms from \"../GraphAlgorithms\";\r\nconst ctx: Worker = self as any;\r\n\r\nlet myID: number;\r\n\r\nfunction sleep(ms: number) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nctx.addEventListener(\"message\", async e => {\r\n    if (e.data.type === \"id\") {\r\n        myID = e.data.id;\r\n        return;\r\n    }\r\n    const args: any[] = e.data.args;\r\n    if (e.data.type === \"test\") {\r\n        await sleep(e.data.waitTime);\r\n        ctx.postMessage({ id: myID, data: \"DONE\" });\r\n        return;\r\n    }\r\n    if (\"convertToGraphImmut\" in e.data && e.data.convertToGraphImmut) {\r\n        args.push(GraphAlgorithms.graphPlainToGraphImmut(e.data.graph));\r\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\r\n    } else {\r\n        ctx.postMessage({ id: myID, data: (GraphAlgorithms as any)[e.data.type].apply(null, args) });\r\n    }\r\n});\r\n"],"names":["graphPlainToGraphImmut","gp","nodes","edges","directed","weighted","colorNetwork","G","nodeArr","getAllNodes","degrees","getAllOutDegrees","vertexOrder","a","b","colorIndex","currentColor","length","root","shift","myGroup","push","i","p","conflict","j","areAdjacent","splice","colors","chromaticNumber","connectedComponents","components","componentCount","setComponentNum","v","getNumberOfNodes","GraphAlgorithms","depthFirstSearch","forEach","count","start","visisted","Stack","pop","includes","getNodeAdjacency","nodeID","stronglyConnectedComponents","index","indices","lowlink","S","strongConnect","w","Math","min","breadthFirstSearch","startNodeID","targetNodeID","Q","edgeTo","x","y","path","reverse","weight","getMinWeightEdgeBetween","pathExists","distance","dijkstraSearch","isDirected","asDirected","isWeighted","asWeighted","getAllEdges","find","edge","getWeight","queue","_nodes","enqueue","priority","key","this","sort","dequeue","isEmpty","distances","previous","node","dist","Infinity","getID","smallest","neighbor","alt","cost","bellmanFord","parents","getFrom","getTo","negativeCylce","slice","fordFulkerson","V","reduceMultiGraph","value","marked","edgeProperties","from","to","capacity","flow","other","e","split","parseInt","residualCapacity","addResidualFlow","deltaFlow","hasAugmentedPath","bottleneckValue","maxFlow","flowPath","f","getFlows","kruskal","set","connected","union","reduce","acc","mst","totalWeight","topologicalSort","adjacency","getFullAdjacency","L","filter","n","in","nodeN","nodeNConnectedTo","mID","getNode","isGraphCyclic","directionalEulerian","directionalDegrees","scc","eulerian","component","deg","id","out","hasEulerianCircuit","cc","q","myID","ctx","self","addEventListener","data","type","args","ms","waitTime","Promise","resolve","setTimeout","postMessage","convertToGraphImmut","graph","apply"],"sourceRoot":""}